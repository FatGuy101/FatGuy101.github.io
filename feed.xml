<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://fattt.org.edu.kg//jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="https://fattt.org.edu.kg//jekyll-theme-yat/" rel="alternate" type="text/html" /><updated>2024-01-04T14:05:16+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/feed.xml</id><title type="html">Fattt blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>FatGuy101</name></author><entry><title type="html">有关Kubernetes的面试题</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/K8sInterviewQuestions" rel="alternate" type="text/html" title="有关Kubernetes的面试题" /><published>2023-11-30T00:00:00+00:00</published><updated>2023-11-30T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/Kubenetes%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/K8sInterviewQuestions"><![CDATA[<h2 id="什么是pod-">什么是pod ？</h2>

<ol>
  <li>在docker中支持以containers容器的方式部署应用,但是一个容器只能部署一个软件应用,实际情况中如果想让一个软件正常运行通常需要部署多个应用配合运行才能对外提供功能,docker中针对这种情况会把这些应用部署为一组容器,比较繁琐</li>
  <li>Pod是k8s中最小的部署单元,一个pod中可以运行一个或多个容器,这些容器共享存储、网络、以及怎样运行这些容器的声明,一般不直接创建Pod，而是创建一些工作负载由工作负载来创建Pod</li>
  <li>pod 内的容器都是平等的</li>
</ol>

<h2 id="直接创建-pod的缺点-">直接创建 pod的缺点 ?</h2>

<ol>
  <li>直接创建的pod,该pod中的容器如果宕机异常,有恢复功能, 但是这个pod如果宕机异常不会有恢复功能,所以创建一些工作负载由他们来创建Pod,实现pod的异常恢复功能</li>
  <li>在直接部署pod时,虽然可以通过podIP属性指定该pod的访问ip,但是集群网络是私有的,该地址只能在集群内部访问,如果想允许外部访问需要创建Service来公开Pod的网络终结点</li>
</ol>

<h2 id="pod-中的多容器协同">Pod 中的多容器协同</h2>

<ol>
  <li>
    <p>什么是多容器协同: 在一个pod中部署多个Container应用容器,多个应用容器配合工作</p>

    <ul>
      <li>
        <p>网络：每个Pod都会被分配一个唯一的IP地址<strong>,Pod中的所有容器共享网络空间</strong>,包括IP地址和端口。Pod内部的容器可以使用localhost互相通信。Pod中的容器与外界通信时，必须分配共享网络资源（例如使用宿主机的端口映射）</p>
      </li>
      <li>
        <p>存储: 可以Pod指定多个共享的Volume。Pod中的所有容器共享volume。Volume也可以用来持久化Pod中的存储资源，以防容器重启后文件丢失</p>
      </li>
    </ul>
  </li>
  <li>
    <p>多容器协同的好处:</p>
  </li>
</ol>

<ul>
  <li>
    <p>举个不太恰当的例子,服务间相互调用现在有a,b,c,d四个服务,d是配合工作的附加服务,多个服务间是通过d服务进行通信的,这样在pod中就可以部署为”a,d”,“b,d”,”c,d”在pod内部abc三个主服务都附加一个d服务</p>
  </li>
  <li>
    <p>优点:</p>

    <ul>
      <li>
        <p>将相关的服务放在同一个 Pod 中可以共享资源,例如网络和存储，避免了在不同 Pod 之间进行跨节点通信的开销</p>
      </li>
      <li>
        <p>更高的可靠性：这种部署方式可以增加服务之间的稳定性和可靠性,可以通过本地的 localhost 直接通信，而且共享相同的生命周期</p>
      </li>
      <li>
        <p>简化部署和管理：将相关服务打包到同一个 Pod 中可以简化部署和管理过程。例如可以通过 Deployment 或 StatefulSet 来管理 Pod，可以实现集中的配置、更新和扩展，同时降低了管理成本</p>
      </li>
      <li>
        <p>安全性增强：因为打包到同一个pod的服务之间的通信是通过 localhost 进行的，不需要经过网络暴露，减少了一些潜在的攻击</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="pod-的组成与paush-重要">Pod 的组成与paush (重要)</h2>

<ol>
  <li>
    <p>一个pod中可以部署多个容器，多个容器之间共享网络，通过localhost就可以通信,共享文件资源。每个pod中除了运行的应用容器外，每个pod内部都存在一个特殊的Pause容器。</p>

    <p><a href="https://imgse.com/i/pi4AzWt"><img src="https://s11.ax1x.com/2023/12/15/pi4AzWt.png" alt="pi4AzWt.png" /></a></p>
  </li>
  <li>
    <p>Pasu 容器通过 <code class="language-plaintext highlighter-rouge">kubectl get pods</code> 是看不到的，需要在 对应节点的下通过 <code class="language-plaintext highlighter-rouge">docker ps | grep</code> “pod名称”才可看到</p>
  </li>
  <li>
    <p>每个pod内部都会部署一个Pause特殊容器,pod在启动容器时会优先启动这个特殊容器,可以将这个特殊容器看成用来管理同一pod下的其它应用容器的,它负责了: <strong>创建和占用pod的NetworkNamespace网络命名空间和PID命名空间:</strong></p>

    <ul>
      <li>
        <p>简单解释就是pause容器在启动时,会为 pod 生成一个独立的网络环境和进程环境,并将这些环境与其他 pod 隔离开,其中:</p>
      </li>
      <li>
        <p>创建和占用pod的NetworkNamespace网络命名空间,网络命名空间是Linux的一种技术,通过pause为pod分配一个虚拟 IP 地址分配一个独立的虚拟网络接口和 IP 地址,当前pod中的其他用户容器就可以加入到这个网络命名空间中,从而共享同一个IP和网络接口,提供了网络通信环境,使得它们可以通过 localhost 进行通信,也可以访问外部网络</p>
      </li>
      <li>
        <p>创建和占用pod 的 PID 命名空间，并为自己分配一个 PID 为 1 的进程，pod 中的其他用户容器就可以加入到这个 PID 命名空间中,共享同一个进程 ID 空间,通过共享进程ID空间实现了: 1pod 内的容器之间的进程监控和管理, 2pod 内的容器之间的信号传递, 3pod 内的容器之间的僵尸进程的回收避免了资源泄漏(注意好像在1.8版本中被修改默认情况下是禁用的)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>回收僵尸进程的步骤如下：</p>

    <ul>
      <li>
        <p>首先，当 pod 中的某个用户容器启动时，它会加入到 pause 容器创建和占用的 PID 命名空间中，从而共享同一个进程 ID 空间</p>
      </li>
      <li>
        <p>当 pod 中的某个用户容器中的某个子进程退出时，会变成一个僵尸进程，也就是已经结束运行，但是还没被父进程回收</p>
      </li>
      <li>
        <p>由于 pod 中的所有容器都在同一个 PID 命名空间中，所以都可以看到这个僵尸进程，并且可以向它发送 SIGCHLD 信号，通知它的父进程回收它</p>
      </li>
      <li>
        <p>pause 容器是 pod 中第一个启动的容器，并且分配了 PID 为 1 的进程，它会成为 pod 中所有孤儿进程（没有父进程或者父进程已经退出的进程）的父进程。因此，当 pause 容器收到 SIGCHLD 信号时，它会调用 wait() 函数来回收僵尸进程，并释放其占用的资源</p>
      </li>
    </ul>
  </li>
</ol>

<ul>
  <li>
    <h3 id="面试题">面试题:</h3>
  </li>
</ul>

<p>为什么一个pod中的多个容器可以共享网络:</p>

<p>因为在pod在部署容器时,每个应用都会多部署一个对应的paush容器,通过这个paush容器设置来设置当前实际容器的网络</p>

<ul>
  <li>
    <h3 id="面试题-1">面试题:</h3>
  </li>
</ul>

<p>如果pod中的容器宕机重启,ip会变吗?</p>

<p>不会,底层会通过对应的paush去设置网络,但是如果重建 pod 则IP 可能会变化</p>

<h2 id="pod-的生命周期">Pod 的生命周期</h2>

<ol>
  <li>
    <p>pod对象从创建到终止的这段时间范围称为pod的生命周期,主要包含:</p>

    <ul>
      <li>
        <p>pod创建</p>
      </li>
      <li>
        <p>运行初始化容器（initContainer）</p>
      </li>
      <li>
        <p>运行主容器（main container）过程</p>
      </li>
      <li>
        <p>容器启动后钩子postStart执行，容器终止前preStop钩子</p>
      </li>
      <li>
        <p>容器的存活性探测（liveness probe），就绪性探测（readness probe）</p>
      </li>
      <li>
        <p>pod终止</p>
      </li>
    </ul>
  </li>
  <li>
    <p>在整个声明周期中，Pod会出现5种状态(相位)</p>

    <ul>
      <li>
        <p>挂起Pending：挨批server已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</p>
      </li>
      <li>
        <p>运行中Running：pod已经被调度至某节点，并且所有容器都已经被kubectl创建完成</p>
      </li>
      <li>
        <p>成功Succeed：pod中的所有容器都已经成功终止并且不会被重启</p>
      </li>
      <li>
        <p>失败Failed：所有容器都已经停止，但至少有一个容器终止失败，即容器返回了非0的退出状态</p>
      </li>
      <li>
        <p>未知Unknown：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所致</p>
      </li>
    </ul>
  </li>
  <li>Pod的创建过程详解:
    <ul>
      <li>
        <p>用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer</p>
      </li>
      <li>
        <p>apiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</p>
      </li>
      <li>
        <p>apiServer开始反映etcd中的pod对象的变化，其他组件使用watch机制来跟踪检查apiServer上的变动</p>
      </li>
      <li>
        <p>scheduler发现有新的pod对象要创建，开始为pod分配足迹并将结果更新只apiServer</p>
      </li>
      <li>
        <p>node节点上的kubectl发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer</p>
      </li>
      <li>
        <p>apiServer将接收到的pod状态信息存入etcd中</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Pod的终止过程详解:</p>

    <ul>
      <li>
        <p>用户向apiServer发送删除pod对象的命令,执行<code class="language-plaintext highlighter-rouge">kubectl delete {pod_id}</code>删除老pod</p>
      </li>
      <li>
        <p>在删除pod时好像有一个在宽限期默认30秒，此时pod被视为dead</p>
      </li>
      <li>
        <p>后续apiServer接收到删除命令后,会在etd中将根据pod_id将老pod标记为terminating退出中</p>
      </li>
      <li>
        <p>kube-proxy监听endPoint,当发现pod对象转为terminating状态,会触发iptables-restore,生成全新的iptables规则(上线pod时会执行多次,下线pod时好些只会执行一次),新的iptables DNAT规则中就会删除当前pod_id,将当前pod提出负载均衡</p>
      </li>
      <li>
        <p>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式执行</p>
      </li>
      <li>
        <p>kubelet监听到etcd中pod status状态变化,当发现属于当前节点时,走针对pod的实际退出流程—&gt;preStop执行pod的退出回调–&gt;关闭监听端口–&gt;处理现有连接–&gt;完成退出</p>
      </li>
      <li>
        <p>注意kube-proxy检查到下线pod命令执行删除地址动作与kubelet执行删除实际pod是同步执行的,所以可能会出现pod已经实际删除了,但是地址还存在endpoint列表中,造成请求异常</p>
      </li>
    </ul>
  </li>
</ol>

<h2 id="静态pod">静态Pod</h2>

<p>kl8s中pod分为静态pod与动态pod,我们使用k8s指定部署的应用pod称为动态pod,而k8s这个服务中的基础设施启动需要的pod称为静态pod, 在<code class="language-plaintext highlighter-rouge">/etc/kubernetes/manifests</code>位置放了创建这些静态pod的Pod.yaml文件，机器启动kubelet自己就把他启动起来。静态Pod一直守护在他的这个机器上</p>

<h2 id="探针">探针</h2>

<p>​	上面了解到pod是有状态有生命周期的,通过这个状态又延伸出了重启策略, 重启底层实际就基于探针实现的,通过探测和重启策略实现了服务的健康检查,0宕机</p>

<p>​	在容器的containers中存在三个属性: <strong>startupProbe启动探针, livenessProbe存活探针, readinessProbe就绪探针</strong></p>

<ul>
  <li>
    <p>startupProbe启动探针: 用来探测当前容器是否启动成功</p>
  </li>
  <li>
    <p>livenessProbe存活探针: 用来判断当前容器是否存活,例如当探测到容器不存活时,会重新拉起</p>
  </li>
  <li>
    <p>readinessProbe就绪探针: 用来探测当前容器是否就绪,能否能够对外提供服务,以调用服务负载均衡为例,当接收到请求后如果通过该探针探测到某个服务节点不可用,则不会将该节点加入负载均衡</p>
  </li>
</ul>

<p>​	探针支持的三种设置方法(与钩子相同)</p>

<ul>
  <li>
    <p>exec: 通过钩子程序执行命令</p>
  </li>
  <li>
    <p>httpGet:通过钩子发送http get请求</p>
  </li>
  <li>
    <p>tcpSocket: 容器创建之后连接tcp端口进行指定操作</p>
  </li>
</ul>

<ol>
  <li>
    <h3 id="livenessprobe存活探针">livenessProbe存活探针</h3>

    <ul>
      <li>
        <p>livenessProbe存活探针用于判断容器是不是健康，如果不满足健康条件，Kubelet 将根据 Pod 中设置的 restartPolicy 重启策略来判断，Pod 是否要进行重启。</p>
      </li>
      <li>
        <p>LivenessProbe按照配置去探测 ( 进程、或者端口、或者命令执行后是否成功等等)，来判断容器是不是正常。如果探测不到，代表容器不健康（可以配置连续多少次失败才记为不健康），则 kubelet 会杀掉该容器，并根据容器的重启策略做相应的处理。</p>
      </li>
      <li>
        <p>如果未配置存活探针，则默认容器启动为Success通过状态。即Success后pod状态是RUNING</p>
      </li>
    </ul>
  </li>
  <li>
    <h3 id="readinessprobe就绪探针">readinessProbe就绪探针</h3>

    <ul>
      <li>
        <p>readinessProbe就绪探针，用于判断容器内的程序是否存活或者说是否健康，是否启动完成并就绪,正常对外提供服务</p>
      </li>
      <li>
        <p>容器启动后会按照readinessProbe的配置进行探测, 探测成功返回 Success。pod的READY状态变为 true，更新pod成功数量比如1/1，否则还是0/1。</p>
      </li>
      <li>
        <p>若未配置就绪探针，则默认容器启动后状态Success。此时pod、pod关联的Service、EndPoint 等资源都会进入Ready 状态,进行相关设置</p>
      </li>
      <li>
        <p>后续程序运行中还可以通过readinessProbe继续监测, 如果探测失败,更新Pod 的 Ready 状态变为 false，系统则会在对应的Service关联的 EndPoint 列表中去除此pod地址，实现服务的异常踢除。如果 Pod 恢复为 Ready 状态。将再会被加回 Endpoint 列表。kube-proxy也将有概率通过负载机制会引入流量到此pod中</p>
      </li>
    </ul>
  </li>
  <li>
    <h3 id="startupprobe启动探针">startupProbe启动探针</h3>

    <ul>
      <li>
        <p>启动探针时 k8s 在1.16版本后增加startupProbe探针，主要解决在复杂的程序中readinessProbe、livenessProbe探针无法更好的判断程序是否启动、是否存活。进而引入startupProbe探针为readinessProbe、livenessProbe探针服务,</p>
      </li>
      <li>
        <p>startupProbe探针与另两种区别: 如果三个探针同时存在，先执行startupProbe探针，其他两个探针将会被暂时禁用，直到pod满足startupProbe探针配置的条件，其他2个探针启动，如果不满足按照规则重启容器, 另外两种探针在容器启动后，会按照配置，直到容器消亡才停止探测，而startupProbe探针只是在容器启动后按照配置满足一次后，不在进行后续的探测</p>
      </li>
    </ul>
  </li>
  <li>
    <h3 id="就绪存活两种探针的区别">就绪、存活两种探针的区别</h3>

    <ul>
      <li>
        <p>ReadinessProbe 和 livenessProbe 可以使用相同探测方式，只是对 Pod 的处置方式不同：</p>
      </li>
      <li>
        <p>readinessProbe 当检测失败后，将 Pod 的 IP:Port 从对应的 EndPoint 列表中删除。</p>
      </li>
      <li>
        <p>livenessProbe 当检测失败后，将杀死容器并根据 Pod 的重启策略来决定作出对应的措施</p>
      </li>
    </ul>
  </li>
  <li>
    <h3 id="startupprobe的存在意义">startupProbe的存在意义？</h3>

    <ul>
      <li>startupProbe 和 livenessProbe 最大的区别就是startupProbe在探测认为成功之后就不会继续探测了，而livenessProbe在pod的生命周期中一直在探测,并且其它探针是在startupProbe认为成功后才会执行,。如果只设置livenessProbe探针会存在如下问题： “一个服务如果前期启动需要很长时间，那么它后面死亡未被发现的时间就越长，为什么会这么说呢？假设我们一个服务A启动完成需要2分钟，那么我们如下开始定义livenessProbe,5s就会根据重启策略进行一次重启，这个时候你会发现pod一直会陷入死循环”</li>
    </ul>
  </li>
  <li>
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">livenessProbe</span><span class="pi">:</span>
  <span class="na">httpGet</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/test</span>
    <span class="na">prot</span><span class="pi">:</span> <span class="m">80</span>
<span class="na">failureThreshold</span><span class="pi">:</span> <span class="m">1</span>
<span class="na">initialDelay</span><span class="pi">:</span> <span class="m">5</span>
<span class="na">periodSeconds</span><span class="pi">:</span> <span class="m">5</span>
</code></pre></div>    </div>

    <ul>
      <li>为解决以上问题修改为,使用启动探针startupProbe,程序有605s=300s的启动时间，当startupProbe探针探测成功之后，才会被livenessProbe接管，这样在运行中出问题livenessProbe就能在15=5s内发现。如果启动探测是3分钟内还没有探测成功，则接受Pod的重启策略进行重启</li>
    </ul>
  </li>
  <li>
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">livenessProbe</span><span class="pi">:</span>
  <span class="na">httpGet</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/test</span>
    <span class="na">prot</span><span class="pi">:</span> <span class="m">80</span>
<span class="na">failureThreshold</span><span class="pi">:</span> <span class="m">1</span>
<span class="na">initialDelay</span><span class="pi">:</span> <span class="m">5</span>
<span class="na">periodSeconds</span><span class="pi">:</span> <span class="m">5</span>
   
<span class="na">startupProbe</span><span class="pi">:</span>
  <span class="na">httpGet</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/test</span>
    <span class="na">prot</span><span class="pi">:</span> <span class="m">80</span>
<span class="na">failureThreshold</span><span class="pi">:</span> <span class="m">60</span>
<span class="na">initialDelay</span><span class="pi">:</span> <span class="m">5</span>
<span class="na">periodSeconds</span><span class="pi">:</span> <span class="m">5</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="pod的tolerations容忍策略相关">Pod的tolerations容忍策略相关</h2>

<ol>
  <li>
    <p>Pod中可以通过tolerations进行容忍相关设置,实现了如下功能</p>

    <ul>
      <li>调度约束：通过设置tolerations容忍,可以将pod调度安装到指定节点上</li>
      <li>弹性和容错性：在节点出现故障或维护时，节点上的Pod可能需要迁移到其他节点上。通过定义tolerations，可以确保Pod仍然能够被分配到指定节点上,并且可以设置等待迁移时间</li>
    </ul>
  </li>
  <li>
    <p>Pod下tolerations内部是一个数组属性,可以设置多个容忍规则,其中内部包含:</p>

    <ol>
      <li>
        <p>key：设置需要匹配的污点(注意此处除了可以设置自定义污点外,也可以设置k8s内部预定义的污点,实现某些特殊功能)</p>
      </li>
      <li>
        <p>operator：指定如何与节点上的污点进行比较。常用的匹配操作符有以下几种：</p>

        <ul>
          <li>
            <p>Equal：要求污点的键值与toleration规则的键值完全相等。</p>
          </li>
          <li>
            <p>Exists：只要存在与toleration规则的键相同的污点键，即可匹配成功。</p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
  <li>
    <p>value：匹配的值,污点也是有值的,当污点匹配成功后,匹配污点的值,如果未指定该属性，则默认为”“空字符串。</p>
  </li>
  <li>
    <p>effect：设置匹配成功后的执行规则,可以设置为以下几种：</p>

    <ul>
      <li>
        <p>NoSchedule：当Pod满足toleration规则时，将不会被调度到带有匹配污点的节点上。</p>
      </li>
      <li>
        <p>PreferNoSchedule：当Pod满足toleration规则时，尽量不要被调度到带有匹配污点的节点上，但并不是绝对禁止调度</p>
      </li>
      <li>
        <p>NoExecute：当Pod满足toleration规则时，如果该节点上已经存在该污点，则会从该节点上驱逐（删除）Pod。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>tolerationSeconds：定义容忍时间，用于指定容忍期限。当一个节点上的污点超过了容忍时间，Pod将被驱逐。该属性是可选的，如果未指定，默认为tolerationSeconds: null，表示没有容忍期限</p>

    <p>例如：</p>
  </li>
  <li>
    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-pod</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">my-container</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
  <span class="na">tolerations</span><span class="pi">:</span>  <span class="c1"># 指定tolerations部分</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s2">"</span><span class="s">critical-node"</span>  <span class="c1"># 指定需要容忍的污点</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Equal"</span>  <span class="c1"># 指定如何与节点上的污点进行比较,当前是做等值判断</span>
      <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">true"</span>  <span class="c1"># 指定节点上污点的预期值判断,默认为""空字符串</span>
      <span class="na">effect</span><span class="pi">:</span> <span class="s2">"</span><span class="s">NoSchedule"</span>  <span class="c1"># 当匹配规则满足时的作用效果,当前表示为不调度安装到存在该污点的节点</span>
</code></pre></div>    </div>
  </li>
  <li>
    <h3 id="k8s内置的污点与节点异常容忍时间问题">k8s内置的污点与节点异常容忍时间问题</h3>

    <ol>
      <li>
        <p>k8s中内置了多种污点,可以将这些污点设置到tolerations的key属性上实现一些特殊功能,例如</p>

        <ul>
          <li>node.kubernetes.io/not-ready: 用于表示节点当前处于不可用状态</li>
          <li>node.kubernetes.io/unreachable：用于标记节点不可达。当节点无法与集群通信时，该污点会自动添加到节点上，以确保不会将新的Pod调度到该节点上。</li>
          <li>node.kubernetes.io/out-of-disk：用于标记节点磁盘空间不足。当节点的可用磁盘空间不足时，该污点会自动添加到节点上，防止将新的Pod调度到可能导致更多磁盘使用的节点上。</li>
          <li>node.kubernetes.io/memory-pressure：用于标记节点内存压力过大。当节点的可用内存资源不足时，该污点会自动添加到节点上，以避免将新的Pod调度到可能导致更多内存使用的节点上。</li>
          <li>node.kubernetes.io/disk-pressure：用于标记节点磁盘压力过大。当节点的磁盘压力过大时，该污点会自动添加到节点上，以避免将新的Pod调度到可能导致更多磁盘使用的节点上。</li>
          <li>node.kubernetes.io/network-unavailable：用于标记节点网络不可用。当节点的网络无法正常工作时，该污点会自动添加到节点上，以防止将新的Pod调度到网络不可用的节点上。</li>
        </ul>
      </li>
      <li>
        <p>以节点异常容忍时间为例举例说明内置污点的使用,首先什么是节点的异常容忍时间,意思是k8s集群中如果某个节点意外宕机,在发生宕机时,该节点上部署的应用会自动迁移到其它可用节点,迁移过程可能需要一些时间,取决与硬件性能,网络性能,镜像拉取时间等等,为此k8s引入了一个称为”容忍时间”Toleration的概念,用于控制每个Pod在发生迁移时,允许等待的时间，默认为300秒,如果在这个等待时间内没有重新调度到其它节点完成运行,这个pod将会标记为丢失状态(注意这个等待时间只对已经允许的pod有效,对于新部署的pod无效)</p>
      </li>
      <li>
        <p>如何修改容忍时间,或者如何缩短容忍时间(不要修改过短,要考虑服务的启动时间,如果过短考虑网络延迟问题,会出现pod反复迁移),通过部署pod的tolerations属性设置</p>

        <ul>
          <li>
            <p>首先在节点发生异常时,会自动给节点添加 node.kubernetes.io/not-ready表示当前节点处于不可用状态的污点,和node.kubernetes.io/unreachable节点通信异常表示当前节点不可达的污点</p>
          </li>
          <li>
            <p>在pod模板中的tolerations属性中,通过key设置匹配这两个污点,设置不在存在该污点的节点上调度安装</p>
          </li>
          <li>
            <p>在pod模板中的tolerations属性中,通过tolerationSeconds指定容忍时间,当前不设置默认为300秒,既在pod发生迁移时如果指定时间内为迁移成功,该pod会标记为丢失状态</p>

            <p>例如：</p>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ol>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">example-pod</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">my-container</span>
      <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">tolerations</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s">node.kubernetes.io/unreachable</span> <span class="c1">#匹配的污点,该污点是k8s内置的</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s">Exists</span> <span class="c1">#匹配规则,Exists表示存在</span>
      <span class="na">effect</span><span class="pi">:</span> <span class="s">NoSchedule</span>
      <span class="na">tolerationSeconds</span><span class="pi">:</span> <span class="m">300</span>  <span class="c1"># 设置容忍时间默认300秒</span>
    <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s">node.kubernetes.io/not-ready</span> <span class="c1">#匹配的污点,该污点是k8s内置的</span>
      <span class="na">operator</span><span class="pi">:</span> <span class="s">Exists</span> <span class="c1">#匹配规则,Exists表示存在</span>
      <span class="na">effect</span><span class="pi">:</span> <span class="s">NoSchedule</span> <span class="c1">#效果,NoSchedule表示如果匹配成功,则在对应的节点上驱逐,也就是不会调度安装到对应的节点上</span>
      <span class="na">tolerationSeconds</span><span class="pi">:</span> <span class="m">300</span>  <span class="c1"># 设置容忍时间默认300秒</span>
</code></pre></div></div>

<h2 id="k8s-面试题整理">K8s 面试题整理:</h2>

<p><strong>1、 k8s是什么？请说出你的了解</strong>？</p>

<p>答：Kubernetes是一个针对容器应用，进行自动部署，弹性伸缩和管理的开源系统。主要功能是生产环境中的容器编排。</p>

<p>K8S是Google公司推出的，它来源于由Google公司内部使用了15年的Borg系统，集结了Borg的精华。</p>

<p><strong>2、 K8s架构的组成是什么？</strong></p>

<p>答：和大多数分布式系统一样，K8S集群至少需要一个主节点（Master）和多个计算节点（Node）。</p>

<ul>
  <li>主节点主要用于暴露API，调度部署和节点的管理；</li>
  <li>计算节点运行一个容器运行环境，一般是docker环境（类似docker环境的还有rkt），同时运行一个K8s的代理（kubelet）用于和master通信。计算节点也会运行一些额外的组件，像记录日志，节点监控，服务发现等等。计算节点是k8s集群中真正工作的节点。</li>
</ul>

<p>K8S架构细分：</p>

<p>1、Master节点（默认不参加实际工作）：</p>

<ul>
  <li>Kubectl：客户端命令行工具，作为整个K8s集群的操作入口；</li>
  <li>Api Server：在K8s架构中承担的是“桥梁”的角色，作为资源操作的唯一入口，它提供了认证、授权、访问控制、API注册和发现等机制。客户端与k8s群集及K8s内部组件的通信，都要通过Api Server这个组件；</li>
  <li>Controller-manager：负责维护群集的状态，比如故障检测、自动扩展、滚动更新等；</li>
  <li>Scheduler：负责资源的调度，按照预定的调度策略将pod调度到相应的node节点上；</li>
  <li>Etcd：担任数据中心的角色，保存了整个群集的状态；</li>
</ul>

<p>2、Node节点：</p>

<ul>
  <li>
    <p>Kubelet：负责维护容器的生命周期，同时也负责Volume和网络的管理，一般运行在所有的节点，是Node节点的代理，当Scheduler确定某个node上运行pod之后，会将pod的具体信息（image，volume）等发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向master返回运行状态。（自动修复功能：如果某个节点中的容器宕机，它会尝试重启该容器，若重启无效，则会将该pod杀死，然后重新创建一个容器）；</p>
  </li>
  <li>
    <p>Kube-proxy：Service在逻辑上代表了后端的多个pod。负责为Service提供cluster内部的服务发现和负载均衡（外界通过Service访问pod提供的服务时，Service接收到的请求后就是通过kube-proxy来转发到pod上的）；</p>
  </li>
</ul>

<p>container-runtime：是负责管理运行容器的软件，比如docker</p>

<ul>
  <li>Pod：是k8s集群里面最小的单位。每个pod里边可以运行一个或多个container（容器），如果一个pod中有两个container，那么container的USR（用户）、MNT（挂载点）、PID（进程号）是相互隔离的，UTS（主机名和域名）、IPC（消息队列）、NET（网络栈）是相互共享的。</li>
</ul>

<p><strong>3、 容器和主机部署应用的区别是什么？</strong></p>

<p>答：容器的中心思想就是秒级启动；一次封装、到处运行；这是主机部署应用无法达到的效果，但同时也更应该注重容器的数据持久化问题。</p>

<p>另外，容器部署可以将各个服务进行隔离，互不影响，这也是容器的另一个核心概念。</p>

<p><strong>4、请说一下kubernetes针对pod资源对象的健康监测机制？</strong></p>

<p>答：K8s中对于pod资源对象的健康状态检测，提供了三类probe（探针）来执行对pod的健康监测：</p>

<ol>
  <li>
    <p>livenessProbe探针</p>

    <p>​	可以根据用户自定义规则来判定pod是否健康，如果livenessProbe探针探测到容器不健康，则kubelet会根据其重启策略来决定是否重启，如果一个容器不包含livenessProbe探针，则kubelet会认为容器的livenessProbe探针的返回值永远成功。</p>
  </li>
  <li>
    <p>ReadinessProbe探针</p>

    <p>​	同样是可以根据用户自定义规则来判断pod是否健康，如果探测失败，控制器会将此pod从对应service的endpoint列表中移除，从此不再将任何请求调度到此Pod上，直到下次探测成功。</p>
  </li>
  <li>
    <p>startupProbe探针</p>

    <p>​	启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉，这个问题也可以换另一种方式解决，就是定义上面两类探针机制时，初始化时间定义的长一些即可。</p>
  </li>
</ol>

<p>每种探测方法能支持以下几个相同的检查参数，用于设置控制检查时间：</p>

<ul>
  <li>
    <p>initialDelaySeconds：初始第一次探测间隔，用于应用启动的时间，防止应用还没启动而健康检查失败</p>
  </li>
  <li>
    <p>periodSeconds：检查间隔，多久执行probe检查，默认为10s；</p>
  </li>
  <li>
    <p>timeoutSeconds：检查超时时长，探测应用timeout后为失败；</p>
  </li>
  <li>
    <p>successThreshold：成功探测阈值，表示探测多少次为健康正常，默认探测1次。</p>
  </li>
</ul>

<p>上面两种探针都支持以下三种探测方法：</p>

<ol>
  <li>Exec：通过执行命令的方式来检查服务是否正常，比如使用cat命令查看pod中的某个重要配置文件是否存在，若存在，则表示pod健康。反之异常。</li>
  <li>Httpget：通过发送http/htps请求检查服务是否正常，返回的状态码为200-399则表示容器健康（注http get类似于命令curl -I）。</li>
  <li>tcpSocket：通过容器的IP和Port执行TCP检查，如果能够建立TCP连接，则表明容器健康，这种方式与HTTPget的探测机制有些类似，tcpsocket健康检查适用于TCP业务。</li>
</ol>

<p>在上述的yaml配置文件中，两类探针都使用了，在容器启动5秒后，kubelet将发送第一个readinessProbe探针，这将连接容器的8080端口，如果探测成功，则该pod为健康，十秒后，kubelet将进行第二次连接。</p>

<p>除了readinessProbe探针外，在容器启动15秒后，kubelet将发送第一个livenessProbe探针，仍然尝试连接容器的8080端口，如果连接失败，则重启容器。</p>

<p>探针探测的结果无外乎以下三者之一：</p>

<ul>
  <li>Success：Container通过了检查；</li>
  <li>Failure：Container没有通过检查；</li>
  <li>Unknown：没有执行检查，因此不采取任何措施（通常是没有定义探针检测，默认为成功）。</li>
</ul>

<p><strong>5、 如何控制滚动更新过程？</strong></p>

<p>答：可以通过下面的命令查看到更新时可以控制的参数：</p>

<ul>
  <li>maxSurge：此参数控制滚动更新过程，副本总数超过预期pod数量的上限。可以是百分比，也可以是具体的值。默认为1。</li>
  <li>maxUnavailable：此参数控制滚动更新过程中，不可用的Pod的数量。</li>
</ul>

<p><strong>6、什么是Kubernetes？它的主要目标是什么？</strong></p>

<p>答：Kubernetes是一个开源容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它的主要目标是简化容器化应用的部署和管理，并提供弹性、可靠的应用程序编排。</p>

<p><strong>7、什么是Pod？</strong></p>

<p>答：Pod是Kubernetes的最小调度和部署单元。它是一个包含一个或多个容器的逻辑主机，这些容器共享网络和存储资源，并且在同一主机上共享生命周期。</p>

<p><strong>8、什么是ReplicaSet？</strong></p>

<p>答：ReplicaSet是Kubernetes的控制器之一，用于确保在集群中运行指定数量的Pod副本。如果Pod的数量少于指定的副本数，ReplicaSet将创建新的Pod副本；如果Pod的数量多于指定的副本数，ReplicaSet将删除多余的Pod。</p>

<p><strong>9、什么是Deployment？</strong></p>

<p>答：Deployment是Kubernetes的控制器之一，用于声明性地管理Pod副本集。它允许定义Pod模板、副本数和更新策略，使得应用程序的部署和更新变得简单可控。</p>

<p><strong>10、什么是Service？</strong></p>

<p>答：Service是Kubernetes的抽象层，用于暴露应用程序的一组Pod。它为这些Pod提供稳定的网络终结点，并允许它们通过服务发现进行通信。</p>

<p><strong>11、什么是命名空间（Namespace）？</strong></p>

<p>答：命名空间是一种在Kubernetes集群中创建多个虚拟集群的机制。它可以用于隔离和管理不同的应用程序、团队或环境。</p>

<p><strong>12、如何进行应用程序的水平扩展？</strong></p>

<p>答：可以使用Deployment的副本数字段来进行水平扩展。通过增加副本数，Kubernetes会创建更多的Pod副本以应对负载增加。</p>

<p><strong>13、如何在Kubernetes中进行滚动更新（Rolling Update）？</strong></p>

<p>答：可以通过更新Deployment的Pod模板来进行滚动更新。Kubernetes会逐步替换现有的Pod副本，确保在整个更新过程中应用程序的可用性。</p>

<p><strong>14、如何在Kubernetes中进行滚动回滚（Rollback）？</strong></p>

<p>答：可以使用Deployment的回滚功能来进行滚动回滚。通过指定回滚到的特定修订版本或回滚到上一个修订版本，Kubernetes会自动恢复旧的Pod副本。</p>

<p><strong>15、什么是Kubernetes的水平自动扩展（Horizontal Pod Autoscaling）？</strong></p>

<p>答：水平自动扩展是Kubernetes的功能之一，根据应用程序的负载自动调整Pod副本数。它基于CPU利用率或自定义指标来进行自动扩展。</p>

<p><strong>16、如何进行存储卷（Volume）的使用？</strong></p>

<p>答：可以使用存储卷将持久化数据附加到Pod中。Kubernetes支持多种类型的存储卷，如空白存储卷、主机路径、持久卷等。</p>

<p><strong>17、什么是ConfigMap和Secret？</strong></p>

<p>答：ConfigMap用于存储应用程序的配置数据，而Secret用于存储敏感信息，如密码、API密钥等。它们可以作为环境变量、命令行参数或挂载到容器中使用。</p>

<p><strong>18、什么是亲和性（Affinity）和反亲和性（Anti-Affinity）？</strong></p>

<p>答：亲和性和反亲和性是Pod调度的约束条件。通过使用亲和性，可以将Pod调度到指定的节点；通过使用反亲和性，可以避免将Pod调度到指定的节点。</p>

<p><strong>19、什么是DaemonSet？</strong></p>

<p>答：DaemonSet是Kubernetes的控制器之一，用于在集群中的每个节点上运行一个Pod副本。它适用于在集群中的每个节点上运行系统级别的守护进程。</p>

<p><strong>20、什么是Ingress？</strong></p>

<p>答：Ingress是Kubernetes的资源之一，用于将外部流量路由到集群内的服务。它可以提供负载均衡、SSL终止、路径基于的路由等功能。</p>

<p><strong>21、什么是持久卷（Persistent Volume）和持久卷声明（Persistent Volume Claim）？</strong></p>

<p>答：持久卷是一种Kubernetes资源，用于提供独立于Pod的持久化存储。持久卷声明用于请求持久卷，使得Pod可以访问持久化存储。</p>

<p><strong>22、什么是Init容器（Init Container）？</strong></p>

<p>答：Init容器是Pod中的一个额外容器，用于在主应用程序容器启动之前运行初始化任务。它可以用于数据准备、配置下载等任务。</p>

<p><strong>23、如何在Kubernetes中进行配置文件的安全管理？</strong></p>

<p>答：可以使用Secret来安全地管理敏感配置信息，如数据库密码、API密钥等。可以通过加密、访问控制和密钥轮换等措施来确保Secret的安全性。</p>

<p><strong>24、如何监控Kubernetes集群？</strong></p>

<p>答：可以使用Kubernetes内置的指标和日志系统，如kube-state-metrics、Heapster和EFK堆栈，来监控集群的运行状态和性能。</p>

<p><strong>25、如何进行跨集群部署和管理？</strong></p>

<p>答：可以使用Kubernetes Federation或Kubernetes多集群（Multi-cluster）解决方案来进行跨集群部署和管理。</p>

<p><strong>25、什么是Kubernetes的生命周期钩子（Lifecycle Hook）？</strong></p>

<p>答：生命周期钩子是Pod中的回调函数，可以在容器的生命周期事件发生时触发。它们可以用于在容器启动、停止或失败时执行定制化操作。</p>

<p><strong>26、什么是Pod的探针（Probe）？</strong></p>

<p>答：Pod的探针用于定期检查容器的健康状态。Kubernetes支持三种类型的探针：存活探针（Liveness Probe）、就绪探针（Readiness Probe）和启动探针（Startup Probe）。</p>

<p><strong>27、什么是Kubernetes的安全性措施？</strong></p>

<p>答：Kubernetes提供了多种安全性措施，如访问控制、网络策略、身份验证和授权、安全上下文等。此外，还可以使用第三方工具和插件来增强Kubernetes的安全性。</p>

<p><strong>29、什么是容器资源限制（Resource Limit）和容器资源请求（Resource Request）？</strong></p>

<p>答：容器资源限制用于限制容器使用的CPU和内存资源。容器资源请求用于向调度器声明容器所需的CPU和内存资源。</p>

<p><strong>30、什么是Kubernetes中的水平和垂直扩展？</strong></p>

<p>答：水平扩展（Horizontal Scaling）指的是增加Pod副本数来处理更多的负载。垂直扩展（Vertical Scaling）指的是增加或减少单个Pod的资源限制。</p>

<p><strong>31、什么是Kubernetes的节点亲和性（Node Affinity）？</strong></p>

<p>答：节点亲和性用于将Pod调度到具有特定标签或节点选择器匹配的节点上。它可以用于确保Pod运行在特定类型的节点上，如SSD存储节点或GPU节点。</p>

<p><strong>32、什么是Kubernetes的事件（Event）？</strong></p>

<p>答：事件是Kubernetes集群中发生的重要操作或状态更改的记录。可以使用kubectl命令或API查看集群中的事件。</p>

<p><strong>33、什么是Helm？</strong></p>

<p>答：Helm是Kubernetes的包管理工具，用于简化应用程序的部署和管理。它允许定义和版本化应用程序的Charts（图表），并通过Helm命令进行安装、升级和删除。</p>

<p><strong>34、如何进行Kubernetes集群的高可用性配置？</strong></p>

<p>答：可以使用Kubernetes的Master节点高可用性（HA）模式，通过配置多个Master节点实现集群的高可用性。这可以通过使用负载均衡器、备份ETCD数据存储等方法来实现。</p>

<p><strong>35、什么是Kubernetes的状态管理器（StatefulSet）？</strong></p>

<p>答：StatefulSet是Kubernetes的控制器之一，用于管理有状态应用程序的部署。它确保Pod的稳定网络标识和有序启动、停止，适用于数据库、队列等有状态应用程序。</p>

<p><strong>36、什么是Kubernetes的自定义资源定义（Custom Resource Definition，CRD）？</strong></p>

<p>答：CRD允许用户将自定义资源（Custom Resources）引入到Kubernetes中。这使得用户可以扩展Kubernetes的API和控制器，以支持自定义的资源类型。</p>

<p><strong>37、什么是Kubernetes的配置管理工具？</strong></p>

<p>答：Kubernetes提供了多种配置管理工具，如kubectl、kubeconfig文件、ConfigMap、Secret、Helm等。这些工具可以用于管理和传递应用程序的配置信息。</p>

<p><strong>38、什么是Kubernetes的网络模型？</strong></p>

<p>答：Kubernetes的网络模型基于容器间和容器与外部的通信。每个Pod都具有唯一的IP地址，并且可以通过服务和Ingress来实现内部和外部的网络通信。</p>

<p><strong>39、什么是Kubernetes的升级策略？</strong></p>

<p>答：Kubernetes的升级策略指定了如何处理应用程序的升级。它包括滚动更新、蓝绿部署、金丝雀发布等不同的升级方式。</p>

<p><strong>40、什么是Kubernetes的监控和日志记录解决方案？</strong></p>

<p>答：Kubernetes提供了多种监控和日志记录解决方案，如Prometheus、Grafana、ELK堆栈等。这些工具可以用于监控集群的性能指标和应用程序日志。</p>

<p><strong>41、请解释一下 Kubernetes 的主要组件。</strong></p>

<p>答：Kubernetes的主要组件包括：Master组件（API Server、Controller Manager、Scheduler）和Node组件（kubelet、kube-proxy、容器运行时）。</p>

<p><strong>42、如何在 Kubernetes 中扩展应用程序？</strong></p>

<p>答：可以使用ReplicaSet、Deployment或Horizontal Pod Autoscaler（HPA）来扩展应用程序。</p>

<p><strong>43、怎样从一个镜像创建一个 Pod？</strong></p>

<p>答：可以使用kubectl命令行工具或编写一个Pod的YAML文件，然后使用kubectl apply命令创建Pod。</p>

<p><strong>44、如何将应用程序部署到 Kubernetes？</strong></p>

<p>答：可以使用Deployment、StatefulSet或DaemonSet等资源对象来部署应用程序。</p>

<p><strong>45、如何水平扩展 Deployment？</strong></p>

<p>答：可以通过更改Deployment的副本数来水平扩展应用程序。例如，使用kubectl scale命令或更改Deployment的replicas字段。</p>

<p><strong>46、怎样在 Kubernetes 中进行服务发现？</strong></p>

<p>可以使用Kubernetes的Service对象来进行服务发现。Pod可以通过Service的DNS名称进行通信。</p>

<p><strong>47、如何进行滚动更新（Rolling Update）？</strong></p>

<p>答：可以通过更新Deployment的Pod模板或修改RollingUpdate策略来执行滚动更新。</p>

<p><strong>48、什么是 PVC（Persistent Volume Claim）？</strong></p>

<p>答：PVC是用于声明对持久卷（Persistent Volume）的需求的对象，它允许Pod使用持久化存储。</p>

<p><strong>49、怎样进行容器间通信？</strong></p>

<p>答：可以使用Pod的内部IP地址和端口号进行容器间通信。此外，也可以使用Service对象来提供稳定的网络访问。</p>

<p><strong>50、如何进行集群内部的日志收集？</strong></p>

<p>答：可以使用Kubernetes的日志收集器（如Fluentd、Prometheus）来收集集群中各个Pod的日志。</p>

<p><strong>51、什么是亲和性调度（Affinity Scheduling）？</strong></p>

<p>答：亲和性调度是一种机制，用于将Pod调度到特定的节点或一组节点，以便满足特定的调度策略。</p>

<p><strong>52、怎样进行水平自动扩展（Horizontal Pod Autoscaling）？</strong></p>

<p>答：可以使用Horizontal Pod Autoscaler（HPA）对象来自动根据CPU或其他指标水平扩展Pod副本的数量。</p>

<p><strong>53、如何进行安全访问控制（RBAC）？</strong></p>

<p>答：可以使用Kubernetes的Role-Based Access Control（RBAC）机制来定义和管理用户对集群资源的访问权限。</p>

<p><strong>54、什么是 Sidecar 容器？</strong></p>

<p>答：Sidecar容器是与主应用程序容器共同运行的辅助容器，用于提供额外的功能或服务。</p>

<p><strong>55、怎样进行跨集群部署？</strong></p>

<p>答：可以使用Kubernetes的Federation机制来管理跨多个集群的应用程序部署和资源。</p>

<p><strong>56、如何进行存储卷的扩展和快照？</strong></p>

<p>答：可以使用Kubernetes的存储类（StorageClass）和持久卷声明（Persistent Volume Claim）来管理存储卷的扩展和快照。</p>

<p><strong>57、什么是 Pod 的生命周期？</strong></p>

<p>答：Pod的生命周期包括Pending、Running、Succeeded、Failed和Unknown等阶段。</p>

<p><strong>58、怎样进行热更新（Hot Deployment）？</strong></p>

<p>答：可以使用滚动更新策略，将新版本的应用程序容器逐步替换旧版本的容器，实现热更新。</p>

<p><strong>59、什么是 Downward API？</strong></p>

<p>答：Downward API是一种机制，用于将Pod的元数据（如标签、注解、环境变量等）注入到容器中。</p>

<p><strong>60、怎样进行资源限制和配额管理？</strong></p>

<p>答：可以使用Kubernetes的资源限制（Resource Limit）和配额（Resource Quota）来控制Pod使用的资源。</p>

<p><strong>61、什么是 CNI（Container Network Interface）？</strong></p>

<p>答：CNI是一种规范，用于定义容器运行时和网络插件之间的接口，以实现容器网络的配置和管理。</p>]]></content><author><name>FatGuy010</name></author><category term="面试" /><summary type="html"><![CDATA[什么是pod ？]]></summary></entry><entry><title type="html">使用Prometheus监控Kubernetes集群</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/2023/10/15/DeployPrometheusWithKubernetes" rel="alternate" type="text/html" title="使用Prometheus监控Kubernetes集群" /><published>2023-10-15T00:00:00+00:00</published><updated>2023-10-15T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/2023/10/15/Kubernetes%E9%83%A8%E7%BD%B2Promtheus%E5%B9%B6%E7%9B%91%E6%8E%A7</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/2023/10/15/DeployPrometheusWithKubernetes"><![CDATA[<h3 id="集群搭建">集群搭建</h3>

<p>参考之前写的Kubernetes集群搭建</p>

<p><a href="https://fattt.org.edu.kg/2023/09/25/DeployKubernetesCluster">https://fattt.org.edu.kg/2023/09/25/DeployKubernetesCluster</a></p>

<p>这里使用多master的k8s集群</p>

<table>
  <thead>
    <tr>
      <th>hosts</th>
      <th>ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>server10(master)</td>
      <td>192.168.25.10</td>
    </tr>
    <tr>
      <td>server11(master)</td>
      <td>192.168.25.11</td>
    </tr>
    <tr>
      <td>server12(master)</td>
      <td>192.168.25.12</td>
    </tr>
    <tr>
      <td>server13</td>
      <td>192.168.25.13</td>
    </tr>
  </tbody>
</table>

<h3 id="kubernetes部署promtheus">Kubernetes部署Promtheus</h3>

<p>创建目录</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> /root/prom/<span class="o">{</span>alertmanager,node-exporter,config,grafana<span class="o">}</span> <span class="o">&amp;&amp;</span> <span class="nb">cd</span> /root/prom/
</code></pre></div></div>

<h4 id="namespace">namespace</h4>

<p>创建namespace</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> prometheus-ns.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: Namespace
metadata:
  name: prom
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> prometheus-ns.yaml 
</code></pre></div></div>

<h4 id="rbac">RBAC</h4>

<p>配置promtheus RBAC账号权限</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> prometheus-rbac.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
  namespace: prom

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus
rules:
- apiGroups: [""]
  resources:
  - nodes
  - nodes/proxy
  - services
  - endpoints
  - pods
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources:
  - configmaps
  verbs: ["get"]
- nonResourceURLs: ["/metrics"]
  verbs: ["get"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: prom
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> prometheus-rbac.yaml 
</code></pre></div></div>

<h4 id="congfigmap">congfigMap</h4>

<p>创建prometheus配置文件，以congfigMap方式使用(这里我还监控了ceph，不需要的可删除)</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> prometheus-config-configMap.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
data:
  prometheus.yaml: |
    global:
      scrape_interval:     15s
      evaluation_interval: 15s
      external_labels:
        cluster: k8s-cluster

    alerting:
      alertmanagers:
      - static_configs:
        - targets:
           - alertmanager.prom.svc:9093

    rule_files:
      - /etc/prometheus-rules/alerts.yaml

    scrape_configs:
      - job_name: 'prometheus'
        static_configs:
        - targets: ['localhost:9090']

      - job_name: 'kubernetes-node-exporter'
        kubernetes_sd_configs:
        - role: node
        relabel_configs:
        - source_labels: [__address__]
          regex: '(.*):10250'
          replacement: '</span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="sh">:9100'
          target_label: __address__
          action: replace
        - source_labels: [__meta_kubernetes_node_name]
          action: replace
          target_label: node
        - action: labelmap
          regex: __meta_kubernetes_node_label_(.+)
        - source_labels: [__meta_kubernetes_node_address_InternalIP]
          action: replace
          target_label: ip
          
      - job_name: 'kubernetes-apiservers'
        kubernetes_sd_configs:
        - role: endpoints
        scheme: https
        tls_config:
          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
        relabel_configs:
        - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]
          action: keep
          regex: default;kubernetes;https

      - job_name: 'kubernetes-nodes'
        kubernetes_sd_configs:
        - role: node
        scheme: https
        tls_config:
          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
        relabel_configs:
        - action: labelmap
          regex: __meta_kubernetes_node_label_(.+)
        - target_label: __address__
          replacement: kubernetes.default.svc:443
        - source_labels: [__meta_kubernetes_node_name]
          regex: (.+)
          target_label: __metrics_path__
          replacement: /api/v1/nodes/</span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="sh">/proxy/metrics

      - job_name: 'kubernetes-cadvisor'
        kubernetes_sd_configs:
        - role: node
        scheme: https
        tls_config:
          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
        relabel_configs:
        - action: labelmap
          regex: __meta_kubernetes_node_label_(.+)
        - target_label: __address__
          replacement: kubernetes.default.svc:443
        - source_labels: [__meta_kubernetes_node_name]
          regex: (.+)
          target_label: __metrics_path__
          replacement: /api/v1/nodes/</span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="sh">/proxy/metrics/cadvisor

      - job_name: 'kubernetes-service-endpoints'
        kubernetes_sd_configs:
        - role: endpoints
        relabel_configs:
        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]
          action: keep
          regex: true
        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]
          action: replace
          target_label: __scheme__
          regex: (https?)
        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]
          action: replace
          target_label: __metrics_path__
          regex: (.+)
        - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]
          action: replace
          target_label: __address__
          regex: ([^:]+)(?::</span><span class="se">\d</span><span class="sh">+)?;(</span><span class="se">\d</span><span class="sh">+)
          replacement: </span><span class="nv">$1</span><span class="sh">:</span><span class="nv">$2</span><span class="sh">
        - action: labelmap
          regex: __meta_kubernetes_service_label_(.+)
        - source_labels: [__meta_kubernetes_namespace]
          action: replace
          target_label: kubernetes_namespace
        - source_labels: [__meta_kubernetes_service_name]
          action: replace
          target_label: kubernetes_name

      - job_name: 'kubernetes-services'
        kubernetes_sd_configs:
        - role: service
        metrics_path: /probe
        params:
          module: [http_2xx]
        relabel_configs:
        - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_probe]
          action: keep
          regex: true
        - source_labels: [__address__]
          target_label: __param_target
        - target_label: __address__
          replacement: blackbox-exporter.example.com:9115
        - source_labels: [__param_target]
          target_label: instance
        - action: labelmap
          regex: __meta_kubernetes_service_label_(.+)
        - source_labels: [__meta_kubernetes_namespace]
          target_label: kubernetes_namespace
        - source_labels: [__meta_kubernetes_service_name]
          target_label: kubernetes_name

      - job_name: 'kubernetes-ingresses'
        kubernetes_sd_configs:
        - role: ingress
        relabel_configs:
        - source_labels: [__meta_kubernetes_ingress_annotation_prometheus_io_probe]
          action: keep
          regex: true
        - source_labels: [__meta_kubernetes_ingress_scheme,__address__,__meta_kubernetes_ingress_path]
          regex: (.+);(.+);(.+)
          replacement: </span><span class="k">${</span><span class="nv">1</span><span class="k">}</span><span class="sh">://</span><span class="k">${</span><span class="nv">2</span><span class="k">}${</span><span class="nv">3</span><span class="k">}</span><span class="sh">
          target_label: __param_target
        - target_label: __address__
          replacement: blackbox-exporter.example.com:9115
        - source_labels: [__param_target]
          target_label: instance
        - action: labelmap
          regex: __meta_kubernetes_ingress_label_(.+)
        - source_labels: [__meta_kubernetes_namespace]
          target_label: kubernetes_namespace
        - source_labels: [__meta_kubernetes_ingress_name]
          target_label: kubernetes_name

      - job_name: 'kubernetes-pods'
        kubernetes_sd_configs:
        - role: pod
        relabel_configs:
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
          action: keep
          regex: true
        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
          action: replace
          target_label: __metrics_path__
          regex: (.+)
        - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
          action: replace
          regex: ([^:]+)(?::</span><span class="se">\d</span><span class="sh">+)?;(</span><span class="se">\d</span><span class="sh">+)
          replacement: </span><span class="nv">$1</span><span class="sh">:</span><span class="nv">$2</span><span class="sh">
          target_label: __address__
        - action: labelmap
          regex: __meta_kubernetes_pod_label_(.+)
        - source_labels: [__meta_kubernetes_namespace]
          action: replace
          target_label: kubernetes_namespace
        - source_labels: [__meta_kubernetes_pod_name]
          action: replace
          target_label: kubernetes_pod_name

      - job_name: 'ceph'
        static_configs:
        - targets: ['192.168.25.150:9283']

kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: prom
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> prometheus-config-configMap.yaml
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> prometheus-alerts-configMap.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
data:
  alerts.yaml: |
    groups:
     - name: prometheus alert
       rules:
        - alert: "InstanceDown"
          expr: up == 0
          for: 30s
          labels:
            severity: critical
          annotations:
            instance: ""
            description: " 已停止运行超过 30s！"
            
     - name: node-up
       rules:
       - alert: "node-up"
         expr: up{node="server13"} == 0
         for: 15s
         labels:
           severity: critical
         annotations:
           instance: ""
           description: " 已停止运行超过 15s！"

kind: ConfigMap
metadata:
  name: prometheus-alerts
  namespace: prom
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> prometheus-alerts-configMap.yaml
</code></pre></div></div>

<h4 id="deployment">deployment</h4>

<p>部署prometheus</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> prometheus-deploy.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: prom
  labels:
    app: prometheus
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      serviceAccountName: prometheus
      containers:
      - image: prom/prometheus
        name: prometheus
        imagePullPolicy: IfNotPresent
        command:
        - "/bin/prometheus"
        args:
        - "--config.file=/etc/prometheus/prometheus.yaml"
        # 暂时使用自身Pod进行存储 &lt;应该修改为 pv 存储&gt;
        - "--storage.tsdb.path=/prometheus"
        # 数据保留30天
        - "--storage.tsdb.retention=30d"
        # 控制对admin HTTP API的访问，其中包括删除时间序列等功能
        - "--web.enable-admin-api"
        # 支持热更新，直接执行 curl -x POST  ip:9090/-/reload立即生效
        - "--web.enable-lifecycle"

        ports:
        - containerPort: 9090
          protocol: TCP
          name: http
        volumeMounts:
        - mountPath: "/etc/prometheus"
          name: config-volume
        - mountPath: "/etc/prometheus-rules"
          name: alerts-volume
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
          limits:
            cpu: 1500m
            memory: 1500Mi
      securityContext:
        runAsUser: 0

      volumes:
      - configMap:
          name: prometheus-config
        name: config-volume

      - name: alerts-volume
        configMap:
          name: prometheus-alerts
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> prometheus-deploy.yaml
</code></pre></div></div>

<h4 id="service">service</h4>

<p>创建 prometheus service 暴露服务 <如果无需外界访问则无需暴露></如果无需外界访问则无需暴露></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> prometheus-svc.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  namespace: prom
  labels:
    app: prometheus
spec:
  selector:
    app: prometheus
  type: NodePort
  ports:
    - name: prometheus-web
      nodePort: 30090
      port: 9090
      targetPort: http
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> prometheus-svc.yaml
</code></pre></div></div>

<h3 id="kubernetes部署alertmanager">Kubernetes部署alertManager</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /root/prom/alertmanager
</code></pre></div></div>

<h4 id="configmap">configMap</h4>

<p>配置configMap配置清单</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> alertmanager-config.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: ConfigMap
metadata:
  name: alertmanager-config
  namespace: prom
data:
  alerts.yaml: |-
    global:
      # 在没有报警的情况下声明为已解决的时间
      resolve_timeout: 5m
      # 配置邮件发送信息
      smtp_smarthost: 'smtp.qq.com:465'
      # 填写自己的qq邮箱
      smtp_from: 'xxxxxx@qq.com'
      # 填写自己的qq邮箱
      smtp_auth_username: 'xxxxxx@qq.com'
      # 填写自己的邮箱授权码，我这里是假的授权码
      smtp_auth_password: 'syiolshahdusgaja'
      smtp_hello: 'qq.com'
      smtp_require_tls: true
    # 所有报警信息进入后的根路由，用来设置报警的分发策略
    route:
      # 这里的标签列表是接收到报警信息后的重新分组标签，例如，接收到的报警信息里面有许多具有 cluster=A 和 alertname=LatncyHigh 这样的标签的报警信息将会批量被聚合到一个分组里面
      group_by: ['alertname', 'cluster']
      # 当一个新的报警分组被创建后，需要等待至少group_wait时间来初始化通知，这种方式可以确保您能有足够的时间为同一分组来获取多个警报，然后一起触发这个报警信息。
      group_wait: 30s
      # 当第一个报警发送后，等待'group_interval'时间来发送新的一组报警信息。
      group_interval: 5m
      # 如果一个报警信息已经发送成功了，等待'repeat_interval'时间来重新发送他们
      repeat_interval: 5m
      # 默认的receiver：如果一个报警没有被一个route匹配，则发送给默认的接收器
      receiver: default
      # 上面所有的属性都由所有子路由继承，并且可以在每个子路由上进行覆盖。
      routes:
      - receiver: email
        group_wait: 10s
        match:
          team: node
    receivers:
    - name: 'default'
      email_configs:
      # 填写自己的qq邮箱
      - to: 'xxxxxxx@qq.com'
        send_resolved: true
    - name: 'email'
      email_configs:
      # 填写别人的qq邮箱
      - to: 'xxxxxx@qq.com'
        send_resolved: true
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> alertmanager-config.yaml
</code></pre></div></div>

<h4 id="delpoyment">delpoyment</h4>

<p>配置alertmanager Pod</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> alertmanager-deploy.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: alertmanager
  namespace: prom
spec:
  selector:
    matchLabels:
      app: alertmanager
  replicas: 2
  template:
    metadata:
      labels:
         app: alertmanager
    spec:
      containers:
      - name: alertmanager
        image: prom/alertmanager
        imagePullPolicy: IfNotPresent
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 100m
            memory: 256Mi
        volumeMounts:
        - name: alert-config
          mountPath: /etc/prometheus-rules
        ports:
        - name: http
          containerPort: 9093
      volumes:
      - name: alert-config
        configMap:
          name: alertmanager-config
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> alertmanager-deploy.yaml
</code></pre></div></div>

<h4 id="service-1">service</h4>

<p>暴露alertmanager service</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> alertmanager-svc.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: Service
metadata:
  name: alertmanager-svc
  namespace: prom
  annotations:
    prometheus.io/scrape: "true"
spec:
  selector:
    app: alertmanager
  ports:
  - name: http
    port: 9093
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> alertmanager-svc.yaml
</code></pre></div></div>

<h3 id="kubernetes部署node-exporter">Kubernetes部署node-exporter</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /root/prom/node-exporter
</code></pre></div></div>

<h4 id="node-exporter">node-exporter</h4>

<p>部署安装node-exporter</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> node-exporter.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: node-exporter
  namespace: prom
  labels:
    name: node-exporter
spec:
  selector:
    matchLabels:
      name: node-exporter
  template:
    metadata:
      labels:
        name: node-exporter
    spec:
      hostPID: true
      hostIPC: true
      hostNetwork: true
      containers:
      - name: node-exporter
        image: prom/node-exporter
        ports:
        - containerPort: 9100
        resources:
          requests:
            cpu: 0.15
        securityContext:
          privileged: true
        args:
        - --path.procfs
        - /host/proc
        - --path.sysfs
        - /host/sys
        - --collector.filesystem.ignored-mount-points
        - '</span><span class="se">\"</span><span class="sh">^/</span><span class="se">\(</span><span class="sh">sys|proc|dev|host|etc)</span><span class="se">\(\$</span><span class="sh">|/)</span><span class="se">\"</span><span class="sh">'
        volumeMounts:
        - name: dev
          mountPath: /host/dev
        - name: proc
          mountPath: /host/proc
        - name: sys
          mountPath: /host/sys
        - name: rootfs
          mountPath: /rootfs
      tolerations:
      - key: "node-role.kubernetes.io/control-plane"
        operator: "Exists"
        effect: "NoSchedule"
      volumes:
        - name: proc
          hostPath:
            path: /proc
        - name: dev
          hostPath:
            path: /dev
        - name: sys
          hostPath:
            path: /sys
        - name: rootfs
          hostPath:
            path: /
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> node-exporter.yaml
</code></pre></div></div>

<h3 id="kubernetes部署grafana">Kubernetes部署grafana</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /root/prom/grafana
<span class="nb">mkdir</span> <span class="nt">-p</span> /root/prom/grafana/data
</code></pre></div></div>

<h4 id="部署-kafana">部署 kafana</h4>

<p>PS: 这里配置securityContext的原因是从v5.1.0开始，grafana的运行用户ID（userid）和组ID（groupid）已经改成了472。而另外两个env是用来配置Grafana的管理员用户和密码。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> grafana-deploy.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  namespace: prom
  labels:
    app: grafana
spec:
  selector:
    matchLabels:
      app: grafana
  replicas: 1
  revisionHistoryLimit: 10
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
      - name: grafana
        image: grafana/grafana:9.5.10
        imagePullPolicy: IfNotPresent
        ports:
        - name: grafana
          containerPort: 3000
        env:
        #指定 grafana的初始 admin用户和密码
        - name: GF_SECURITY_ADMIN_USER
          value: admin
        - name: GF_SECURITY_ADMIN_PASSWORD
          value: admin
        readinessProbe:
          failureThreshold: 10
          httpGet:
            path: /api/health
            port: 3000
            scheme: HTTP
          initialDelaySeconds: 60
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 30
        livenessProbe:
          failureThreshold: 10
          httpGet:
            path: /api/health
            port: 3000
            scheme: HTTP
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        resources:
          requests:
            cpu: 100m
            memory: 256Mi
          limits:
            cpu: 100m
            memory: 256Mi
        volumeMounts:
        - name: storage
          mountPath: /var/lib/grafana
          subPath: grafana
      securityContext:
        fsGroup: 472
        runAsUser: 472
      volumes:
      - name: storage
        persistentVolumeClaim:
          claimName: grafana
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> grafana-deploy.yaml
</code></pre></div></div>

<h4 id="pvpv">pvpv</h4>

<p>动态制备卷</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> grafana-pvpv.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: PersistentVolume
metadata:
  name: grafana
spec:
  capacity:
    storage: 1Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Recycle
  nfs:
    # 这里指定你的NFS服务器地址
    server: xxx.xx.xxx.xx
    path: /root/prom/grafana/data
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: grafana
  namespace: kube-ops
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
</span><span class="no">EOF
</span>kubectl apply <span class="nt">-f</span> grafana-pvpv.yaml
</code></pre></div></div>

<h4 id="service-2">service</h4>

<p>暴露kafana的服务(因为没指定端口，所以它自己生成了端口号)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat &gt; grafana-svc.yaml &lt;&lt; EOF
apiVersion: v1
kind: Service
metadata:
  name: grafana
  namespace: prom
  labels:
    app: grafana
spec:
  selector:
    app: grafana
  type: NodePort
  ports:
  - name: grafana
    port: 3000
EOF
kubectl apply -f grafana-svc.yaml
</code></pre></div></div>

<h3 id="热部署">热部署</h3>

<p>查看service</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get <span class="nt">-n</span> prom svc
NAME               TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>          AGE
alertmanager-svc   ClusterIP   10.1.210.101   &lt;none&gt;        9093/TCP         19h
grafana            NodePort    10.1.154.58    &lt;none&gt;        3000:31431/TCP   19h
prometheus         NodePort    10.1.106.7     &lt;none&gt;        9090:30090/TCP   20h
</code></pre></div></div>

<p>更新Prometheus数据</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-X</span> POST http://10.1.106.7:9090/-/reload
</code></pre></div></div>

<h3 id="浏览器访问">浏览器访问</h3>

<p>Prometheus</p>

<p>http://192.168.25.10:30090</p>

<p>Grafana</p>

<p>http://192.168.25.10:31431</p>

<p>alertManager警报生效</p>

<p><img src="https://picss.sunbangyan.cn/2023/11/25/00451ba6d08d58dc7809afaff21ab60e.jpeg" alt="" /></p>

<p>警告规则生效</p>

<p><img src="https://picst.sunbangyan.cn/2023/11/25/4386a4b9c082678dbf341c9215fae1c7.jpeg" alt="" /></p>

<p>自动发现服务生效</p>

<p><img src="https://picdm.sunbangyan.cn/2023/11/25/35dd824d017e556d7e28e9868e457a02.jpeg" alt="" /></p>

<p>targets生效</p>

<p><img src="https://picdm.sunbangyan.cn/2023/11/25/7174d0a5dc3b005750efe9f224a11ec5.jpeg" alt="" /></p>

<p>grafana使用配置好的账号密码登录</p>

<p>账号：admin</p>

<p>密码：admin</p>

<p>导入Prometheus数据时要注意，Prometheus和grafana都在k8s集群内部</p>

<p>填写url就指定service名字和集群内部的端口</p>

<p><img src="https://picdm.sunbangyan.cn/2023/11/25/457f2230c5b532123a2794ab906d53fd.jpeg" alt="" /></p>

<p>监控node-exporter</p>

<p><img src="https://picst.sunbangyan.cn/2023/11/25/6a63e820cb6e6243b0f0d14174551d66.jpeg" alt="" /></p>

<p>监控模板</p>

<p>Dashboards -&gt; Manage -&gt; Import -&gt; 输入仪表盘ID -&gt; Load</p>

<p><img src="https://picss.sunbangyan.cn/2023/11/25/a1d7e7ad82a4b8d67a39208f10c976cd.jpeg" alt="" /></p>]]></content><author><name>FatGuy010</name></author><category term="Linux" /><category term="Kubernetes" /><summary type="html"><![CDATA[集群搭建]]></summary></entry><entry><title type="html">面试题</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/InterviewQuestions" rel="alternate" type="text/html" title="面试题" /><published>2023-10-09T00:00:00+00:00</published><updated>2023-10-09T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9F</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/InterviewQuestions"><![CDATA[<h1 id="容器">容器</h1>

<h2 id="k8s面试题"><a href="https://blog.csdn.net/chongfa2008/article/details/121975552">K8s面试题</a></h2>

<p><a href="https://fattt.org.edu.kg/K8sInterviewQuestions">https://fattt.org.edu.kg/K8sInterviewQuestions</a></p>

<h2 id="容器与虚拟机的区别">容器与虚拟机的区别</h2>

<p>容器和虚拟机都是提供隔离环境以运行应用程序的技术，但它们在架构和运行机制上有本质的不同。</p>

<p><strong>虚拟机（VM）</strong></p>

<p>虚拟机是一种基于硬件的虚拟化技术。每个虚拟机都包括完整的操作系统，以及运行在该操作系统之上的应用程序和必要的库。虚拟机由一个称为<strong>虚拟机监控器</strong>（Hypervisor）的软件组件管理，它负责在物理硬件和各个虚拟机之间进行调度。</p>

<p><strong>特点</strong>：</p>

<ul>
  <li><strong>完全隔离</strong>：每个虚拟机都是完全独立的。</li>
  <li><strong>资源消耗</strong>：因为每个虚拟机都运行一个完整的操作系统，所以相对占用更多的资源。</li>
  <li><strong>启动时间</strong>：虚拟机的启动通常需要几分钟，因为需要加载整个操作系统。</li>
  <li><strong>可移植性</strong>：虚拟机可以在不同的物理机器和虚拟化平台之间迁移，但通常体积较大，迁移速度较慢。</li>
</ul>

<p><strong>容器</strong></p>

<p>容器是一种基于操作系统级别的虚拟化。与虚拟机不同，容器共享宿主机的操作系统内核，但在用户空间中为每个容器提供隔离的环境。容器内部包含应用程序和其依赖的库和设置，但不包括整个操作系统。</p>

<p><strong>特点</strong>：</p>

<ul>
  <li><strong>轻量级</strong>：容器共享宿主机的操作系统内核，因此占用的资源比虚拟机少得多。</li>
  <li><strong>快速启动</strong>：容器只需启动应用程序，而不是整个操作系统，因此启动通常在几秒钟内完成。</li>
  <li><strong>密度高</strong>：在同等硬件上，可以运行更多的容器实例。</li>
  <li><strong>可移植性</strong>：容器的体积小，易于快速迁移和扩展。</li>
</ul>

<p><strong>对比总结</strong></p>

<ul>
  <li><strong>隔离级别</strong>：虚拟机提供硬件级别的完全隔离，而容器提供的是操作系统级别的隔离。</li>
  <li><strong>性能开销</strong>：虚拟机包含完整的操作系统副本，导致更高的性能开销。容器由于共享宿主操作系统的内核，因此开销更小。</li>
  <li><strong>启动速度</strong>：虚拟机启动慢，容器启动快。</li>
  <li><strong>系统兼容性</strong>：虚拟机可以运行不同于宿主机的操作系统，而容器则受限于宿主机的操作系统内核。</li>
  <li><strong>管理工具</strong>：虚拟机通常使用VMware、Hyper-V等虚拟化平台管理，容器则使用Docker、Kubernetes等容器管理工具。</li>
</ul>

<p>在实际应用中，虚拟机更适用于需要完全隔离和安全保障的环境，而容器则因其轻量级和快速部署的特性，适用于微服务架构和持续集成/持续部署（CI/CD）的环境。</p>

<h1 id="数据库">数据库</h1>

<h2 id="结构和非结构化数据">结构和非结构化数据</h2>

<p>结构化数据和非结构化数据是两种主要的数据类型，它们在存储、处理和分析时有着本质的不同。</p>

<p><strong>结构化数据</strong></p>

<p>结构化数据是指那些高度组织和格式化的数据，因此可以轻松地被搜索引擎和数据挖掘工具所读取、搜索和分析。它们通常存储在关系数据库（如 MySQL、PostgreSQL、Oracle）中，并且有严格定义的数据模型和关系，如表格中的行和列。每一列都有一个预定义的数据类型，所有的数据项都符合这个数据类型。</p>

<p><strong>例子</strong>：</p>
<ul>
  <li>客户信息表格，包括姓名、地址、电话号码等。</li>
  <li>销售数据，包括日期、销售额、客户ID等。</li>
  <li>库存管理系统中的物品清单。</li>
</ul>

<p>结构化数据的优点是易于查询和更新，支持通过SQL（结构化查询语言）等查询语言进行高效的数据操作和分析。</p>

<p><strong>非结构化数据</strong></p>

<p>非结构化数据是指没有预定义数据模型的数据，也不容易放入传统的关系数据库中。这类数据包括文本、图像、音频、视频等，通常存储在文件系统中或者使用专门的存储系统和数据仓库。</p>

<p><strong>例子</strong>：</p>
<ul>
  <li>邮件、PDF文件、Word文档等文本文件。</li>
  <li>数码照片、视频剪辑等多媒体文件。</li>
  <li>社交媒体帖子、博客文章等网络内容。</li>
</ul>

<p>非结构化数据的挑战在于它的多样性和复杂性，需要使用特定的工具和技术来处理和分析，例如文本分析、图像识别和自然语言处理。</p>

<p><strong>半结构化数据</strong></p>

<p>除了结构化和非结构化数据之外，还有一种被称为半结构化数据的类型，它是介于结构化和非结构化数据之间的数据。它们可能不符合严格的数据模型，但仍然包含标签或其他标记来分隔语义元素，并支持数据的层次化组织。</p>

<p><strong>例子</strong>：</p>
<ul>
  <li>XML和JSON文件，它们包含标记或键值对，用于描述数据，但不符合固定的模式或结构。</li>
  <li>电子数据交换（EDI）文件，它们用于商业交易，并遵循特定的格式标准，但并非存储在关系数据库中。</li>
</ul>

<p>在现代数据管理和分析中，能够有效地处理结构化和非结构化数据是非常重要的，因为它们可以提供不同的视角和洞察力。随着大数据技术的发展，非结构化数据的重要性日益增加，因为它构成了世界数据量的一个很大比例。</p>

<h2 id="关系型数据和非关系型数据">关系型数据和非关系型数据</h2>

<p>关系型数据和非关系型数据是指存储在关系型数据库和非关系型数据库中的数据类型，它们具有不同的数据模型和用例。</p>

<p><strong>关系型数据（Relational Data）</strong></p>

<p>关系型数据基于关系模型，这种模型由数学家E.F. Codd在1970年提出。关系型数据库管理系统（RDBMS）如MySQL、PostgreSQL、Oracle和SQL Server等广泛采用这一模型。</p>

<p><strong>特点</strong>：</p>

<ul>
  <li><strong>结构化</strong>：数据以表格的形式存储，每个表都有固定的列（属性）和多行（记录）。</li>
  <li><strong>严格的模式</strong>：定义了数据的结构，包括数据类型、关系等，所有数据写入前都需要符合这个模式。</li>
  <li><strong>数据完整性</strong>：通过主键、外键、索引、约束等机制来维护数据的准确性和一致性。</li>
  <li><strong>支持复杂的查询</strong>：使用结构化查询语言（SQL）进行高度复杂的数据查询。</li>
  <li><strong>事务支持</strong>：具有事务处理的能力，遵循ACID原则（原子性、一致性、隔离性、持久性）。</li>
</ul>

<p><strong>非关系型数据（Non-Relational Data）</strong></p>

<p>非关系型数据，也称为NoSQL数据，存储在非关系型数据库中，如MongoDB、Cassandra、Redis和Elasticsearch等。这些数据库不遵循传统的关系模型，而是采用了其他种类的数据模型。</p>

<p><strong>特点</strong>：</p>

<ul>
  <li><strong>灵活的模式</strong>：数据结构可以动态修改，不需要预先定义。</li>
  <li><strong>多样的数据模型</strong>：包括键值对（Key-Value）、文档（Document）、列族（Column-Family）和图（Graph）等。</li>
  <li><strong>可扩展性</strong>：通常设计为易于水平扩展，通过增加更多的服务器来提升性能和存储能力。</li>
  <li><strong>优化为特定类型的查询</strong>：每种NoSQL数据库可能针对特定模式的查询或存储需求进行了优化。</li>
  <li><strong>事务支持差异</strong>：NoSQL数据库通常不提供全面的ACID事务支持，尽管某些数据库开始提供类似功能。</li>
</ul>

<p><strong>使用场景</strong></p>

<ul>
  <li><strong>关系型数据库</strong>通常用于需要严格数据完整性和复杂查询的应用，例如金融服务、会计系统和其他需要复杂事务处理的应用程序。</li>
  <li><strong>非关系型数据库</strong>适用于数据模式不固定、需要水平扩展或对读写性能有特别要求的场景，如大数据分析、实时数据处理、内容管理系统等。</li>
</ul>

<h2 id="如何查看主从延时情况">如何查看主从延时情况？</h2>

<p>在使用MySQL关系型数据库的主从复制架构中，”主从延时”指的是从服务器复制主服务器上的数据变化所经历的时间差。这个延时可能是由网络延迟、从服务器的负载或复制过程中的SQL执行时间等因素造成的。</p>

<p><strong>1. SHOW SLAVE STATUS命令</strong></p>

<p>在MySQL中，可以在从服务器上执行<code class="language-plaintext highlighter-rouge">SHOW SLAVE STATUS\G</code>命令来查看复制状态，包括延时情况。这个命令会返回一个包含复制状态信息的结果集，其中的<code class="language-plaintext highlighter-rouge">Seconds_Behind_Master</code>字段显示了从服务器落后于主服务器的秒数。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SHOW</span> <span class="n">SLAVE</span> <span class="n">STATUS</span><span class="err">\</span><span class="k">G</span>
</code></pre></div></div>

<p>查看输出结果中的<code class="language-plaintext highlighter-rouge">Seconds_Behind_Master</code>值：</p>

<ul>
  <li>
    <p>如果这个值是<code class="language-plaintext highlighter-rouge">0</code>，表示主从复制良好。</p>
  </li>
  <li>
    <p>如果这个值是一个非零的数字，它表示从服务器落后于主服务器的秒数，数字越大表示从库延迟越严重。</p>
  </li>
  <li>
    <p>如果这个值是<code class="language-plaintext highlighter-rouge">NULL</code>，表示<code class="language-plaintext highlighter-rouge">io_thread</code>或是<code class="language-plaintext highlighter-rouge">sql_thread</code>有任何一个发生故障。</p>
  </li>
</ul>

<p><strong>2. Performance Schema</strong></p>

<p>从MySQL 5.6开始，可以使用Performance Schema来监控复制延迟。首先，需要确保Performance Schema被启用，并且相关的复制表也被激活。然后，可以查询<code class="language-plaintext highlighter-rouge">performance_schema.replication_applier_status_by_worker</code>表来获取复制延迟的信息。</p>

<p><strong>3. pt-heartbeat</strong></p>

<p><code class="language-plaintext highlighter-rouge">pt-heartbeat</code>是Percona Toolkit工具套件中的一个工具，它可以更精确地测量复制延迟。它通过在主服务器上创建一个记录心跳时间的表，并定期更新这个表来工作。从服务器上的<code class="language-plaintext highlighter-rouge">pt-heartbeat</code>进程会监测这个表，并计算出主从同步的延迟时间。</p>

<p><strong>4. 自定义脚本</strong></p>

<p>可以编写自定义脚本来检测主从延迟。这些脚本通常在主服务器上插入时间戳记录，在从服务器上读取这些记录，并计算出时间差。</p>

<p><strong>5. 第三方监控工具</strong></p>

<p>还可以使用第三方监控工具，如Zabbix、Nagios、Prometheus等，配合相关插件来监控MySQL复制延迟。</p>

<p><strong>6. MySQL Shell的复制报告</strong></p>

<p>MySQL Shell是MySQL 8.0引入的一个高级客户端和代码编辑器。在MySQL Shell中，可以使用复制报告功能来检查复制状态，包括延迟。</p>

<h2 id="解决数据丢失的问题">解决数据丢失的问题</h2>

<p><strong>半同步复制</strong></p>

<p>从MySQL5.5开始，MySQL已经支持半同步复制了，半同步复制介于异步复制和同步复制之间，主库在执行完事务后不立刻返回结果给客户端，需要等待至少一个从库接收到并写到relay log中才返回结果给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一个TCP/IP往返耗时的延迟。</p>

<p><a href="https://imgse.com/i/picoplj"><img src="https://z1.ax1x.com/2023/12/06/picoplj.png" alt="picoplj.png" /></a></p>

<h2 id="解决从库复制延迟的问题">解决从库复制延迟的问题</h2>

<p>优化网络</p>

<p>升级Slave硬件配置</p>

<p>Slave调整参数，关闭binlog，修改<code class="language-plaintext highlighter-rouge">innodb_flush_log_at_trx_commit</code>参数值</p>

<p>升级MySQL版本到5.7，使用并行复制</p>

<h2 id="数据同步的主要优点包括以下几个方面">数据同步的主要优点包括以下几个方面</h2>

<p><strong>提高数据一致性</strong></p>

<p>数据同步可以将不同位置或系统中的数据进行实时或定期的更新和匹配，从而保持数据的一致性。</p>

<p><strong>提高数据可靠性</strong></p>

<p>通过数据同步，可以将<a href="https://cloud.tencent.com/developer/techpedia/1725">数据备份</a>到不同的位置或系统中，提高数据的可靠性和安全性。</p>

<p><strong>提高数据可用性</strong></p>

<p>通过数据同步，可以将数据从一个系统同步到另一个系统中，提高数据的可用性和共享性，为业务决策和<a href="https://cloud.tencent.com/developer/techpedia/1580">数据分析</a>提供有力支持。</p>

<p><strong>提高工作效率</strong></p>

<p>数据同步可以自动化完成数据的更新和匹配过程，减少手动操作，提高工作效率。</p>

<p><strong>降低成本</strong></p>

<p>通过数据同步，可以减少数据的重复输入和错误，降低<a href="https://cloud.tencent.com/developer/techpedia/1723">数据管理</a>和维护的成本。</p>

<h2 id="mysql-基于gtid主从复制">Mysql 基于gtid主从复制</h2>

<p><strong>GTID的工作原理</strong></p>

<ol>
  <li>当一个事务在主库端执行并提交时，产生GTID，一同记录到binlog日志。</li>
  <li>binlog传输到slave,并存储到slave的relaylog后，读取这个GTID的这个值设置GTID_next变量，即告诉Slave，下一个要执行的GTID值。</li>
  <li>sql线程从relay log中获取GTID，然后对比slave端的binlog是否有该GTID。</li>
  <li>如果有记录，说明该GTID的事务已经执行，slave会忽略。</li>
  <li>如果没有记录，slave就会执行该GTID事务，并记录该GTID到自身的binlog，在读取执行事务前会先检查其他session持有该GTID，确保不被重复执行。</li>
  <li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描。</li>
</ol>

<p><strong>GTID的优点</strong></p>

<ol>
  <li>一个事务对应一个唯一ID，一个GTID在一个服务器上只会执行一次;</li>
  <li>GTID是用来代替传统复制的方法，GTID复制与普通复制模式的最大不同就是不需要指定二进制文件名和位置;</li>
  <li>减少手工干预和降低服务故障时间，当主机挂了之后通过软件从众多的备机中提升一台备机为主 机;</li>
</ol>

<p><strong>GTID 的缺点(限制)</strong></p>

<ol>
  <li>不支持非事务引擎;</li>
  <li>不允许一个SQL同时更新一个事务引擎表和非事务引擎表;</li>
  <li>在一个复制组中，必须要求统一开启GTID或者是关闭GTID;</li>
  <li>开启GTID需要重启 (mysql5.7除外);</li>
  <li>开启GTID后，就不再使用原来的传统复制方式;</li>
</ol>

<h1 id="linux">Linux</h1>

<h2 id="linux-开机启动过程">Linux 开机启动过程</h2>

<ol>
  <li>开机BIOS自检</li>
  <li>MBR引导</li>
  <li>GRUB引导菜单</li>
  <li>加载内核Kernel</li>
  <li>初始化init/systemd</li>
  <li>运行程序</li>
  <li>提示登陆</li>
</ol>

<h2 id="raid磁盘阵列">Raid磁盘阵列</h2>

<p><a href="https://imgse.com/i/pic4g39"><img src="https://z1.ax1x.com/2023/12/06/pic4g39.png" alt="pic4g39.png" /></a></p>

<p><strong>Raid 0</strong>：两块硬盘或者以上就可做
raid0优势：数据读取写入最快，最大优势提高硬盘容量，比如3快80G的硬盘做raid0 可用总容量为240G。速度是一样。
缺点：无冗余能力，一块硬盘损坏，数据全无。
建议：做raid0 可以提供更好的容量以及性能，推荐对数据安全性要求不高的使用。</p>

<p><strong>Raid 1</strong>：至少2快硬盘可做
raid1优势：镜像，数据安全强，2快硬盘做raid一块正常运行，另外一块镜像备份数据，保障数据的安全。一块坏了，另外一块硬盘也有完整的数据，保障运行。
缺点：性能提示不明显，做raid1之后硬盘使用率为50%.
建议：对数据安全性比较看着，性能没有太高要求的人使用。</p>

<p><strong>Raid5</strong>：至少需要3块硬盘
raid5优势：以上优势，raid5兼顾。任意N-1快硬盘都有完整的数据。
缺点：只允许单盘故障，一盘出现故障得尽快处理。有盘坏情况下，raid5 IO/CPU性能狂跌，此时性能烂到无以复加。
建议：盘不多，对数据安全性和性能提示都有要求，raid5是个不错选择，鉴于出问题的性能，盘多可考虑riad10</p>

<p><strong>Raid10</strong>：至少需要4快硬盘。raid10是2快硬盘组成raid1,2组raid1z组成raid0,所以必须需要4块硬盘。</p>

<p>优势：兼顾安全性和速度。基础4盘的情况下，raid10允许对柜盘2块故障，随着硬盘数量的提示，容错量也会相对应提升。这是raid5无法做到的。</p>

<p>缺点：对盘的数量要求稍高，磁盘使用率为一半。</p>

<p>建议：硬盘数量足够的情况，建议riad10.不过raid最重要的指标是可靠性：4盘的raid5,只允许单盘故障，raid10,允许对柜盘2块g故障，可靠性高于raid5,且raid10 可随盘上升提高容错，raid就不行，而且IO和CPU的额外开销还涂增，从可靠性和冗余角度，达到同样的可靠性,raid10写能力高于raid5.</p>

<h1 id="网络">网络</h1>

<h2 id="一次域名请求经过的协议">一次域名请求经过的协议</h2>

<p>一次域名请求通常会涉及到 DNS 解析、HTTP/HTTPS 请求、TCP连接、安全传输协议（如果是 HTTPS 请求的话），以及可能的其他应用层协议(例如：FTP、STMP)。</p>

<h2 id="dns解析过程是怎样的">DNS解析过程是怎样的</h2>

<p><a href="https://imgse.com/i/pi2FcE6"><img src="https://z1.ax1x.com/2023/12/08/pi2FcE6.png" alt="pi2FcE6.png" /></a></p>

<p>递归查询</p>

<p><a href="https://imgse.com/i/pi2FU4U"><img src="https://z1.ax1x.com/2023/12/08/pi2FU4U.png" alt="pi2FU4U.png" /></a></p>

<p>迭代查询</p>

<p><a href="https://imgse.com/i/pi2F0gJ"><img src="https://z1.ax1x.com/2023/12/08/pi2F0gJ.png" alt="pi2F0gJ.png" /></a></p>

<p>在实际应用中，递归查询通常用于从请求主机到本地 DNS 服务器的查询，而迭代查询则用于本地 DNS 服务器向根域名服务器或者顶级域名服务器发出查询请求。</p>

<h2 id="网络七层协议">网络七层协议</h2>

<ul>
  <li><strong>物理层</strong>：</li>
</ul>

<p>解决两个硬件之间怎么通信的问题，常见的物理媒介有光纤、电缆、中继器等。它主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。</p>

<p>它的<strong>主要作用</strong>是传输<strong>比特流</strong>（就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做<strong>比特</strong>。</p>

<ul>
  <li><strong>数据链路层：</strong></li>
</ul>

<p>在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。</p>

<p>它的具体工作是接收来自物理层的位流形式的数据，并<strong>封装成帧</strong>，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做<strong>帧</strong>。</p>

<ul>
  <li><strong>网络层：</strong></li>
</ul>

<p>计算机网络中如果有多台计算机，怎么找到要发的那台？如果中间有多个节点，怎么选择路径？这就是路由要做的事。</p>

<p>该层的主要任务就是：通过路由选择算法，为<strong>报文</strong>（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了<strong>IP协议</strong>。</p>

<ul>
  <li><strong>传输层：</strong></li>
</ul>

<p>当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。</p>

<p>简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输。</p>

<ul>
  <li><strong>会话层：</strong></li>
</ul>

<p>虽然已经可以实现给正确的计算机，发送正确的封装过后的信息了。但我们总不可能每次都要调用传输层协议去打包，然后再调用IP协议去找路由，所以我们要建立一个自动收发包，自动寻址的功能。于是会话层出现了：它的作用就是<strong>建立和管理应用程序之间的通信</strong>。</p>

<ul>
  <li><strong>表示层：</strong></li>
</ul>

<p>表示层负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。</p>

<ul>
  <li><strong>应用层：</strong></li>
</ul>

<p>应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。</p>

<h2 id="osi七层模型">OSI七层模型</h2>

<p><a href="https://imgse.com/i/pi2FzKs"><img src="https://z1.ax1x.com/2023/12/08/pi2FzKs.png" alt="pi2FzKs.png" /></a></p>

<h2 id="tcpip4层模型5层模型和osi七层模型的差别">TCP/IP4层模型、5层模型和OSI七层模型的差别</h2>

<p><a href="https://imgse.com/i/pi2FoDI"><img src="https://z1.ax1x.com/2023/12/08/pi2FoDI.png" alt="pi2FoDI.png" /></a></p>

<h2 id="三次握手和四次挥手">三次握手和四次挥手</h2>

<p><a href="https://www.cnblogs.com/zzjdbk/p/13028290.html">https://www.cnblogs.com/zzjdbk/p/13028290.html</a></p>

<p><strong>三次握手</strong></p>

<ol>
  <li>
    <p>第一次握手：客户端给服务器发送一个 SYN 报文。</p>
  </li>
  <li>
    <p>第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。</p>
  </li>
  <li>
    <p>第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</p>

    <p><a href="https://imgse.com/i/pi2Aa6J"><img src="https://z1.ax1x.com/2023/12/08/pi2Aa6J.png" alt="pi2Aa6J.png" /></a></p>
  </li>
</ol>

<p><strong>四次挥手</strong></p>

<ol>
  <li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</li>
  <li>第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</li>
  <li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
  <li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</li>
  <li>服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ol>

<p><a href="https://imgse.com/i/pi2AYfU"><img src="https://z1.ax1x.com/2023/12/08/pi2AYfU.png" alt="pi2AYfU.png" /></a></p>

<h1 id="服务">服务</h1>

<h2 id="keepalived的本质">Keepalived的本质</h2>

<p>使用VRRP协议(虚拟路由器冗余协议)：通告：心跳，优先级等；周期性
工作方式：</p>

<ul>
  <li><strong>抢占式</strong>：一旦有优先级高的路由器加入，立即成为Master</li>
  <li><strong>非抢占式</strong>：只要Master不挂掉，优先级高的路由器只能等待</li>
</ul>

<p>vrrp协议的作用是提供了局域网上的设备备份机制。vrrp协议是一种容错协议，它保证当主机的下一跳路由器坏掉时，可以及时由另一台路由器来替代，从而保证通讯的连续性和可靠性</p>

<p>Keepalived高可用软件两个核心功能：
 1.健康检测功能
 2.VRRP冗余功能</p>

<p>Keepalived本质就是为ipvs服务的，它也不需要共享存储。IPVS其实就是一些规则，Keepalived主要的任务就是去调用ipvsadm命令，来生成规则，并自动实现将用户需要访问的地址转移到可用LVS节点实现。</p>

<h2 id="nginx获取真实的客户端ip地址获取源ip">Nginx获取真实的客户端IP地址(<strong>获取源IP</strong>)</h2>

<p><strong>方法一、通过 头部字段 传递 客户端Ip 到 上游服务器</strong></p>

<p>在代理设置真实ip  到  X-Real-IP  头部字段，该字段不区分大小写,在 上游服务器日志中引用该变量即可</p>

<p><code class="language-plaintext highlighter-rouge">proxy_set_header X-Real-IP $remote_addr;</code></p>

<p>在游服务器日志中引用该字段变量,(注意引用变量时，要加$http_, 其次 ‘-‘ 变 ‘_’, 大小写忽略)</p>

<p>​    <code class="language-plaintext highlighter-rouge">log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</code></p>

<p>​                      <code class="language-plaintext highlighter-rouge">'$status $body_bytes_sent "$http_referer" '</code></p>

<p>​                      <code class="language-plaintext highlighter-rouge">'"$http_user_agent" "$http_X_Real_IP"';</code></p>

<p>对于多级代理 X-Forwarded-For 字段可以包含 客户端地址和代理地址</p>

<p><code class="language-plaintext highlighter-rouge">proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;</code></p>

<p>​    <code class="language-plaintext highlighter-rouge">log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</code></p>

<p>​                      <code class="language-plaintext highlighter-rouge">'$status $body_bytes_sent "$http_referer" '</code></p>

<p>​                      <code class="language-plaintext highlighter-rouge">'"$http_user_agent" "$http_x_forwarded_for"';</code></p>

<p><strong>方法二、 ngx_http_realip_module  通过模块获取客户端IP</strong></p>

<p>nginx 通过<code class="language-plaintext highlighter-rouge">ngx_http_proxy_module</code>模块 实现反向代理；在nginx 启动服务load conf时， 就会读取<code class="language-plaintext highlighter-rouge">proxy_set_header</code> 的配置项；来获取需要的变量。<code class="language-plaintext highlighter-rouge">proxy_set_header</code> 是用来设置请求的header的； 比如：设置上面的<code class="language-plaintext highlighter-rouge">host X-Real-IP x-forwarded-for</code></p>

<h2 id="elk如何进行日志切割">ELK如何进行日志切割</h2>

<p><strong>方法一：Filebeat的dissect</strong></p>

<p>优点：简单快捷，在简单应用场景中效率更高</p>

<p>缺点：日志切割场景单一，功能单一</p>

<p>实现：在配置文件中processors下面加上dissect 对日志进行切割</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">processors</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">dissect</span><span class="pi">:</span>
      <span class="na">tokenizer</span><span class="pi">:</span> <span class="s2">"</span><span class="s">%{date}</span><span class="nv"> </span><span class="s">%{time}</span><span class="nv"> </span><span class="s">%{s-ip}</span><span class="nv"> </span><span class="s">%{cs-method}</span><span class="nv"> </span><span class="s">%{cs-uri-stem}</span><span class="nv"> </span><span class="s">%{cs-uri-query}</span><span class="nv"> </span><span class="s">%{s-port}</span><span class="nv"> </span><span class="s">%{cs-username}</span><span class="nv"> </span><span class="s">%{c-ip}</span><span class="nv"> </span><span class="s">%{cs(User-Agent)}</span><span class="nv"> </span><span class="s">%{cs(Referer)}</span><span class="nv"> </span><span class="s">%{sc-status}</span><span class="nv"> </span><span class="s">%{sc-substatus}</span><span class="nv"> </span><span class="s">%{sc-win32-status}</span><span class="nv"> </span><span class="s">%{time-taken}"</span>
      <span class="na">field</span><span class="pi">:</span> <span class="s2">"</span><span class="s">message"</span>
      <span class="na">target_prefix</span><span class="pi">:</span> <span class="s2">"</span><span class="s">fields"</span>
</code></pre></div></div>

<p><strong>方法二：Logstash的grok</strong></p>

<p>优点：能灵活的切割各种日志，有很多功能加工日志</p>

<p>缺点：配置难度较dissect高出不少</p>

<p>实现：在Logstash配置文件中input和output之间的filter中进行配置</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filter</span> <span class="p">{</span>
  <span class="n">grok</span> <span class="p">{</span>
    <span class="n">match</span> <span class="o">=&gt;</span> <span class="p">[</span>
         <span class="p">\</span><span class="s2">"message</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">%{TIMESTAMP</span><span class="se">\_</span><span class="s2">ISO8601:iis.access.time} </span><span class="se">\(</span><span class="s2">?:-|%{IPORHOST:destination.address}) </span><span class="se">\(</span><span class="s2">?:-|%{WORD:http.request.method}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.path}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.query}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:destination.port:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user.name}) </span><span class="se">\(</span><span class="s2">?:-|%{IPORHOST:source.address}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user</span><span class="se">\_</span><span class="s2">agent.original}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:http.request.referrer}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.response.status</span><span class="se">\_</span><span class="s2">code:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.sub</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.win32</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:temp.duration:long})</span><span class="se">\"</span><span class="s2">,
         </span><span class="se">\"</span><span class="s2">message</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">%{TIMESTAMP</span><span class="se">\_</span><span class="s2">ISO8601:iis.access.time} </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:iis.access.site</span><span class="se">\_</span><span class="s2">name}) </span><span class="se">\(</span><span class="s2">?:-|%{WORD:http.request.method}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.path}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.query}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:destination.port:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user.name}) </span><span class="se">\(</span><span class="s2">?:-|%{IPORHOST:source.address}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user</span><span class="se">\_</span><span class="s2">agent.original}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:iis.access.cookie}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:http.request.referrer}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:destination.domain}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.response.status</span><span class="se">\_</span><span class="s2">code:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.sub</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.win32</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.response.body.bytes:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.request.body.bytes:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:temp.duration:long})</span><span class="se">\"</span><span class="s2">,
         </span><span class="se">\"</span><span class="s2">message</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">%{TIMESTAMP</span><span class="se">\_</span><span class="s2">ISO8601:iis.access.time} </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:iis.access.site</span><span class="se">\_</span><span class="s2">name}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:iis.access.server</span><span class="se">\_</span><span class="s2">name}) </span><span class="se">\(</span><span class="s2">?:-|%{IPORHOST:destination.address}) </span><span class="se">\(</span><span class="s2">?:-|%{WORD:http.request.method}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.path}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.query}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:destination.port:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user.name}) </span><span class="se">\(</span><span class="s2">?:-|%{IPORHOST:source.address}) </span><span class="se">\(</span><span class="s2">?:-|HTTP/%{NUMBER:http.version}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user</span><span class="se">\_</span><span class="s2">agent.original}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:iis.access.cookie}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:http.request.referrer}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:destination.domain}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.response.status</span><span class="se">\_</span><span class="s2">code:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.sub</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.win32</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.response.body.bytes:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.request.body.bytes:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:temp.duration:long})</span><span class="se">\"</span><span class="s2">,
         </span><span class="se">\"</span><span class="s2">message</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">%{TIMESTAMP</span><span class="se">\_</span><span class="s2">ISO8601:iis.access.time} </span><span class="se">\\</span><span class="s2">[%{IPORHOST:destination.address}</span><span class="se">\]\\</span><span class="s2">(http://%{IPORHOST:destination.address}</span><span class="se">\)</span><span class="s2"> </span><span class="se">\(</span><span class="s2">?:-|%{WORD:http.request.method}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.path}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.query}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:destination.port:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user.name}) </span><span class="se">\\</span><span class="s2">[%{IPORHOST:source.address}</span><span class="se">\]\\</span><span class="s2">(http://%{IPORHOST:source.address}</span><span class="se">\)</span><span class="s2"> </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user</span><span class="se">\_</span><span class="s2">agent.original}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.response.status</span><span class="se">\_</span><span class="s2">code:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.sub</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.win32</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:temp.duration:long})</span><span class="se">\"</span><span class="s2">,
         </span><span class="se">\"</span><span class="s2">message</span><span class="se">\"</span><span class="s2">,</span><span class="se">\"</span><span class="s2">%{TIMESTAMP</span><span class="se">\_</span><span class="s2">ISO8601:iis.access.time} </span><span class="se">\(</span><span class="s2">?:-|%{IPORHOST:destination.address}) </span><span class="se">\(</span><span class="s2">?:-|%{WORD:http.request.method}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.path}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:url.query}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:destination.port:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user.name}) </span><span class="se">\(</span><span class="s2">?:-|%{IPORHOST:source.address}) </span><span class="se">\(</span><span class="s2">?:-|%{NOTSPACE:user</span><span class="se">\_</span><span class="s2">agent.original}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:http.response.status</span><span class="se">\_</span><span class="s2">code:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.sub</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:iis.access.win32</span><span class="se">\_</span><span class="s2">status:long}) </span><span class="se">\(</span><span class="s2">?:-|%{NUMBER:temp.duration:long})</span><span class="se">\"</span><span class="s2">
    ]
    tag_on_failure =&gt; ["</span><span class="n">fail_in_message</span><span class="s2">"]
  }
}
</span></code></pre></div></div>

<h1 id="cicd">CICD</h1>

<h2 id="cicd的几种发布方式">CI/CD的几种发布方式</h2>

<p><strong>蓝绿部署（Blue-Green Deployment）：</strong></p>

<ul>
  <li>
    <p>在蓝绿部署中，有两套完全相同的生产环境，分别称为蓝环境和绿环境。在任何时刻，只有一套环境在向用户提供服务，而另一套环境则处于闲置状态。当新版本准备好发布时，流量被切换到处于闲置状态的环境，从而实现零停机时间的部署。</p>

    <p><strong>特点</strong></p>

    <ul>
      <li>蓝绿部署的目的是减少发布时的中断时间、能够快速撤回发布</li>
      <li>发布策略简单</li>
      <li>用户无感知，平滑过渡</li>
      <li>升级/回滚速度快</li>
    </ul>

    <p><strong>缺点</strong></p>

    <ul>
      <li>需要准备正常业务使用资源的两倍以上服务器，防止升级期间单组无法承载业务突发</li>
      <li>短时间内浪费一定资源成本</li>
      <li>基础设施无改动，增大升级稳定性</li>
    </ul>
  </li>
</ul>

<p><strong>金丝雀部署/灰度发布（Canary Deployment）：</strong></p>

<ul>
  <li>
    <p>金丝雀部署是一种逐步发布新版本的方式，它允许只向一小部分用户或流量引入新版本，以便在实际生产环境中进行测试。如果新版本没有引发问题，可以逐渐增加流量直至全部流量都使用新版本。</p>

    <p><strong>特点</strong></p>

    <ul>
      <li>保证整体系统稳定性，在初始灰度的时候就可以发现、调整问题，影响范围可控</li>
      <li>新功能逐步评估性能，稳定性和健康状况，如果出问题影响范围很小，相对用户体验也少</li>
      <li>用户无感知，平滑过渡</li>
    </ul>

    <p><strong>缺点</strong></p>

    <ul>
      <li>自动化要求高</li>
    </ul>
  </li>
</ul>

<p><strong>滚动部署（Rolling Deployment）：</strong></p>

<ul>
  <li>
    <p>在滚动部署中，新版本逐步替换旧版本，通常是逐个节点或逐批节点地进行。这种方式可以确保系统的稳定性，因为在部署过程中，总是有一部分节点在提供服务。</p>

    <p><strong>特点</strong></p>

    <ul>
      <li>用户无感知，平滑过渡</li>
      <li>节约资源</li>
    </ul>

    <p><strong>缺点</strong></p>

    <ul>
      <li>部署时间慢，取决于每阶段更新时间</li>
      <li>发布策略较复杂</li>
      <li>无法确定OK的环境，不易回滚</li>
    </ul>
  </li>
</ul>

<p><strong>增量部署（Incremental Deployment）：</strong></p>

<ul>
  <li>增量部署是一种将新功能逐步添加到生产环境中的方式。这种方式通常用于大型系统或对稳定性要求较高的系统，以确保新功能的逐步引入不会对整个系统造成过大的影响。</li>
</ul>]]></content><author><name>FatGuy010</name></author><category term="面试" /><summary type="html"><![CDATA[容器 K8s面试题 https://fattt.org.edu.kg/K8sInterviewQuestions 容器与虚拟机的区别 容器和虚拟机都是提供隔离环境以运行应用程序的技术，但它们在架构和运行机制上有本质的不同。 虚拟机（VM） 虚拟机是一种基于硬件的虚拟化技术。每个虚拟机都包括完整的操作系统，以及运行在该操作系统之上的应用程序和必要的库。虚拟机由一个称为虚拟机监控器（Hypervisor）的软件组件管理，它负责在物理硬件和各个虚拟机之间进行调度。 特点： 完全隔离：每个虚拟机都是完全独立的。 资源消耗：因为每个虚拟机都运行一个完整的操作系统，所以相对占用更多的资源。 启动时间：虚拟机的启动通常需要几分钟，因为需要加载整个操作系统。 可移植性：虚拟机可以在不同的物理机器和虚拟化平台之间迁移，但通常体积较大，迁移速度较慢。 容器 容器是一种基于操作系统级别的虚拟化。与虚拟机不同，容器共享宿主机的操作系统内核，但在用户空间中为每个容器提供隔离的环境。容器内部包含应用程序和其依赖的库和设置，但不包括整个操作系统。 特点： 轻量级：容器共享宿主机的操作系统内核，因此占用的资源比虚拟机少得多。 快速启动：容器只需启动应用程序，而不是整个操作系统，因此启动通常在几秒钟内完成。 密度高：在同等硬件上，可以运行更多的容器实例。 可移植性：容器的体积小，易于快速迁移和扩展。 对比总结 隔离级别：虚拟机提供硬件级别的完全隔离，而容器提供的是操作系统级别的隔离。 性能开销：虚拟机包含完整的操作系统副本，导致更高的性能开销。容器由于共享宿主操作系统的内核，因此开销更小。 启动速度：虚拟机启动慢，容器启动快。 系统兼容性：虚拟机可以运行不同于宿主机的操作系统，而容器则受限于宿主机的操作系统内核。 管理工具：虚拟机通常使用VMware、Hyper-V等虚拟化平台管理，容器则使用Docker、Kubernetes等容器管理工具。 在实际应用中，虚拟机更适用于需要完全隔离和安全保障的环境，而容器则因其轻量级和快速部署的特性，适用于微服务架构和持续集成/持续部署（CI/CD）的环境。 数据库 结构和非结构化数据 结构化数据和非结构化数据是两种主要的数据类型，它们在存储、处理和分析时有着本质的不同。 结构化数据 结构化数据是指那些高度组织和格式化的数据，因此可以轻松地被搜索引擎和数据挖掘工具所读取、搜索和分析。它们通常存储在关系数据库（如 MySQL、PostgreSQL、Oracle）中，并且有严格定义的数据模型和关系，如表格中的行和列。每一列都有一个预定义的数据类型，所有的数据项都符合这个数据类型。 例子： 客户信息表格，包括姓名、地址、电话号码等。 销售数据，包括日期、销售额、客户ID等。 库存管理系统中的物品清单。 结构化数据的优点是易于查询和更新，支持通过SQL（结构化查询语言）等查询语言进行高效的数据操作和分析。 非结构化数据 非结构化数据是指没有预定义数据模型的数据，也不容易放入传统的关系数据库中。这类数据包括文本、图像、音频、视频等，通常存储在文件系统中或者使用专门的存储系统和数据仓库。 例子： 邮件、PDF文件、Word文档等文本文件。 数码照片、视频剪辑等多媒体文件。 社交媒体帖子、博客文章等网络内容。 非结构化数据的挑战在于它的多样性和复杂性，需要使用特定的工具和技术来处理和分析，例如文本分析、图像识别和自然语言处理。 半结构化数据 除了结构化和非结构化数据之外，还有一种被称为半结构化数据的类型，它是介于结构化和非结构化数据之间的数据。它们可能不符合严格的数据模型，但仍然包含标签或其他标记来分隔语义元素，并支持数据的层次化组织。 例子： XML和JSON文件，它们包含标记或键值对，用于描述数据，但不符合固定的模式或结构。 电子数据交换（EDI）文件，它们用于商业交易，并遵循特定的格式标准，但并非存储在关系数据库中。 在现代数据管理和分析中，能够有效地处理结构化和非结构化数据是非常重要的，因为它们可以提供不同的视角和洞察力。随着大数据技术的发展，非结构化数据的重要性日益增加，因为它构成了世界数据量的一个很大比例。 关系型数据和非关系型数据 关系型数据和非关系型数据是指存储在关系型数据库和非关系型数据库中的数据类型，它们具有不同的数据模型和用例。 关系型数据（Relational Data） 关系型数据基于关系模型，这种模型由数学家E.F. Codd在1970年提出。关系型数据库管理系统（RDBMS）如MySQL、PostgreSQL、Oracle和SQL Server等广泛采用这一模型。 特点： 结构化：数据以表格的形式存储，每个表都有固定的列（属性）和多行（记录）。 严格的模式：定义了数据的结构，包括数据类型、关系等，所有数据写入前都需要符合这个模式。 数据完整性：通过主键、外键、索引、约束等机制来维护数据的准确性和一致性。 支持复杂的查询：使用结构化查询语言（SQL）进行高度复杂的数据查询。 事务支持：具有事务处理的能力，遵循ACID原则（原子性、一致性、隔离性、持久性）。 非关系型数据（Non-Relational Data） 非关系型数据，也称为NoSQL数据，存储在非关系型数据库中，如MongoDB、Cassandra、Redis和Elasticsearch等。这些数据库不遵循传统的关系模型，而是采用了其他种类的数据模型。 特点： 灵活的模式：数据结构可以动态修改，不需要预先定义。 多样的数据模型：包括键值对（Key-Value）、文档（Document）、列族（Column-Family）和图（Graph）等。 可扩展性：通常设计为易于水平扩展，通过增加更多的服务器来提升性能和存储能力。 优化为特定类型的查询：每种NoSQL数据库可能针对特定模式的查询或存储需求进行了优化。 事务支持差异：NoSQL数据库通常不提供全面的ACID事务支持，尽管某些数据库开始提供类似功能。 使用场景 关系型数据库通常用于需要严格数据完整性和复杂查询的应用，例如金融服务、会计系统和其他需要复杂事务处理的应用程序。 非关系型数据库适用于数据模式不固定、需要水平扩展或对读写性能有特别要求的场景，如大数据分析、实时数据处理、内容管理系统等。 如何查看主从延时情况？ 在使用MySQL关系型数据库的主从复制架构中，”主从延时”指的是从服务器复制主服务器上的数据变化所经历的时间差。这个延时可能是由网络延迟、从服务器的负载或复制过程中的SQL执行时间等因素造成的。 1. SHOW SLAVE STATUS命令 在MySQL中，可以在从服务器上执行SHOW SLAVE STATUS\G命令来查看复制状态，包括延时情况。这个命令会返回一个包含复制状态信息的结果集，其中的Seconds_Behind_Master字段显示了从服务器落后于主服务器的秒数。 SHOW SLAVE STATUS\G 查看输出结果中的Seconds_Behind_Master值： 如果这个值是0，表示主从复制良好。 如果这个值是一个非零的数字，它表示从服务器落后于主服务器的秒数，数字越大表示从库延迟越严重。 如果这个值是NULL，表示io_thread或是sql_thread有任何一个发生故障。 2. Performance Schema 从MySQL 5.6开始，可以使用Performance Schema来监控复制延迟。首先，需要确保Performance Schema被启用，并且相关的复制表也被激活。然后，可以查询performance_schema.replication_applier_status_by_worker表来获取复制延迟的信息。 3. pt-heartbeat pt-heartbeat是Percona Toolkit工具套件中的一个工具，它可以更精确地测量复制延迟。它通过在主服务器上创建一个记录心跳时间的表，并定期更新这个表来工作。从服务器上的pt-heartbeat进程会监测这个表，并计算出主从同步的延迟时间。 4. 自定义脚本 可以编写自定义脚本来检测主从延迟。这些脚本通常在主服务器上插入时间戳记录，在从服务器上读取这些记录，并计算出时间差。 5. 第三方监控工具 还可以使用第三方监控工具，如Zabbix、Nagios、Prometheus等，配合相关插件来监控MySQL复制延迟。 6. MySQL Shell的复制报告 MySQL Shell是MySQL 8.0引入的一个高级客户端和代码编辑器。在MySQL Shell中，可以使用复制报告功能来检查复制状态，包括延迟。 解决数据丢失的问题 半同步复制 从MySQL5.5开始，MySQL已经支持半同步复制了，半同步复制介于异步复制和同步复制之间，主库在执行完事务后不立刻返回结果给客户端，需要等待至少一个从库接收到并写到relay log中才返回结果给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一个TCP/IP往返耗时的延迟。 解决从库复制延迟的问题 优化网络 升级Slave硬件配置 Slave调整参数，关闭binlog，修改innodb_flush_log_at_trx_commit参数值 升级MySQL版本到5.7，使用并行复制 数据同步的主要优点包括以下几个方面 提高数据一致性 数据同步可以将不同位置或系统中的数据进行实时或定期的更新和匹配，从而保持数据的一致性。 提高数据可靠性 通过数据同步，可以将数据备份到不同的位置或系统中，提高数据的可靠性和安全性。 提高数据可用性 通过数据同步，可以将数据从一个系统同步到另一个系统中，提高数据的可用性和共享性，为业务决策和数据分析提供有力支持。 提高工作效率 数据同步可以自动化完成数据的更新和匹配过程，减少手动操作，提高工作效率。 降低成本 通过数据同步，可以减少数据的重复输入和错误，降低数据管理和维护的成本。 Mysql 基于gtid主从复制 GTID的工作原理 当一个事务在主库端执行并提交时，产生GTID，一同记录到binlog日志。 binlog传输到slave,并存储到slave的relaylog后，读取这个GTID的这个值设置GTID_next变量，即告诉Slave，下一个要执行的GTID值。 sql线程从relay log中获取GTID，然后对比slave端的binlog是否有该GTID。 如果有记录，说明该GTID的事务已经执行，slave会忽略。 如果没有记录，slave就会执行该GTID事务，并记录该GTID到自身的binlog，在读取执行事务前会先检查其他session持有该GTID，确保不被重复执行。 在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有就用全部扫描。 GTID的优点 一个事务对应一个唯一ID，一个GTID在一个服务器上只会执行一次; GTID是用来代替传统复制的方法，GTID复制与普通复制模式的最大不同就是不需要指定二进制文件名和位置; 减少手工干预和降低服务故障时间，当主机挂了之后通过软件从众多的备机中提升一台备机为主 机; GTID 的缺点(限制) 不支持非事务引擎; 不允许一个SQL同时更新一个事务引擎表和非事务引擎表; 在一个复制组中，必须要求统一开启GTID或者是关闭GTID; 开启GTID需要重启 (mysql5.7除外); 开启GTID后，就不再使用原来的传统复制方式; Linux Linux 开机启动过程 开机BIOS自检 MBR引导 GRUB引导菜单 加载内核Kernel 初始化init/systemd 运行程序 提示登陆 Raid磁盘阵列 Raid 0：两块硬盘或者以上就可做 raid0优势：数据读取写入最快，最大优势提高硬盘容量，比如3快80G的硬盘做raid0 可用总容量为240G。速度是一样。 缺点：无冗余能力，一块硬盘损坏，数据全无。 建议：做raid0 可以提供更好的容量以及性能，推荐对数据安全性要求不高的使用。 Raid 1：至少2快硬盘可做 raid1优势：镜像，数据安全强，2快硬盘做raid一块正常运行，另外一块镜像备份数据，保障数据的安全。一块坏了，另外一块硬盘也有完整的数据，保障运行。 缺点：性能提示不明显，做raid1之后硬盘使用率为50%. 建议：对数据安全性比较看着，性能没有太高要求的人使用。 Raid5：至少需要3块硬盘 raid5优势：以上优势，raid5兼顾。任意N-1快硬盘都有完整的数据。 缺点：只允许单盘故障，一盘出现故障得尽快处理。有盘坏情况下，raid5 IO/CPU性能狂跌，此时性能烂到无以复加。 建议：盘不多，对数据安全性和性能提示都有要求，raid5是个不错选择，鉴于出问题的性能，盘多可考虑riad10 Raid10：至少需要4快硬盘。raid10是2快硬盘组成raid1,2组raid1z组成raid0,所以必须需要4块硬盘。 优势：兼顾安全性和速度。基础4盘的情况下，raid10允许对柜盘2块故障，随着硬盘数量的提示，容错量也会相对应提升。这是raid5无法做到的。 缺点：对盘的数量要求稍高，磁盘使用率为一半。 建议：硬盘数量足够的情况，建议riad10.不过raid最重要的指标是可靠性：4盘的raid5,只允许单盘故障，raid10,允许对柜盘2块g故障，可靠性高于raid5,且raid10 可随盘上升提高容错，raid就不行，而且IO和CPU的额外开销还涂增，从可靠性和冗余角度，达到同样的可靠性,raid10写能力高于raid5. 网络 一次域名请求经过的协议 一次域名请求通常会涉及到 DNS 解析、HTTP/HTTPS 请求、TCP连接、安全传输协议（如果是 HTTPS 请求的话），以及可能的其他应用层协议(例如：FTP、STMP)。 DNS解析过程是怎样的 递归查询 迭代查询 在实际应用中，递归查询通常用于从请求主机到本地 DNS 服务器的查询，而迭代查询则用于本地 DNS 服务器向根域名服务器或者顶级域名服务器发出查询请求。 网络七层协议 物理层： 解决两个硬件之间怎么通信的问题，常见的物理媒介有光纤、电缆、中继器等。它主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。 它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 数据链路层： 在计算机网络中由于各种干扰的存在，物理链路是不可靠的。该层的主要功能就是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。 它的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧。 网络层： 计算机网络中如果有多台计算机，怎么找到要发的那台？如果中间有多个节点，怎么选择路径？这就是路由要做的事。 该层的主要任务就是：通过路由选择算法，为报文（该层的数据单位，由上一层数据打包而来）通过通信子网选择最适当的路径。这一层定义的是IP地址，通过IP地址寻址，所以产生了IP协议。 传输层： 当发送大量数据时，很可能会出现丢包的情况，另一台电脑要告诉是否完整接收到全部的包。如果缺了，就告诉丢了哪些包，然后再发一次，直至全部接收为止。 简单来说，传输层的主要功能就是：监控数据传输服务的质量，保证报文的正确传输。 会话层： 虽然已经可以实现给正确的计算机，发送正确的封装过后的信息了。但我们总不可能每次都要调用传输层协议去打包，然后再调用IP协议去找路由，所以我们要建立一个自动收发包，自动寻址的功能。于是会话层出现了：它的作用就是建立和管理应用程序之间的通信。 表示层： 表示层负责数据格式的转换，将应用处理的信息转换为适合网络传输的格式，或者将来自下一层的数据转换为上层能处理的格式。 应用层： 应用层是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。 OSI七层模型 TCP/IP4层模型、5层模型和OSI七层模型的差别 三次握手和四次挥手 https://www.cnblogs.com/zzjdbk/p/13028290.html 三次握手 第一次握手：客户端给服务器发送一个 SYN 报文。 第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。 第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。 四次挥手 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。 第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 服务 Keepalived的本质 使用VRRP协议(虚拟路由器冗余协议)：通告：心跳，优先级等；周期性 工作方式： 抢占式：一旦有优先级高的路由器加入，立即成为Master 非抢占式：只要Master不挂掉，优先级高的路由器只能等待 vrrp协议的作用是提供了局域网上的设备备份机制。vrrp协议是一种容错协议，它保证当主机的下一跳路由器坏掉时，可以及时由另一台路由器来替代，从而保证通讯的连续性和可靠性 Keepalived高可用软件两个核心功能： 1.健康检测功能 2.VRRP冗余功能 Keepalived本质就是为ipvs服务的，它也不需要共享存储。IPVS其实就是一些规则，Keepalived主要的任务就是去调用ipvsadm命令，来生成规则，并自动实现将用户需要访问的地址转移到可用LVS节点实现。 Nginx获取真实的客户端IP地址(获取源IP) 方法一、通过 头部字段 传递 客户端Ip 到 上游服务器 在代理设置真实ip 到 X-Real-IP 头部字段，该字段不区分大小写,在 上游服务器日志中引用该变量即可 proxy_set_header X-Real-IP $remote_addr; 在游服务器日志中引用该字段变量,(注意引用变量时，要加$http_, 其次 ‘-‘ 变 ‘_’, 大小写忽略) ​ log_format main '$remote_addr - $remote_user [$time_local] "$request" ' ​ '$status $body_bytes_sent "$http_referer" ' ​ '"$http_user_agent" "$http_X_Real_IP"'; 对于多级代理 X-Forwarded-For 字段可以包含 客户端地址和代理地址 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; ​ log_format main '$remote_addr - $remote_user [$time_local] "$request" ' ​ '$status $body_bytes_sent "$http_referer" ' ​ '"$http_user_agent" "$http_x_forwarded_for"'; 方法二、 ngx_http_realip_module 通过模块获取客户端IP nginx 通过ngx_http_proxy_module模块 实现反向代理；在nginx 启动服务load conf时， 就会读取proxy_set_header 的配置项；来获取需要的变量。proxy_set_header 是用来设置请求的header的； 比如：设置上面的host X-Real-IP x-forwarded-for ELK如何进行日志切割 方法一：Filebeat的dissect 优点：简单快捷，在简单应用场景中效率更高 缺点：日志切割场景单一，功能单一 实现：在配置文件中processors下面加上dissect 对日志进行切割 processors: - dissect: tokenizer: "%{date} %{time} %{s-ip} %{cs-method} %{cs-uri-stem} %{cs-uri-query} %{s-port} %{cs-username} %{c-ip} %{cs(User-Agent)} %{cs(Referer)} %{sc-status} %{sc-substatus} %{sc-win32-status} %{time-taken}" field: "message" target_prefix: "fields" 方法二：Logstash的grok 优点：能灵活的切割各种日志，有很多功能加工日志 缺点：配置难度较dissect高出不少 实现：在Logstash配置文件中input和output之间的filter中进行配置 filter { grok { match =&gt; [ "message","%{TIMESTAMP_ISO8601:iis.access.time} (?:-|%{IPORHOST:destination.address}) (?:-|%{WORD:http.request.method}) (?:-|%{NOTSPACE:url.path}) (?:-|%{NOTSPACE:url.query}) (?:-|%{NUMBER:destination.port:long}) (?:-|%{NOTSPACE:user.name}) (?:-|%{IPORHOST:source.address}) (?:-|%{NOTSPACE:user_agent.original}) (?:-|%{NOTSPACE:http.request.referrer}) (?:-|%{NUMBER:http.response.status_code:long}) (?:-|%{NUMBER:iis.access.sub_status:long}) (?:-|%{NUMBER:iis.access.win32_status:long}) (?:-|%{NUMBER:temp.duration:long})", "message","%{TIMESTAMP_ISO8601:iis.access.time} (?:-|%{NOTSPACE:iis.access.site_name}) (?:-|%{WORD:http.request.method}) (?:-|%{NOTSPACE:url.path}) (?:-|%{NOTSPACE:url.query}) (?:-|%{NUMBER:destination.port:long}) (?:-|%{NOTSPACE:user.name}) (?:-|%{IPORHOST:source.address}) (?:-|%{NOTSPACE:user_agent.original}) (?:-|%{NOTSPACE:iis.access.cookie}) (?:-|%{NOTSPACE:http.request.referrer}) (?:-|%{NOTSPACE:destination.domain}) (?:-|%{NUMBER:http.response.status_code:long}) (?:-|%{NUMBER:iis.access.sub_status:long}) (?:-|%{NUMBER:iis.access.win32_status:long}) (?:-|%{NUMBER:http.response.body.bytes:long}) (?:-|%{NUMBER:http.request.body.bytes:long}) (?:-|%{NUMBER:temp.duration:long})", "message","%{TIMESTAMP_ISO8601:iis.access.time} (?:-|%{NOTSPACE:iis.access.site_name}) (?:-|%{NOTSPACE:iis.access.server_name}) (?:-|%{IPORHOST:destination.address}) (?:-|%{WORD:http.request.method}) (?:-|%{NOTSPACE:url.path}) (?:-|%{NOTSPACE:url.query}) (?:-|%{NUMBER:destination.port:long}) (?:-|%{NOTSPACE:user.name}) (?:-|%{IPORHOST:source.address}) (?:-|HTTP/%{NUMBER:http.version}) (?:-|%{NOTSPACE:user_agent.original}) (?:-|%{NOTSPACE:iis.access.cookie}) (?:-|%{NOTSPACE:http.request.referrer}) (?:-|%{NOTSPACE:destination.domain}) (?:-|%{NUMBER:http.response.status_code:long}) (?:-|%{NUMBER:iis.access.sub_status:long}) (?:-|%{NUMBER:iis.access.win32_status:long}) (?:-|%{NUMBER:http.response.body.bytes:long}) (?:-|%{NUMBER:http.request.body.bytes:long}) (?:-|%{NUMBER:temp.duration:long})", "message","%{TIMESTAMP_ISO8601:iis.access.time} \\[%{IPORHOST:destination.address}\\]\\(http://%{IPORHOST:destination.address}\\) (?:-|%{WORD:http.request.method}) (?:-|%{NOTSPACE:url.path}) (?:-|%{NOTSPACE:url.query}) (?:-|%{NUMBER:destination.port:long}) (?:-|%{NOTSPACE:user.name}) \\[%{IPORHOST:source.address}\\]\\(http://%{IPORHOST:source.address}\\) (?:-|%{NOTSPACE:user_agent.original}) (?:-|%{NUMBER:http.response.status_code:long}) (?:-|%{NUMBER:iis.access.sub_status:long}) (?:-|%{NUMBER:iis.access.win32_status:long}) (?:-|%{NUMBER:temp.duration:long})", "message","%{TIMESTAMP_ISO8601:iis.access.time} (?:-|%{IPORHOST:destination.address}) (?:-|%{WORD:http.request.method}) (?:-|%{NOTSPACE:url.path}) (?:-|%{NOTSPACE:url.query}) (?:-|%{NUMBER:destination.port:long}) (?:-|%{NOTSPACE:user.name}) (?:-|%{IPORHOST:source.address}) (?:-|%{NOTSPACE:user_agent.original}) (?:-|%{NUMBER:http.response.status_code:long}) (?:-|%{NUMBER:iis.access.sub_status:long}) (?:-|%{NUMBER:iis.access.win32_status:long}) (?:-|%{NUMBER:temp.duration:long})" ] tag_on_failure =&gt; ["fail_in_message"] } } CICD CI/CD的几种发布方式 蓝绿部署（Blue-Green Deployment）： 在蓝绿部署中，有两套完全相同的生产环境，分别称为蓝环境和绿环境。在任何时刻，只有一套环境在向用户提供服务，而另一套环境则处于闲置状态。当新版本准备好发布时，流量被切换到处于闲置状态的环境，从而实现零停机时间的部署。 特点 蓝绿部署的目的是减少发布时的中断时间、能够快速撤回发布 发布策略简单 用户无感知，平滑过渡 升级/回滚速度快 缺点 需要准备正常业务使用资源的两倍以上服务器，防止升级期间单组无法承载业务突发 短时间内浪费一定资源成本 基础设施无改动，增大升级稳定性 金丝雀部署/灰度发布（Canary Deployment）： 金丝雀部署是一种逐步发布新版本的方式，它允许只向一小部分用户或流量引入新版本，以便在实际生产环境中进行测试。如果新版本没有引发问题，可以逐渐增加流量直至全部流量都使用新版本。 特点 保证整体系统稳定性，在初始灰度的时候就可以发现、调整问题，影响范围可控 新功能逐步评估性能，稳定性和健康状况，如果出问题影响范围很小，相对用户体验也少 用户无感知，平滑过渡 缺点 自动化要求高 滚动部署（Rolling Deployment）： 在滚动部署中，新版本逐步替换旧版本，通常是逐个节点或逐批节点地进行。这种方式可以确保系统的稳定性，因为在部署过程中，总是有一部分节点在提供服务。 特点 用户无感知，平滑过渡 节约资源 缺点 部署时间慢，取决于每阶段更新时间 发布策略较复杂 无法确定OK的环境，不易回滚 增量部署（Incremental Deployment）： 增量部署是一种将新功能逐步添加到生产环境中的方式。这种方式通常用于大型系统或对稳定性要求较高的系统，以确保新功能的逐步引入不会对整个系统造成过大的影响。]]></summary></entry><entry><title type="html">使用kubeadm部署Kubernetes集群</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/25/DeployKubernetesCluster" rel="alternate" type="text/html" title="使用kubeadm部署Kubernetes集群" /><published>2023-09-25T00:00:00+00:00</published><updated>2023-09-25T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/25/K8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/25/DeployKubernetesCluster"><![CDATA[<h2 id="kubernetes单master集群搭建">Kubernetes单master集群搭建</h2>

<h3 id="环境">环境</h3>

<p>硬件环境：Centos7，2C2G</p>

<table>
  <thead>
    <tr>
      <th>hosts</th>
      <th>ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>server10(master)</td>
      <td>192.168.25.10</td>
    </tr>
    <tr>
      <td>server11</td>
      <td>192.168.25.11</td>
    </tr>
    <tr>
      <td>server12</td>
      <td>192.168.25.12</td>
    </tr>
  </tbody>
</table>

<h3 id="系统整体环境配置所有节点又要配置">系统整体环境配置，所有节点又要配置</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#语言设置</span>
localectl set-locale <span class="nv">LANG</span><span class="o">=</span>en_US.utf8
<span class="c">#epel源</span>
wget <span class="nt">-O</span> /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repo
<span class="c">#设置时区</span>
timedatectl set-timezone Asia/Shanghai
<span class="c">#校正系统时间</span>
yum <span class="nb">install</span> <span class="nt">-y</span> ntpdate
ntpdate ntp.aliyun.com
<span class="c">#将时间写入本地硬件时钟 RTC</span>
timedatectl set-local-rtc 0
<span class="c">#清除及关闭firewalld,关闭selinux</span>
iptables <span class="nt">-F</span>
systemctl  stop firewalld
systemctl disable firewalld
setenforce 0
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'/SELINUX=/c\SELINUX=disabled/'</span> /etc/selinux/config
<span class="c">#关闭swap（因为swap分区使用会影响k8s性能）</span>
swapoff <span class="nt">-a</span>
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'/swap/s/.*/#&amp;/'</span> /etc/fstab
<span class="c">#设置内核及相关网络参数</span>
yum <span class="nb">install</span> <span class="nt">-y</span> ipvsadm ipset
modprobe br_netfilter
modprobe overlay
modprobe ip_vs_sh
modprobe ip_vs_wrr
modprobe ip_vs_rr
modprobe ip_vs

<span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
ip_vs_sh
ip_vs_wrr
ip_vs_rr
ip_vs
</span><span class="no">EOF

</span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables=1
net.bridge.bridge-nf-call-ip6tables=1
net.ipv4.ip_forward=1
net.ipv4.tcp_tw_recycle=0
vm.swappiness=0
vm.overcommit_memory=1
vm.panic_on_oom=0
fs.inotify.max_user_instances=8192
fs.inotify.max_user_watches=1048576
fs.file-max=52706963
fs.nr_open=52706963
net.ipv6.conf.all.disable_ipv6=1
net.netfilter.nf_conntrack_max=2310720
</span><span class="no">EOF

</span>sysctl <span class="nt">-p</span> /etc/sysctl.d/k8s.conf
</code></pre></div></div>

<p>配置定时任务</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab  <span class="nt">-e</span>

01 <span class="k">*</span>/2 <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>  ntpdata   npt.aliyun.com
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl  restart crond.service
</code></pre></div></div>

<p>配置A记录解析</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/hosts <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.25.10  server10
192.168.25.11  server11
192.168.25.12  server12
</span><span class="no">EOF
</span></code></pre></div></div>

<p>安装docer-cd</p>

<p>官方文档：https://docs.docker.com/engine/install/centos/</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#卸载机器上老版本</span>
yum remove docker <span class="se">\</span>
                  docker-client <span class="se">\</span>
                  docker-client-latest <span class="se">\</span>
                  docker-common <span class="se">\</span>
                  docker-latest <span class="se">\</span>
                  docker-latest-logrotate <span class="se">\</span>
                  docker-logrotate <span class="se">\</span>
                  docker-engine
<span class="c">#配置yum源</span>
yum  <span class="nb">install</span> <span class="nt">-y</span> yum-utils
yum-config-manager <span class="se">\</span>
    <span class="nt">--add-repo</span> <span class="se">\</span>
    https://download.docker.com/linux/centos/docker-ce.repo
<span class="c">#安装</span>
yum <span class="nb">install </span>docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
<span class="c">#docker镜像加速及私有仓库信任</span>
<span class="nb">cat</span> <span class="o">&gt;</span> /etc/docker/daemon.json <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
{
   "registry-mirrors":["https://hub-mirror.c.163.com/"],
   "insecure-registries":["http://hub.registry.com"]
}
</span><span class="no">EOF
</span><span class="c">#启动</span>
systemctl start docker
systemctl <span class="nb">enable </span>docker
</code></pre></div></div>

<p>配置kubernetes 阿里仓库源</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
</span><span class="no">EOF
</span></code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum clean all
yum makecache fast
</code></pre></div></div>

<p>安装cri-dockerd</p>

<p>地址：https://github.com/Mirantis/cri-dockerd</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> go git
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-xf</span> /tmp/cri-dockerd.tar.gz
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>cri-dockerd

make cri-dockerd

<span class="nb">install</span> <span class="nt">-o</span> root <span class="nt">-g</span> root <span class="nt">-m</span> 0755 cri-dockerd    /usr/bin/cri-dockerd

 <span class="nb">install </span>packaging/systemd/<span class="k">*</span> /usr/lib/systemd/system/
</code></pre></div></div>

<p>配置systemd文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /usr/lib/systemd/system/cri-docker.service <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">               
[Unit]
Description=CRI Interface for Docker Application Container Engine
Documentation=https://docs.mirantis.com
After=network-online.target firewalld.service docker.service
Wants=network-online.target
Requires=cri-docker.socket
[Service]
Type=notify
ExecStart=/usr/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --cni-bin-dir=/opt/cni/bin --cni-cache-dir=/var/lib/cni/cache --cni-conf-dir=/etc/cni/net.d --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.9
ExecReload=/bin/kill -s HUP 
TimeoutSec=0
RestartSec=2
Restart=always
StartLimitBurst=3
StartLimitInterval=60s
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
Delegate=yes
KillMode=process
[Install]
WantedBy=multi-user.target
</span><span class="no">EOF
</span></code></pre></div></div>

<p>配置socket文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /usr/lib/systemd/system/cri-docker.socket  <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> 
[Unit]
Description=CRI Docker Socket for the API
PartOf=cri-docker.service

[Socket]
ListenStream=%t/cri-dockerd.sock
SocketMode=0660
SocketUser=root
SocketGroup=root

[Install]
WantedBy=sockets.target
</span><span class="no">EOF
</span></code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl start cri-docker.service
systemctl <span class="nb">enable </span>cri-docker.service
</code></pre></div></div>

<p>安装kubeadm工具</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#查看kubernetes历史版本</span>
yum list <span class="nt">--showduplicates</span> | <span class="nb">grep </span>kube
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#安装对应版本</span>
yum <span class="nb">install</span> <span class="nt">-y</span> kubelet-1.26.3 kubectl-1.26.3 kubeadm-1.26.3
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl <span class="nb">enable </span>kubelet
</code></pre></div></div>

<h3 id="master节点操作">master节点操作</h3>

<p>初始化集群</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm init <span class="nt">--apiserver-advertise-address</span><span class="o">=</span>192.168.25.10 <span class="nt">--kubernetes-version</span><span class="o">=</span>v1.26.3 <span class="nt">--image-repository</span> registry.aliyuncs.com/google_containers <span class="nt">--cri-socket</span> unix:///var/run/cri-dockerd.sock <span class="nt">--service-cidr</span><span class="o">=</span>10.1.0.0/16 <span class="nt">--pod-network-cidr</span><span class="o">=</span>10.2.0.0/16 <span class="nt">--token-ttl</span><span class="o">=</span>0
</code></pre></div></div>

<p>看到这些则表示初始化成功</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/.kube
  <span class="nb">sudo cp</span> <span class="nt">-i</span> /etc/kubernetes/admin.conf <span class="nv">$HOME</span>/.kube/config
  <span class="nb">sudo chown</span> <span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>:<span class="si">$(</span><span class="nb">id</span> <span class="nt">-g</span><span class="si">)</span> <span class="nv">$HOME</span>/.kube/config

Alternatively, <span class="k">if </span>you are the root user, you can run:

  <span class="nb">export </span><span class="nv">KUBECONFIG</span><span class="o">=</span>/etc/kubernetes/admin.conf

You should now deploy a pod network to the cluster.
Run <span class="s2">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

Then you can <span class="nb">join </span>any number of worker nodes by running the following oneach as root:

kubeadm <span class="nb">join </span>192.168.25.10:6443 <span class="nt">--token</span> xg7ibt.8qonzrnjziedn8o6 <span class="se">\\</span>
	<span class="nt">--discovery-token-ca-cert-hash</span> sha256:bba7097fa4fb06aab523d24f6788e5552a86202fc7a74ed09406fb21915dd87c
</code></pre></div></div>

<p>按提示信息建立kubernetes集群配置文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/.kube
<span class="nb">sudo cp</span> <span class="nt">-i</span> /etc/kubernetes/admin.conf <span class="nv">$HOME</span>/.kube/config
<span class="nb">sudo chown</span> <span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>:<span class="si">$(</span><span class="nb">id</span> <span class="nt">-g</span><span class="si">)</span> <span class="nv">$HOME</span>/.kube/config
<span class="nb">export </span><span class="nv">KUBECONFIG</span><span class="o">=</span>/etc/kubernetes/admin.conf
</code></pre></div></div>

<p>如果初始集群错误，可以清除尝试重新初始化</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm</span> <span class="nt">-rf</span> /etc/kubernetes/<span class="k">*</span>
<span class="nb">rm</span> <span class="nt">-rf</span> ~/.kube/<span class="k">*</span>
<span class="nb">rm</span> <span class="nt">-rf</span> /var/lib/etcd/<span class="k">*</span>
kubeadm reset
</code></pre></div></div>

<h3 id="配置kubernetes命令shell--tab补全">配置kubernetes命令shell  tab补全</h3>

<p>官方文档：https://v1-26.docs.kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install </span>bash-com<span class="k">*</span>
kubectl completion bash | <span class="nb">sudo tee</span> /etc/bash<span class="se">\_</span>completion.d/kubectl <span class="o">&gt;</span> /dev/null
<span class="nb">chmod </span>a+r /etc/bash_completion.d/kubectl
<span class="nb">echo</span> <span class="s1">'alias k=kubectl'</span> <span class="o">&gt;&gt;</span>~/.bashrc
<span class="nb">echo</span> <span class="s1">'complete -o default -F __start_kubectl k'</span> <span class="o">&gt;&gt;</span>~/.bashrc
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#最后</span>
 <span class="nb">exit</span>
 <span class="c">#或者</span>
 <span class="nb">source</span>
 <span class="c">#重加载shell</span>
</code></pre></div></div>

<h3 id="子节点">子节点</h3>

<p>先删除可能影响的因数</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm</span> <span class="nt">-rf</span> /var/run/containerd/containerd.sock
</code></pre></div></div>

<p>加入master集群</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm <span class="nb">join </span>192.168.25.10:6443 <span class="nt">--token</span> xg7ibt.8qonzrnjziedn8o6 <span class="nt">--discovery-token-ca-cert-hash</span> sha256:bba7097fa4fb06aab523d24f6788e5552a86202fc7a74ed09406fb21915dd87c
</code></pre></div></div>

<p>所有节点记得将以下服务设置开机启动</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl <span class="nb">enable </span>docker
systemctl <span class="nb">enable </span>cri-docker
systemctl <span class="nb">enable </span>kubelet
</code></pre></div></div>

<p>master看到一下则为成功搭建集群</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get nodes

NAME       STATUS     ROLES           AGE     VERSION
server10   NotReady   control-plane   8m29s   v1.26.3
server11   NotReady   &lt;none&gt;          5m20s   v1.26.3
server12   NotReady   &lt;none&gt;          5m3s    v1.26.3
</code></pre></div></div>

<h3 id="flannel网络组件安装">Flannel网络组件安装</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/kubernetes/manifests
wget https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml
</code></pre></div></div>

<p>查看组件所需镜像</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span>  <span class="s2">"image:"</span>  kube-flannel.yml 

image: docker.io/flannel/flannel:v0.23.0
image: docker.io/flannel/flannel-cni-plugin:v1.2.0
image: docker.io/flannel/flannel:v0.23.0
</code></pre></div></div>

<p>修改配置文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/kubernetes/manifests/kube-flannel.yml
<span class="c">#约91行，修改"Network",修改成集群初始化的配置 --pod-network-cidr 指定的ip</span>
 89   net-conf.json: |
 90     <span class="o">{</span>
 91       <span class="s2">"Network"</span>: <span class="s2">"10.2.0.0/16"</span>,
 92       <span class="s2">"Backend"</span>: <span class="o">{</span>
 93         <span class="s2">"Type"</span>: <span class="s2">"vxlan"</span>
 94       <span class="o">}</span>
 95     <span class="o">}</span>
 
<span class="c">#约138行，修改"args"里的数组，添加上--iface=ens33</span>
135       containers:
136       - args:
137         - <span class="nt">--ip-masq</span>
138         - <span class="nt">--kube-subnet-mgr</span>
139         - <span class="nt">--iface</span><span class="o">=</span>ens33

</code></pre></div></div>

<p>启动组件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> kube-flannel.yml
</code></pre></div></div>

<p>启动之后成功，将NotReady改为Ready</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get nodes

NAME       STATUS   ROLES           AGE   VERSION
server10   Ready    control-plane   14m   v1.26.3
server11   Ready    &lt;none&gt;          11m   v1.26.3
server12   Ready    &lt;none&gt;          11m   v1.26.3
</code></pre></div></div>

<h3 id="升级内核">升级内核</h3>

<p>centos7系统内核 &gt;=4.1 (3.10的内核运行高版本的k8s集群存在不稳定因素)</p>

<p>内核的yum源</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/yum.repos.d/kernel.repo <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
[kernel]
name="kernel install."
baseurl=https://elrepo.org/linux/kernel/el7/x86_64/
enabled=1
gpgcheck=0
</span><span class="no">EOF
</span></code></pre></div></div>

<p>安装新内核</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install </span>kernel-lt-5.4.260
<span class="c">#或者载rpm包本地安装</span>
<span class="c"># rpm -ivh /tmp/kernel-lt-5.4.260-1.el7.elrepo.x86_64.rpm</span>
</code></pre></div></div>

<p>设置开机默认启动使用新内核</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grub2-set-default 5.4.260-1.el7.elrepo.x86_64
</code></pre></div></div>

<p>重启</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reboot
</code></pre></div></div>

<p>查看新内核</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">uname</span> <span class="nt">-r</span>
</code></pre></div></div>

<h3 id="修改kube-proxy使用ipvs">修改kube-proxy使用ipvs</h3>

<p>使用edit修改</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl edit cm <span class="nt">-n</span> kube-system kube-proxy

<span class="c">#约48行</span>
<span class="c">#把mode: "" 改成 mode: "ipvs"</span>
<span class="c">#因为edit属于热更改，等一段时间也会自己更新为ipvs模式</span>
</code></pre></div></div>

<p>删除原来的kube-proxy</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete pod <span class="nt">-l</span>  k8s-app<span class="o">=</span>kube-proxy <span class="nt">-n</span> kube-system
</code></pre></div></div>

<p>通过查看kube-proxy的日志可以看到使用信息</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl logs <span class="nt">-n</span> kube-system kube-proxy-pzxr9

<span class="c">#有类似此类信息  "Using ipvs Proxier"</span>
</code></pre></div></div>

<p>通过ipvsadm可以查看到代理规则</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ipvsadm <span class="nt">-Ln</span>
</code></pre></div></div>

<h2 id="kubernetes多master高可用集群搭建">Kubernetes多master高可用集群搭建</h2>

<h3 id="环境-1">环境</h3>

<p>硬件环境：Centos7，2C2G</p>

<table>
  <thead>
    <tr>
      <th>hosts</th>
      <th>ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>server10(master)</td>
      <td>192.168.25.10</td>
    </tr>
    <tr>
      <td>server11(master)</td>
      <td>192.168.25.11</td>
    </tr>
    <tr>
      <td>server12(master)</td>
      <td>192.168.25.12</td>
    </tr>
    <tr>
      <td>server13</td>
      <td>192.168.25.13</td>
    </tr>
  </tbody>
</table>

<h3 id="系统整体环境配置所有节点又要配置-1">系统整体环境配置，所有节点又要配置</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#语言设置</span>
localectl set-locale <span class="nv">LANG</span><span class="o">=</span>en_US.utf8
<span class="c">#epel源</span>
wget <span class="nt">-O</span> /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repo
<span class="c">#设置时区</span>
timedatectl set-timezone Asia/Shanghai
<span class="c">#校正系统时间</span>
yum <span class="nb">install</span> <span class="nt">-y</span> ntpdate
ntpdate ntp.aliyun.com
<span class="c">#将时间写入本地硬件时钟 RTC</span>
timedatectl set-local-rtc 0
<span class="c">#清除及关闭firewalld,关闭selinux</span>
iptables <span class="nt">-F</span>
systemctl  stop firewalld
systemctl disable firewalld
setenforce 0
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'/SELINUX=/c\SELINUX=disabled/'</span> /etc/selinux/config
<span class="c">#关闭swap（因为swap分区使用会影响k8s性能）</span>
swapoff <span class="nt">-a</span>
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'/swap/s/.*/#&amp;/'</span> /etc/fstab
<span class="c">#设置内核及相关网络参数</span>
yum <span class="nb">install</span> <span class="nt">-y</span> ipvsadm ipset
modprobe br_netfilter
modprobe overlay
modprobe ip_vs_sh
modprobe ip_vs_wrr
modprobe ip_vs_rr
modprobe ip_vs

<span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
ip_vs_sh
ip_vs_wrr
ip_vs_rr
ip_vs
</span><span class="no">EOF

</span><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables=1
net.bridge.bridge-nf-call-ip6tables=1
net.ipv4.ip_forward=1
net.ipv4.tcp_tw_recycle=0
vm.swappiness=0
vm.overcommit_memory=1
vm.panic_on_oom=0
fs.inotify.max_user_instances=8192
fs.inotify.max_user_watches=1048576
fs.file-max=52706963
fs.nr_open=52706963
net.ipv6.conf.all.disable_ipv6=1
net.netfilter.nf_conntrack_max=2310720
</span><span class="no">EOF

</span>sysctl <span class="nt">-p</span> /etc/sysctl.d/k8s.conf
</code></pre></div></div>

<p>配置定时任务</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>crontab  <span class="nt">-e</span>

01 <span class="k">*</span>/2 <span class="k">*</span> <span class="k">*</span> <span class="k">*</span>  ntpdata   npt.aliyun.com
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl  restart crond.service
</code></pre></div></div>

<p>配置A记录解析</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/hosts <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.25.10  server10
192.168.25.11  server11
192.168.25.12  server12
192.168.25.13  server13
192.168.25.20  server20  hub.registry.com
</span><span class="no">EOF
</span></code></pre></div></div>

<p>安装docer-cd</p>

<p>官方文档：https://docs.docker.com/engine/install/centos/</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#卸载机器上老版本</span>
yum remove docker <span class="se">\</span>
                  docker-client <span class="se">\</span>
                  docker-client-latest <span class="se">\</span>
                  docker-common <span class="se">\</span>
                  docker-latest <span class="se">\</span>
                  docker-latest-logrotate <span class="se">\</span>
                  docker-logrotate <span class="se">\</span>
                  docker-engine
<span class="c">#配置yum源</span>
yum  <span class="nb">install</span> <span class="nt">-y</span> yum-utils
yum-config-manager <span class="se">\</span>
    <span class="nt">--add-repo</span> <span class="se">\</span>
    https://download.docker.com/linux/centos/docker-ce.repo
<span class="c">#安装</span>
yum <span class="nb">install </span>docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
<span class="c">#docker镜像加速及私有仓库信任</span>
<span class="nb">cat</span> <span class="o">&gt;</span> /etc/docker/daemon.json <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
{
   "registry-mirrors":["https://hub-mirror.c.163.com/"],
   "insecure-registries":["http://hub.registry.com"]
}
</span><span class="no">EOF
</span><span class="c">#启动</span>
systemctl start docker
systemctl <span class="nb">enable </span>docker
</code></pre></div></div>

<p>配置kubernetes 阿里仓库源</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh"> &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
</span><span class="no">EOF
</span></code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum clean all
yum makecache fast
</code></pre></div></div>

<p>安装cri-dockerd</p>

<p>地址：https://github.com/Mirantis/cri-dockerd</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> go git
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-xf</span> /tmp/cri-dockerd.tar.gz
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>cri-dockerd

make cri-dockerd

<span class="nb">install</span> <span class="nt">-o</span> root <span class="nt">-g</span> root <span class="nt">-m</span> 0755 cri-dockerd    /usr/bin/cri-dockerd

<span class="nb">install </span>packaging/systemd/<span class="k">*</span> /usr/lib/systemd/system/
</code></pre></div></div>

<p>配置cri-dockerd的systemd文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /usr/lib/systemd/system/cri-docker.service <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">               
[Unit]
Description=CRI Interface for Docker Application Container Engine
Documentation=https://docs.mirantis.com
After=network-online.target firewalld.service docker.service
Wants=network-online.target
Requires=cri-docker.socket
[Service]
Type=notify
ExecStart=/usr/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --cni-bin-dir=/opt/cni/bin --cni-cache-dir=/var/lib/cni/cache --cni-conf-dir=/etc/cni/net.d --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.9
ExecReload=/bin/kill -s HUP 
TimeoutSec=0
RestartSec=2
Restart=always
StartLimitBurst=3
StartLimitInterval=60s
LimitNOFILE=infinity
LimitNPROC=infinity
LimitCORE=infinity
TasksMax=infinity
Delegate=yes
KillMode=process
[Install]
WantedBy=multi-user.target
</span><span class="no">EOF
</span></code></pre></div></div>

<p>配置cri-dockerd的socket文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /usr/lib/systemd/system/cri-docker.socket  <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh"> 
[Unit]
Description=CRI Docker Socket for the API
PartOf=cri-docker.service

[Socket]
ListenStream=%t/cri-dockerd.sock
SocketMode=0660
SocketUser=root
SocketGroup=root

[Install]
WantedBy=sockets.target
</span><span class="no">EOF
</span></code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl daemon-reload
systemctl start cri-docker.service
systemctl <span class="nb">enable </span>cri-docker.service
</code></pre></div></div>

<p>安装kubeadm工具</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#查看kubernetes历史版本</span>
yum list <span class="nt">--showduplicates</span> | <span class="nb">grep </span>kube
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#安装对应版本</span>
yum <span class="nb">install</span> <span class="nt">-y</span> kubelet-1.26.3 kubectl-1.26.3 kubeadm-1.26.3
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl <span class="nb">enable </span>kubelet
</code></pre></div></div>

<h3 id="部署apiserver的负载均衡器">部署apiServer的负载均衡器</h3>

<p>所有master节点都操作</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> haproxy keepalived
</code></pre></div></div>

<p>haproxy配置文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/haproxy/haproxy.cfg

<span class="c">#三个master的haproxy配置文件可以相同 </span>
global
    log         127.0.0.1 local2
    <span class="nb">chroot</span>      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     4000
    user        haproxy
    group       haproxy
    daemon

    stats socket /var/lib/haproxy/stats

defaults
    mode                    tcp
    log                     global
    option                  httplog
    option                  dontlognull
    option http-server-close
    option forwardfor       except 127.0.0.0/8
    option                  redispatch
    retries                 3
    <span class="nb">timeout </span>http-request    10s
    <span class="nb">timeout </span>queue           1m
    <span class="nb">timeout </span>connect         10s
    <span class="nb">timeout </span>client          1m
    <span class="nb">timeout </span>server          1m
    <span class="nb">timeout </span>http-keep-alive 10s
    <span class="nb">timeout </span>check           10s
    maxconn                 3000

frontend    k8s-api
   <span class="c">#haproxy的工作端口</span>
   <span class="nb">bind</span>     :16443
   mode     tcp
   maxconn  50000
   default_backend  k8s-api-backend

backend  k8s-api-backend
    <span class="c">#三个master进行负载均衡</span>
    balance roundrobin
    server  server10  192.168.25.10:6443  weight 1 check inter 5s rise 2 fall 3
    server  server11  192.168.25.11:6443  weight 1 check inter 5s rise 2 fall 3
    server  server13  192.168.25.12:6443  weight 1 check inter 5s rise 2 fall 3
</code></pre></div></div>

<p>keepalived配置文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/keepalived/keepalived.conf 

<span class="o">!</span> Configuration File <span class="k">for </span>keepalived
global_defs <span class="o">{</span>
   <span class="c">#每个master的router_id 要不相同</span>
   router_id  server10
   vrrp_mcast_group4  224.3.3.3
   script_user  root
   enable_script_security
<span class="o">}</span>

vrrp_script chklive <span class="o">{</span>
    script  /etc/keepalived/chkhaproxy.sh
    interval 1
    weight  <span class="nt">-3</span>
    <span class="nb">timeout  </span>5
<span class="o">}</span>

vrrp_instance VI_1 <span class="o">{</span>
    nopreempt
    state     BACKUP
    interface ens33
    <span class="c">#可以根据情况修改优先级</span>
    priority  100
    virtual_router_id 51

    advert_int 3
    authentication <span class="o">{</span>
        auth_type PASS
        auth_pass 1111
    <span class="o">}</span>
    virtual_ipaddress <span class="o">{</span>
        <span class="c">#改成自己的VIP</span>
        192.168.25.99
    <span class="o">}</span>

    track_script <span class="o">{</span>
        chklive
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>keepalived脚本</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/keepalived/chkhaproxy.sh 

<span class="c">#! /bin/bash</span>

<span class="k">if</span> <span class="o">!</span> netstat  <span class="nt">-nlpt</span> | <span class="nb">grep</span> <span class="nt">-w</span> <span class="se">\"</span>16443<span class="se">\"</span> &amp;&gt; /dev/null
<span class="k">then
    </span>systemctl  stop keepalived
<span class="k">fi
</span><span class="nb">exit </span>0
</code></pre></div></div>

<p>给脚本权限</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> +x /etc/keepalived/chkhaproxy.sh
</code></pre></div></div>

<p>设置开机自启并启动</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl <span class="nb">enable</span> <span class="nt">--now</span> haproxy
systemctl <span class="nb">enable</span> <span class="nt">--now</span> keepalived
</code></pre></div></div>

<p>使用<strong>ip addr</strong>查看VIP在哪台master，然后对有VIP的master测试VIP是否会漂移</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl stop haproxy
</code></pre></div></div>

<p>VIP会根据keepalived设置的优先级进行漂移，查看其他master节点，使用ip addr查看VIP是否已经漂移到别的节点，若出现VIP则高可用成功</p>

<p>测试完后要记得把haproxy和keepalived重启启动。</p>

<h3 id="初始化集群">初始化集群</h3>

<p>在有VIP的master节点上执行命令</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm init <span class="nt">--apiserver-advertise-address</span><span class="o">=</span>192.168.25.10 <span class="nt">--kubernetes-version</span><span class="o">=</span>v1.26.3 <span class="nt">--image-repository</span> registry.aliyuncs.com/google_containers <span class="nt">--cri-socket</span> unix:///var/run/cri-dockerd.sock <span class="nt">--service-cidr</span><span class="o">=</span>10.1.0.0/16 <span class="nt">--pod-network-cidr</span><span class="o">=</span>10.2.0.0/16 <span class="nt">--control-plane-endpoint</span> <span class="s2">"192.168.25.99:16443"</span> <span class="nt">--upload-certs</span> 
</code></pre></div></div>

<p>成功则显示这个</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/.kube
  <span class="nb">sudo cp</span> <span class="nt">-i</span> /etc/kubernetes/admin.conf <span class="nv">$HOME</span>/.kube/config
  <span class="nb">sudo chown</span> <span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>:<span class="si">$(</span><span class="nb">id</span> <span class="nt">-g</span><span class="si">)</span> <span class="nv">$HOME</span>/.kube/config

Alternatively, <span class="k">if </span>you are the root user, you can run:

  <span class="nb">export </span><span class="nv">KUBECONFIG</span><span class="o">=</span>/etc/kubernetes/admin.conf

You should now deploy a pod network to the cluster.
Run <span class="s2">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

You can now <span class="nb">join </span>any number of the control-plane node running the following <span class="nb">command </span>on each as root:

  kubeadm <span class="nb">join </span>192.168.25.99:16443 <span class="nt">--token</span> 0ojcff.13901wo8w8u60f92 <span class="se">\\</span>
	<span class="nt">--discovery-token-ca-cert-hash</span> sha256:81b112b4737542d2410c99a851c1917070ce5a291fa120145d5289782e4c7ff6 <span class="se">\\</span>
	<span class="nt">--control-plane</span> <span class="nt">--certificate-key</span> e3b7091a454d1b1cf9f5ca19bfbd94749ab306c03192118088f6866430e3a132

Please note that the certificate-key gives access to cluster sensitive data, keep it secret!
As a safeguard, uploaded-certs will be deleted <span class="k">in </span>two hours<span class="p">;</span> If necessary,you can use
<span class="s2">"kubeadm init phase upload-certs --upload-certs"</span> to reload certs afterward.

Then you can <span class="nb">join </span>any number of worker nodes by running the following on each as root:

kubeadm <span class="nb">join </span>192.168.25.99:16443 <span class="nt">--token</span> 0ojcff.13901wo8w8u60f92 <span class="se">\\</span>
	<span class="nt">--discovery-token-ca-cert-hash</span> sha256:81b112b4737542d2410c99a851c1917070ce5a291fa120145d5289782e4c7ff6
</code></pre></div></div>

<p>其他master节点加入集群，这里的token和证书有有效期，有效期过了token就会失效，想要再加入集群需要再次创建token，使用命令<strong><code class="language-plaintext highlighter-rouge">kubeadm token create</code></strong> 创建token</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm <span class="nb">join </span>192.168.25.99:16443 <span class="nt">--token</span> 0ojcff.13901wo8w8u60f92 <span class="se">\\</span>
	<span class="nt">--discovery-token-ca-cert-hash</span> sha256:81b112b4737542d2410c99a851c1917070ce5a291fa120145d5289782e4c7ff6 <span class="se">\\</span>
	<span class="nt">--control-plane</span> <span class="nt">--certificate-key</span> e3b7091a454d1b1cf9f5ca19bfbd94749ab306c03192118088f6866430e3a132 <span class="se">\\</span>
	<span class="nt">--cri-socket</span> unix:///var/run/cri-dockerd.sock
</code></pre></div></div>

<p>成功后根据提示</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="nv">$HOME</span>/.kube
<span class="nb">sudo cp</span> <span class="nt">-i</span> /etc/kubernetes/admin.conf <span class="nv">$HOME</span>/.kube/config
<span class="nb">sudo chown</span> <span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span>:<span class="si">$(</span><span class="nb">id</span> <span class="nt">-g</span><span class="si">)</span> <span class="nv">$HOME</span>/.kube/config
</code></pre></div></div>

<p>加入node节点</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubeadm <span class="nb">join </span>192.168.25.99:16443 <span class="nt">--token</span> 0ojcff.13901wo8w8u60f92 <span class="se">\</span>
	<span class="nt">--discovery-token-ca-cert-hash</span> sha256:81b112b4737542d2410c99a851c1917070ce5a291fa120145d5289782e4c7ff6 <span class="se">\</span>
	<span class="nt">--cri-socket</span> unix:///var/run/cri-dockerd.sock
</code></pre></div></div>

<p>查看集群状态</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get nodes

NAME       STATUS   ROLES           AGE   VERSION
server10   Ready    control-plane   8d    v1.26.3
server11   Ready    control-plane   8d    v1.26.3
server12   Ready    control-plane   8d    v1.26.3
server13   Ready    &lt;none&gt;          8d    v1.26.3
</code></pre></div></div>

<h3 id="配置kubernetes命令shell--tab补全-1">配置kubernetes命令shell  tab补全</h3>

<p>官方文档：https://v1-26.docs.kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> bash-com<span class="k">*</span>
kubectl completion bash | <span class="nb">sudo tee</span> /etc/bash<span class="se">\_</span>completion.d/kubectl <span class="o">&gt;</span> /dev/null
<span class="nb">chmod </span>a+r /etc/bash_completion.d/kubectl
<span class="nb">echo</span> <span class="s1">'alias k=kubectl'</span> <span class="o">&gt;&gt;</span>~/.bashrc
<span class="nb">echo</span> <span class="s1">'complete -o default -F __start_kubectl k'</span> <span class="o">&gt;&gt;</span>~/.bashrc
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c">#最后</span>
 <span class="nb">exit</span>
</code></pre></div></div>

<h3 id="flannel网络组件安装-1">Flannel网络组件安装</h3>

<p>只在master节点上安装</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /etc/kubernetes/manifests
wget https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml
</code></pre></div></div>

<p>查看组件所需镜像</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span>  <span class="s2">"image:"</span>  kube-flannel.yml 

image: docker.io/flannel/flannel:v0.23.0
image: docker.io/flannel/flannel-cni-plugin:v1.2.0
image: docker.io/flannel/flannel:v0.23.0
</code></pre></div></div>

<p>修改配置文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/kubernetes/manifests/kube-flannel.yml
<span class="c">#约91行，修改"Network",修改成集群初始化的配置 --pod-network-cidr 指定的ip</span>
 89   net-conf.json: |
 90     <span class="o">{</span>
 91       <span class="s2">"Network"</span>: <span class="s2">"10.2.0.0/16"</span>,
 92       <span class="s2">"Backend"</span>: <span class="o">{</span>
 93         <span class="s2">"Type"</span>: <span class="s2">"vxlan"</span>
 94       <span class="o">}</span>
 95     <span class="o">}</span>
 
<span class="c">#约138行，修改"args"里的数组，添加上--iface=ens33</span>
135       containers:
136       - args:
137         - <span class="nt">--ip-masq</span>
138         - <span class="nt">--kube-subnet-mgr</span>
139         - <span class="nt">--iface</span><span class="o">=</span>ens33

</code></pre></div></div>

<p>启动组件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> kube-flannel.yml
</code></pre></div></div>

<p>启动之后成功，在所有master节点上运行，NotReady变为Ready</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get nodes

NAME       STATUS   ROLES           AGE   VERSION
server10   Ready    control-plane   14m   v1.26.3
server11   Ready    &lt;none&gt;          11m   v1.26.3
server12   Ready    &lt;none&gt;          11m   v1.26.3
</code></pre></div></div>

<h3 id="升级内核-1">升级内核</h3>

<p>centos7系统内核 &gt;=4.1 (3.10的内核运行高版本的k8s集群存在不稳定因素)</p>

<p>内核的yum源</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/yum.repos.d/kernel.repo <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
[kernel]
name="kernel install."
baseurl=https://elrepo.org/linux/kernel/el7/x86_64/
enabled=1
gpgcheck=0
</span><span class="no">EOF
</span></code></pre></div></div>

<p>安装新内核</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install </span>kernel-lt-5.4.260
<span class="c">#或者载rpm包本地安装</span>
<span class="c"># rpm -ivh /tmp/kernel-lt-5.4.260-1.el7.elrepo.x86_64.rpm</span>
</code></pre></div></div>

<p>设置开机默认启动使用新内核</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grub2-set-default 5.4.260-1.el7.elrepo.x86_64
</code></pre></div></div>

<p>重启</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reboot
</code></pre></div></div>

<p>查看新内核</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">uname</span> <span class="nt">-r</span>
</code></pre></div></div>

<h3 id="修改kube-proxy使用ipvs-1">修改kube-proxy使用ipvs</h3>

<p>使用edit修改</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl edit cm <span class="nt">-n</span> kube-system kube-proxy

<span class="c">#约48行</span>
<span class="c">#把mode: "" 改成 mode: "ipvs"</span>
<span class="c">#因为edit属于热更改，等一段时间也会自己更新为ipvs模式</span>
</code></pre></div></div>

<p>删除原来的kube-proxy</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete pod <span class="nt">-l</span>  k8s-app<span class="o">=</span>kube-proxy <span class="nt">-n</span> kube-system
</code></pre></div></div>

<p>通过查看kube-proxy的日志可以看到使用信息</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl logs <span class="nt">-n</span> kube-system kube-proxy-pzxr9

<span class="c">#有类似此类信息  "Using ipvs Proxier"</span>
</code></pre></div></div>

<p>通过ipvsadm可以查看到代理规则</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ipvsadm <span class="nt">-Ln</span>
</code></pre></div></div>]]></content><author><name>FatGuy010</name></author><category term="Linux" /><category term="Kubernetes" /><summary type="html"><![CDATA[Kubernetes单master集群搭建]]></summary></entry><entry><title type="html">源码安装php</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/19/InstallPHP" rel="alternate" type="text/html" title="源码安装php" /><published>2023-09-19T00:00:00+00:00</published><updated>2023-09-19T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/19/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85php5.6.39</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/19/InstallPHP"><![CDATA[<h4 id="源码安装php5639">源码安装php5.6.39</h4>

<p>php5.6.39  安装包</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://prototype.php.net/distributions/php-5.6.39.tar.bz2
</code></pre></div></div>

<h5 id="一安装依赖不一定完整">一、安装依赖（不一定完整）</h5>

<p>PS:安装源码时 确保  base   epel 源可用</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> gcc  libxml2-devel  bzip2-devel   oniguruma-devel   libpng-devel  libjpeg-turbo-devel  freetype-devel  openssl-devel  libmcrypt-devel
</code></pre></div></div>

<h5 id="二编译">二、编译</h5>

<p>进入到解压目录</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./configure <span class="nt">--prefix</span><span class="o">=</span>/usr/local/php5.6 <span class="nt">--with-mysql</span><span class="o">=</span>mysqlnd <span class="nt">--with-pdo-mysql</span><span class="o">=</span>mysqlnd <span class="nt">--with-mysqli</span><span class="o">=</span>mysqlnd <span class="nt">--with-openssl</span> <span class="nt">--enable-fpm</span> <span class="nt">--enable-sockets</span> <span class="nt">--enable-sysvshm</span> <span class="nt">--enable-mbstring</span> <span class="nt">--with-freetype-dir</span> <span class="nt">--with-gd</span> <span class="nt">--with-jpeg-dir</span> <span class="nt">--with-png-dir</span> <span class="nt">--with-zlib</span> <span class="nt">--with-libxml-dir</span> <span class="nt">--enable-xml</span> <span class="nt">--with-mhash</span> <span class="nt">--with-mcrypt</span> <span class="nt">--with-config-file-path</span><span class="o">=</span>/etc <span class="nt">--with-config-file-scan-dir</span><span class="o">=</span>/etc/php.d <span class="nt">--with-bz2</span> <span class="nt">--enable-maintainer-zts</span> <span class="nt">--without-pear</span>  <span class="nt">--disable-phar</span>
</code></pre></div></div>

<h5 id="三make--make-install">三、make &amp;&amp; make install</h5>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j2</span> <span class="o">&amp;&amp;</span> make <span class="nb">install</span>
</code></pre></div></div>

<p>-j2  多进程安装（加快速度）</p>

<h5 id="四php的配置文件">四、php的配置文件</h5>

<p>php.ini</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp </span>php.ini-production /etc/php.ini
</code></pre></div></div>

<p>php.ini-production  在解压出来的php5.6目录里边</p>

<p>php-fpm.conf</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cp</span> /usr/local/php5.6/etc/php-fpm.conf.default /usr/local/php5.6/etc/php-fpm.conf
</code></pre></div></div>

<h5 id="五启动php">五、启动php</h5>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/local/php5.6/sbin/php-fpm <span class="nt">-D</span>
</code></pre></div></div>

<p>查看帮助文档</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/local/php5.6/sbin/php-fpm <span class="nt">-h</span>
</code></pre></div></div>]]></content><author><name>FatGuy010</name></author><category term="Linux" /><category term="php" /><summary type="html"><![CDATA[源码安装php5.6.39 php5.6.39 安装包 https://prototype.php.net/distributions/php-5.6.39.tar.bz2 一、安装依赖（不一定完整） PS:安装源码时 确保 base epel 源可用 yum install -y gcc libxml2-devel bzip2-devel oniguruma-devel libpng-devel libjpeg-turbo-devel freetype-devel openssl-devel libmcrypt-devel 二、编译 进入到解压目录 ./configure --prefix=/usr/local/php5.6 --with-mysql=mysqlnd --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd --with-openssl --enable-fpm --enable-sockets --enable-sysvshm --enable-mbstring --with-freetype-dir --with-gd --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir --enable-xml --with-mhash --with-mcrypt --with-config-file-path=/etc --with-config-file-scan-dir=/etc/php.d --with-bz2 --enable-maintainer-zts --without-pear --disable-phar 三、make &amp;&amp; make install make -j2 &amp;&amp; make install -j2 多进程安装（加快速度） 四、php的配置文件 php.ini cp php.ini-production /etc/php.ini php.ini-production 在解压出来的php5.6目录里边 php-fpm.conf cp /usr/local/php5.6/etc/php-fpm.conf.default /usr/local/php5.6/etc/php-fpm.conf 五、启动php /usr/local/php5.6/sbin/php-fpm -D 查看帮助文档 /usr/local/php5.6/sbin/php-fpm -h]]></summary></entry><entry><title type="html">扩展命令</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/2022/09/17/ExtensionCommand" rel="alternate" type="text/html" title="扩展命令" /><published>2023-09-17T00:00:00+00:00</published><updated>2023-09-17T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/2022/09/17/%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/2022/09/17/ExtensionCommand"><![CDATA[<h2 id="mkpasswd-命令生成随机复杂密码">mkpasswd 命令生成随机复杂密码</h2>

<p>mkpasswd命令生成随机复杂密码，前提安装expect，然后执行mkpasswd命令即可生成随机的密码。</p>

<p>一、基本的命令安装
安装expect：   yum install -y expect</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-l #      (密码的长度定义, 默认是 9)
-d #      (数字个数, 默认是 2)
-c #      (小写字符, 默认是 3)
-C #      (大写字符, 默认是 2)
-s #      (特殊字符, 默认是  1)
-v        (详细。。。)
-p prog   (程序设置密码, 默认是 passwd)
</code></pre></div></div>

<p>详细参数，用如下命令查看：</p>

<p>创建了一个长度为20位,包括数字个数5个，包含小写字母个数5个，包含大写字母个数5个，包含特殊符号个数5个。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkpasswd  -l 20 -d 5 -c 5 -C 5 -s 5 
Z}K7hp0UPJ6v@&amp;,c5{d3
</code></pre></div></div>

<p>随机密码最短只能7位（两个数字，两个小写字母，两个大写字母，一个特殊符号）</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkpasswd -l 5
impossible to generate 5-character password with 2 numbers, 2 lowercase letters, 2 uppercase letters and 1 special characters.

</code></pre></div></div>

<h2 id="bc-计算器">bc 计算器</h2>

<p>bc 命令是任意精度计算器语言，通常在linux下当计算器用。它类似基本的计算器, 使用这个计算器可以做基本的数学运算。</p>

<ul>
  <li>-i：强制进入交互式模式；</li>
  <li>-l：定义使用的标准数学库</li>
  <li>； -w：对POSIX bc的扩展给出警告信息；</li>
  <li>-q：不打印正常的GNU bc环境信息；</li>
  <li>-v：显示指令版本信息；</li>
  <li>
    <p>-h：显示指令的帮助信息。</p>
  </li>
  <li>quit： 退出</li>
</ul>

<p><strong>通过管道符</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo "15+5" | bc
20
</code></pre></div></div>

<p>scale=2 设小数位，2 代表保留两位:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo 'scale=2; (2.777 - 1.4744)/1' | bc
1.30
</code></pre></div></div>

<p>bc 除了 scale 来设定小数位之外，还有 ibase 和 obase 来其它进制的运算:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo "ibase=2;111" |bc
7
</code></pre></div></div>

<p><strong>进制转换</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

abc=192 
echo "obase=2;$abc" | bc
</code></pre></div></div>

<p>执行结果为：11000000，这是用bc将十进制转换成二进制。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash 

abc=11000000 
echo "obase=10;ibase=2;$abc" | bc
</code></pre></div></div>

<p>执行结果为：192，这是用bc将二进制转换为十进制。</p>

<p>计算平方和平方根：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo "10^10" | bc 
10000000000
$ echo "sqrt(100)" | bc
10
</code></pre></div></div>

<h2 id="ack-文本搜索工具">ack 文本搜索工具</h2>

<p>比grep好用的文本搜索工具</p>

<p><a href="https://jaywcjlove.gitee.io/linux-command/c/ack.html">原链接</a></p>

<p><a href="https://beyondgrep.com/">官网</a></p>

<p><strong>安装</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ubuntu下要安装ack-grep，因为在debian系中，ack这个名字被其他的软件占用了。</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>ack-grep

<span class="c"># alpine Linux-apk软件包管理器 安装 ack</span>
apk <span class="nb">install </span>ack

<span class="c"># Centos7 要准备好epel源</span>
yum <span class="nb">install</span> <span class="nt">-y</span> ack.noarch
</code></pre></div></div>

<p><strong>参数</strong></p>

<p>这些参数在linux上的适用频率是相当高的，尤其是你用vim做为IDE的话</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-n</span>, 显示行号
<span class="nt">-l</span>, 显示匹配的文件名
<span class="nt">-L</span>, 显示不匹配的文件名
<span class="nt">-c</span>, 统计次数
<span class="nt">-w</span>, 词匹配
<span class="nt">-i</span>, 忽略大小写
<span class="nt">-f</span>, 只显示文件名,不进行搜索.
<span class="nt">-h</span>, 不显示名称
<span class="nt">-v</span>, 显示不匹配
</code></pre></div></div>

<p><strong>特点</strong></p>

<p>ack官网列出了这工具的5大卖点：</p>

<ol>
  <li>速度非常快,因为它只搜索有意义的东西。</li>
  <li>更友好的搜索，忽略那些不是你源码的东西。</li>
  <li>为源代码搜索而设计，用更少的击键完成任务。</li>
  <li>非常轻便，移植性好。</li>
  <li>免费且开源</li>
</ol>

<p><strong>实例</strong></p>

<p>grep常用操作</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="nt">-r</span> <span class="s1">'hello_world'</span> <span class="c"># 简单用法</span>
<span class="nb">grep</span> <span class="s1">'^hello_world'</span> <span class="nb">.</span> <span class="c"># 简单正则</span>
<span class="nb">ls</span> <span class="nt">-l</span> | <span class="nb">grep</span> .py <span class="c"># 管道用法</span>
</code></pre></div></div>

<p><strong>搜索</strong></p>

<p>简单的文本搜索，默认是递归的。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ack hello
ack -i hello
ack -v hello
ack -w hello
ack -Q 'hello*'
</code></pre></div></div>

<p><strong>搜索文件</strong></p>

<p>对搜索结果进行处理，比如只显示一个文件的一个匹配项，或者xxx</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ack <span class="nt">--line</span><span class="o">=</span>1       <span class="c"># 输出当前目录下所有文件第一行</span>
ack <span class="nt">-l</span> <span class="s1">'hello'</span>     <span class="c"># 包含查询内容的文件名</span>
ack <span class="nt">-L</span> <span class="s1">'hello'</span>     <span class="c"># 非包含查询内容的文件名</span>
</code></pre></div></div>

<p><strong>文件演示</strong></p>

<p>输出的结果是以什么方式展示呢，这个部分有几个参数可以练习下</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ack hello <span class="nt">--pager</span><span class="o">=</span><span class="s1">'less -R'</span>    <span class="c"># 以less形式展示</span>
ack hello <span class="nt">--noheading</span>      <span class="c"># 不在头上显示文件</span>
ack hello <span class="nt">--nocolor</span>        <span class="c"># 不对匹配字符着色</span>
</code></pre></div></div>

<p><strong>文件查找</strong></p>

<p>没错，它可以查找文件，以省去你要不断的结合find和grep的麻烦，虽然在linux的思想是一个工具做好一件事。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ack <span class="nt">-f</span> hello.py     <span class="c"># 查找全匹配文件</span>
ack <span class="nt">-g</span> hello.py<span class="nv">$ </span>   <span class="c"># 查找正则匹配文件</span>
ack <span class="nt">-g</span> hello  <span class="nt">--sort-files</span>     <span class="c"># 查找然后排序</span>
</code></pre></div></div>

<p><strong>文件包含/排除</strong></p>

<p>文件过滤，个人觉得这是一个很不错的功能。如果你曾经在搜索项目源码是不小心命中日志中的某个关键字的话，你会觉得这个有用。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ack <span class="nt">--python</span> hello       <span class="c"># 查找所有python文件</span>
ack <span class="nt">-G</span> hello.py<span class="nv">$ </span>hello   <span class="c"># 查找匹配正则的文件</span>
</code></pre></div></div>

<p><strong>ack支持的文件类型</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ack <span class="nt">--help-types</span>
</code></pre></div></div>

<p><strong>更多扩搜索展</strong></p>

<p>[知乎上找的]</p>

<h2 id="pigz--解压缩文件">pigz  解压缩文件</h2>

<p>可以用来解压缩文件，gzip的并行实现升级版</p>

<p><strong>补充说明</strong></p>

<p><strong>pigz命令</strong>可以用来解压缩文件，最重要的是支持多线程并行处理，解压缩比gzip快。</p>

<p><a href="http://zlib.net/pigz/">主页</a></p>

<p><strong>语法</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pigz <span class="o">[</span> <span class="nt">-cdfhikKlLmMnNqrRtz0</span>..9,11 <span class="o">]</span> <span class="o">[</span> <span class="nt">-b</span> blocksize <span class="o">]</span> <span class="o">[</span> <span class="nt">-p</span> threads <span class="o">]</span> <span class="o">[</span> <span class="nt">-S</span> suffix <span class="o">]</span> <span class="o">[</span> name ...  <span class="o">]</span>
unpigz <span class="o">[</span> <span class="nt">-cfhikKlLmMnNqrRtz</span> <span class="o">]</span> <span class="o">[</span> <span class="nt">-b</span> blocksize <span class="o">]</span> <span class="o">[</span> <span class="nt">-p</span> threads <span class="o">]</span> <span class="o">[</span> <span class="nt">-S</span> suffix <span class="o">]</span> <span class="o">[</span> name ...  <span class="o">]</span>
</code></pre></div></div>

<p><strong>参数</strong></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-0</span> to <span class="nt">-9</span>, <span class="nt">-11</span>       <span class="c"># Compression level (level 11, zopfli, is much slower)</span>
<span class="nt">--fast</span>, <span class="nt">--best</span>      <span class="c"># Compression levels 1 and 9 respectively</span>
<span class="nt">-b</span>, <span class="nt">--blocksize</span> mmm <span class="c"># Set compression block size to mmmK (default 128K)</span>
<span class="nt">-c</span>, <span class="nt">--stdout</span>        <span class="c"># Write all processed output to stdout (won't delete)</span>
<span class="nt">-d</span>, <span class="nt">--decompress</span>    <span class="c"># Decompress the compressed input</span>
<span class="nt">-f</span>, <span class="nt">--force</span>         <span class="c"># Force overwrite, compress .gz, links, and to terminal</span>
<span class="nt">-F</span>  <span class="nt">--first</span>         <span class="c"># Do iterations first, before block split for -11</span>
<span class="nt">-h</span>, <span class="nt">--help</span>          <span class="c"># Display a help screen and quit</span>
<span class="nt">-i</span>, <span class="nt">--independent</span>   <span class="c"># Compress blocks independently for damage recovery</span>
<span class="nt">-I</span>, <span class="nt">--iterations</span> n  <span class="c"># Number of iterations for -11 optimization</span>
<span class="nt">-J</span>, <span class="nt">--maxsplits</span> n   <span class="c"># Maximum number of split blocks for -11</span>
<span class="nt">-k</span>, <span class="nt">--keep</span>          <span class="c"># Do not delete original file after processing</span>
<span class="nt">-K</span>, <span class="nt">--zip</span>           <span class="c"># Compress to PKWare zip (.zip) single entry format</span>
<span class="nt">-l</span>, <span class="nt">--list</span>          <span class="c"># List the contents of the compressed input</span>
<span class="nt">-L</span>, <span class="nt">--license</span>       <span class="c"># Display the pigz license and quit</span>
<span class="nt">-m</span>, <span class="nt">--no-time</span>       <span class="c"># Do not store or restore mod time</span>
<span class="nt">-M</span>, <span class="nt">--time</span>          <span class="c"># Store or restore mod time</span>
<span class="nt">-n</span>, <span class="nt">--no-name</span>       <span class="c"># Do not store or restore file name or mod time</span>
<span class="nt">-N</span>, <span class="nt">--name</span>          <span class="c"># Store or restore file name and mod time</span>
<span class="nt">-O</span>  <span class="nt">--oneblock</span>      <span class="c"># Do not split into smaller blocks for -11</span>
<span class="nt">-p</span>, <span class="nt">--processes</span> n   <span class="c"># Allow up to n compression threads (default is the number of online processors, or 8 if unknown)</span>
<span class="nt">-q</span>, <span class="nt">--quiet</span>         <span class="c"># Print no messages, even on error</span>
<span class="nt">-r</span>, <span class="nt">--recursive</span>     <span class="c"># Process the contents of all subdirectories</span>
<span class="nt">-R</span>, <span class="nt">--rsyncable</span>     <span class="c"># Input-determined block locations for rsync</span>
<span class="nt">-S</span>, <span class="nt">--suffix</span> .sss   <span class="c"># Use suffix .sss instead of .gz (for compression)</span>
<span class="nt">-t</span>, <span class="nt">--test</span>          <span class="c"># Test the integrity of the compressed input</span>
<span class="nt">-v</span>, <span class="nt">--verbose</span>       <span class="c"># Provide more verbose output</span>
<span class="nt">-V</span>  <span class="nt">--version</span>       <span class="c"># Show the version of pigz</span>
<span class="nt">-Y</span>  <span class="nt">--synchronous</span>   <span class="c"># Force output file write to permanent storage</span>
<span class="nt">-z</span>, <span class="nt">--zlib</span>          <span class="c"># Compress to zlib (.zz) instead of gzip format</span>
<span class="nt">--</span>                  <span class="c"># All arguments after "--" are treated as files</span>
</code></pre></div></div>

<p><strong>实例</strong></p>

<p>可以结合<code class="language-plaintext highlighter-rouge">tar</code>使用, 压缩命令</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-cvf</span> - dir1 dir2 dir3 | pigz <span class="nt">-p</span> 8 <span class="o">&gt;</span> output.tgz
</code></pre></div></div>

<p>解压命令</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pigz <span class="nt">-p</span> 8 <span class="nt">-d</span> output.tgz
</code></pre></div></div>

<p>如果是gzip格式，也支持用tar解压</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-xzvf</span> output.tgz
</code></pre></div></div>

<h2 id="tgpt--命令行的人工智能">tgpt  命令行的人工智能</h2>

<p><a href="https://github.com/aandrew-me/tgpt">命令的GitHub地址</a></p>

<p>安装命令</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-sSL</span> https://raw.githubusercontent.com/aandrew-me/tgpt/main/install | bash <span class="nt">-s</span> /usr/local/bin
</code></pre></div></div>

<p>-h 查看帮助</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Usage: tgpt <span class="o">[</span>Flag] <span class="o">[</span>Prompt]

Flags:
<span class="nt">-s</span>, <span class="nt">--shell</span>                                        Generate and Execute shell commands. <span class="o">(</span>Experimental<span class="o">)</span> 
<span class="nt">-c</span>, <span class="nt">--code</span>                                         Generate Code. <span class="o">(</span>Experimental<span class="o">)</span>
<span class="nt">-q</span>, <span class="nt">--quiet</span>                                        Gives response back without loading animation
<span class="nt">-w</span>, <span class="nt">--whole</span>                                        Gives response back as a whole text
<span class="nt">-img</span>, <span class="nt">--image</span>                                      Generate images from text

Options:
<span class="nt">-f</span>, <span class="nt">--forget</span>                                       Forget Chat ID 
<span class="nt">-v</span>, <span class="nt">--version</span>                                      Print version 
<span class="nt">-h</span>, <span class="nt">--help</span>                                         Print <span class="nb">help </span>message 
<span class="nt">-i</span>, <span class="nt">--interactive</span>                                  Start normal interactive mode 
<span class="nt">-m</span>, <span class="nt">--multiline</span>                                    Start multi-line interactive mode 
<span class="nt">-cl</span>, <span class="nt">--changelog</span>                                   See changelog of versions 
<span class="nt">-u</span>, <span class="nt">--update</span>                                       Update program 

Examples:
tgpt <span class="s2">"What is internet?"</span>
tgpt <span class="nt">-f</span>
tgpt <span class="nt">-m</span>
tgpt <span class="nt">-s</span> <span class="s2">"How to update my system?"</span>
</code></pre></div></div>

<p>tgpt命令是基于3.5模型开发的，有些问题也是回答不上来的，不过有总比没有好</p>]]></content><author><name>FatGuy010</name></author><category term="Linux" /><category term="Linux" /><summary type="html"><![CDATA[mkpasswd 命令生成随机复杂密码]]></summary></entry><entry><title type="html">源码安装redis</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/10/InstallRedis" rel="alternate" type="text/html" title="源码安装redis" /><published>2023-09-10T00:00:00+00:00</published><updated>2023-09-10T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/10/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85redis</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/10/InstallRedis"><![CDATA[<h3 id="源码安装redis">源码安装redis</h3>

<p>下载redis源码包</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /tmp
wget https://download.redis.io/releases/redis-7.0.13.tar.gz
</code></pre></div></div>

<p>解压源码包</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar </span>xf redis-7.0.13.tar.gz <span class="nt">-C</span> /usr/local/
</code></pre></div></div>

<p>更名</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mv</span> /usr/local/redis-7.0.13 /usr/local/redis7
</code></pre></div></div>

<p>进入到redis目录</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /usr/local/redis7
</code></pre></div></div>

<p>安装依赖</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> gcc
</code></pre></div></div>

<p>编译</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
</code></pre></div></div>

<p>安装</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nv">PREFIX</span><span class="o">=</span>/usr/local/redis7 <span class="nb">install</span>
</code></pre></div></div>

<p>编辑配置文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'87s/bind 127.0.0.1 -::1/bind 0.0.0.0/'</span> /usr/local/redis7/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'111s/yes/no/'</span> /usr/local/redis7/redis.conf
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'309s/no/yes/'</span> /usr/local/redis7/redis.conf
</code></pre></div></div>

<p>使用systemd管理</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/systemd/system/redis.service

<span class="o">[</span>unit]
<span class="nv">Description</span><span class="o">=</span>redis-server
<span class="nv">After</span><span class="o">=</span>network.target

<span class="o">[</span>Service]
<span class="nv">Type</span><span class="o">=</span>forking
<span class="nv">ExecStart</span><span class="o">=</span>/usr/local/redis7/bin/redis-server /usr/local/redis7/redis.conf
<span class="nv">PrivateTmp</span><span class="o">=</span><span class="nb">true</span>

<span class="o">[</span>Install]
<span class="nv">WantedBy</span><span class="o">=</span>multi-user.target
</code></pre></div></div>

<p>软链接</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ln</span> <span class="nt">-s</span> /usr/local/redis7/bin/redis-cli /usr/bin/redis
</code></pre></div></div>

<p>启动redis</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>redis
</code></pre></div></div>]]></content><author><name>FatGuy010</name></author><category term="Linux" /><category term="Linux" /><category term="redis" /><summary type="html"><![CDATA[源码安装redis]]></summary></entry><entry><title type="html">ceph集群搭建与监控</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/03/CephCluster" rel="alternate" type="text/html" title="ceph集群搭建与监控" /><published>2023-09-03T00:00:00+00:00</published><updated>2023-09-03T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/03/ceph%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%9B%91%E6%8E%A7</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/2023/09/03/CephCluster"><![CDATA[<h3 id="ceph集群搭建">ceph集群搭建</h3>

<p>确保每台机子都有一个系统盘和两个空闲盘(没有格式化，类似刚安装上去的)，两个空闲盘大小都要大于5G</p>

<table>
  <thead>
    <tr>
      <th>hostname</th>
      <th>ip</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>server150</td>
      <td>192.168.25.150</td>
    </tr>
    <tr>
      <td>server151</td>
      <td>192.168.25.151</td>
    </tr>
    <tr>
      <td>server152</td>
      <td>192.168.25.152</td>
    </tr>
  </tbody>
</table>

<p>确认所有节点的时间 是 同步的，不同步使用 ntpdate自行调整</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ntpdate
ntpdate ntp.aliyun.com
</code></pre></div></div>

<p>添加A记录解析</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/hosts <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.25.150 server150
192.168.25.151 server151
192.168.25.152 server152
192.168.25.10  server10
192.168.25.11  server11
192.168.25.12  server12
192.168.25.13  server13
</span><span class="no">EOF
</span></code></pre></div></div>

<p>关闭selinux</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setenforce 0
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'/SELINUX=/cSELINUX=disabled'</span>    /etc/selinux/config
</code></pre></div></div>

<p>配置ssh免密登录</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen <span class="nt">-t</span> rsa <span class="nt">-P</span> <span class="s2">""</span>
ssh-copy-id server150
ssh-copy-id server151
ssh-copy-id server152
</code></pre></div></div>

<p>优化系统</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/security/limits.conf

<span class="c">#添加下面两行</span>
<span class="k">*</span>  soft  nofile  65535
<span class="k">*</span>  hard  nofile  65535
<span class="c">#exit 退出重登录生效</span>
</code></pre></div></div>

<p>添加ceph源</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/yum.repos.d/ceph.repo <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
[ceph]
name=ceph
baseurl=http://mirrors.aliyun.com/ceph/rpm-octopus/el7/x86_64/
gpgcheck=0
priority=1
 
[ceph-noarch]
name=cephnoarch
baseurl=http://mirrors.aliyun.com/ceph/rpm-octopus/el7/noarch/
gpgcheck=0
priority=1
 
[ceph-source]
name=Ceph source packages
baseurl=http://mirrors.aliyun.com/ceph/rpm-octopus/el7/SRPMS
gpgcheck=0
priority=1
</span><span class="no">EOF
</span>yum clean all
yum makecache fast
</code></pre></div></div>

<p>安装ceph-deploy</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ceph-deploy python2-pip
pip <span class="nb">install </span>ceph-deploy<span class="o">==</span>2.0.1 <span class="nt">-i</span> http://mirrors.aliyun.com/pypi/simple/ <span class="nt">--trusted-host</span> mirrors.aliyun.com
</code></pre></div></div>

<p>150上新建集群</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> ~/ceph-cluster
<span class="nb">cd</span> ~/ceph-cluster/
ceph-deploy new server150 server151 server152
</code></pre></div></div>

<p>安装ceph组件包(自动全节点安装)</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph-deploy <span class="nb">install</span> <span class="nt">--no-adjust-repos</span> server150 server151 server152
</code></pre></div></div>

<p>部署monitor 服务，产生相关的管理秘钥</p>

<pre><code class="language-shelll">ceph-deploy mon create-initial 
</code></pre>

<p>将生成的相关秘钥和配置文件，统一分发到所有节点的/etc/ceph 目录中</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph-deploy admin server150 server151 server152
</code></pre></div></div>

<p>创建OSD对象</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph-deploy osd create <span class="nt">--data</span> /dev/sdb server150
ceph-deploy osd create <span class="nt">--data</span> /dev/sdb server151
ceph-deploy osd create <span class="nt">--data</span> /dev/sdb server152
ceph-deploy osd create <span class="nt">--data</span> /dev/sdc server150
ceph-deploy osd create <span class="nt">--data</span> /dev/sdc server151
ceph-deploy osd create <span class="nt">--data</span> /dev/sdc server152
</code></pre></div></div>

<p>部署 MGR 服务</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph-deploy mgr create server150 server151 server152
</code></pre></div></div>

<p>使用以下命名，关闭使用不安全模式运行的提示</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph config <span class="nb">set </span>mon auth_allow_insecure_global_id_reclaim <span class="nb">false</span>
</code></pre></div></div>

<p>所有节点安装依赖并重启</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>pecan werkzeug <span class="nt">-i</span> http://mirrors.aliyun.com/pypi/simple/ <span class="nt">--trusted-host</span> mirrors.aliyun.com
systemctl restart ceph-mgr.target
</code></pre></div></div>

<p>查看集群</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph <span class="nt">-s</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">cluster:</code>
    <code class="language-plaintext highlighter-rouge">id:     629fd2fc-58cf-4c3e-94a3-0f6161cfedf3</code>
    <code class="language-plaintext highlighter-rouge">health: HEALTH_OK</code></p>

<p><code class="language-plaintext highlighter-rouge">services:</code>
    <code class="language-plaintext highlighter-rouge">mon: 3 daemons, quorum server150,server151,server152 (age 8m)</code>
    <code class="language-plaintext highlighter-rouge">mgr: server150(active, since 7s), standbys: server151, server152</code>
    <code class="language-plaintext highlighter-rouge">osd: 6 osds: 6 up (since 6m), 6 in (since 6m)</code></p>

<p><code class="language-plaintext highlighter-rouge">data:</code>
    <code class="language-plaintext highlighter-rouge">pools:   1 pools, 1 pgs</code>
    <code class="language-plaintext highlighter-rouge">objects: 0 objects, 0 B</code>
    <code class="language-plaintext highlighter-rouge">usage:   6.0 GiB used, 54 GiB / 60 GiB avail</code>
    <code class="language-plaintext highlighter-rouge">pgs:     1 active+clean</code></p>

<h3 id="启用dashboard">启用dashboard</h3>

<h4 id="失败作品">失败作品</h4>

<p>启动dashboard模块</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph mgr module <span class="nb">enable </span>dashboard <span class="nt">--force</span>
</code></pre></div></div>

<p>安装插件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ceph-mgr-dashboard
</code></pre></div></div>

<p>报错
<code class="language-plaintext highlighter-rouge">--&gt; Finished Dependency ResolutionError: Package: 2:ceph-mgr-dashboard-15.2.17-0.el7.noarch (ceph-noarch)Requires: python3-cherrypyError: Package: 2:ceph-mgr-dashboard-15.2.17-0.el7.noarch (ceph-noarch)Requires: python3-routesError: Package: 2:ceph-mgr-dashboard-15.2.17-0.el7.noarch (ceph-noarch)Requires: python3-jwt</code></p>

<p>安装依赖</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>cherrypy routes jwt <span class="nt">-i</span> https://mirrors.aliyun.com/pypi/simple/
</code></pre></div></div>

<p>出现报错
    <code class="language-plaintext highlighter-rouge">Traceback (most recent call last):</code>
      <code class="language-plaintext highlighter-rouge">File "&lt;string&gt;", line 1, in &lt;module&gt;</code>
      <code class="language-plaintext highlighter-rouge">File "/tmp/pip-build-1lkzd3u1/cryptography/setup.py", line 18, in &lt;module&gt;</code>
        <code class="language-plaintext highlighter-rouge">from setuptools_rust import RustExtension</code>
    <code class="language-plaintext highlighter-rouge">ModuleNotFoundError: No module named 'setuptools_rust'</code></p>

<p>安装setuptools_rust</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>setuptools_rust cherrypy routes jwt
</code></pre></div></div>

<p>依旧报错
尝试曲线救国拯救</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install</span> <span class="nt">-U</span> pip setuptools <span class="nt">-i</span> https://mirrors.aliyun.com/pypi/simple/
</code></pre></div></div>

<p>再次尝试安装</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 <span class="nb">install </span>cherrypy routes jwt <span class="nt">-i</span> https://mirrors.aliyun.com/pypi/simple/
</code></pre></div></div>

<p>没报错了</p>

<p>安装插件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ceph-mgr-dashboard
</code></pre></div></div>

<p>依旧报原来的错误</p>

<p>看了半天貌似没有有关于dashboard的命令</p>

<p>破案了ceph15的O版搞不来dashborad
要旧版本的ceph
参考 博客
https://www.cnblogs.com/LiuChang-blog/p/15615598.html</p>

<p>安装报错原因分析
这是由于从O版本开始，MGR改为Python3编写，而默认库没有这3个模块包，即使单独找包安装也可能不生效或者安装不上。从社区得知，这是已知问题，建议使用CentOS8系统或者使用cephadm容器化部署Ceph，或者降低Ceph版本也可以，例如H版本，这个版本还是Python2编写的，不存在缺包问题。</p>

<h4 id="成功作品">成功作品</h4>

<p>这里我使用快照进行还原了</p>

<p>然后快速进行ceph集群搭建</p>

<p>和之前的搭建ceph集群一样</p>

<p>先把系统优化好</p>

<h5 id="环境配置">环境配置</h5>

<p>确认所有节点的时间 是 同步的，不同步使用 ntpdate自行调整</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ntpdate
ntpdate ntp.aliyun.com
</code></pre></div></div>

<p>添加A记录解析</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/hosts <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.25.150 server150
192.168.25.151 server151
192.168.25.152 server152
192.168.25.10  server10
192.168.25.11  server11
192.168.25.12  server12
192.168.25.13  server13
</span><span class="no">EOF
</span></code></pre></div></div>

<p>关闭selinux</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setenforce 0
<span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'/SELINUX=/cSELINUX=disabled'</span>    /etc/selinux/config
</code></pre></div></div>

<p>配置ssh免密登录</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh-keygen <span class="nt">-t</span> rsa <span class="nt">-P</span> <span class="s2">""</span>
ssh-copy-id server150
ssh-copy-id server151
ssh-copy-id server152
</code></pre></div></div>

<p>优化系统</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/security/limits.conf

<span class="c">#添加下面两行</span>
<span class="k">*</span>  soft  nofile  65535
<span class="k">*</span>  hard  nofile  65535
<span class="c">#exit 退出重登录生效</span>
</code></pre></div></div>

<p>要注意的是，这里我添加N版的ceph源</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/yum.repos.d/ceph.repo <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
[ceph]
name=ceph
baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/x86_64/
gpgcheck=0
priority=1

[ceph-noarch]
name=cephnoarch
baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/noarch/
gpgcheck=0
priority=1

[ceph-source]
name=Ceph source packages
baseurl=http://mirrors.aliyun.com/ceph/rpm-nautilus/el7/SRPMS
gpgcheck=0
priority=1
</span><span class="no">EOF
</span>yum clean all
yum makecache fast
</code></pre></div></div>

<p>安装ceph-deploy</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ceph-deploy python2-pip
</code></pre></div></div>

<h5 id="搭建集群">搭建集群</h5>

<p>server150上新建集群</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> /root/ceph-cluster
<span class="nb">cd</span> /root/ceph-cluster/
ceph-deploy new server150 server151 server152
</code></pre></div></div>

<p>安装ceph组件包(自动全节点安装)</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph-deploy <span class="nb">install</span> <span class="nt">--no-adjust-repos</span> server150 server151 server152
</code></pre></div></div>

<p>部署monitor 服务，产生相关的管理秘钥</p>

<pre><code class="language-shelll">ceph-deploy mon create-initial 
</code></pre>

<p>将生成的相关秘钥和配置文件，统一分发到所有节点的/etc/ceph 目录中</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph-deploy admin server150 server151 server152
</code></pre></div></div>

<p>创建OSD对象</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph-deploy osd create <span class="nt">--data</span> /dev/sdb server150
ceph-deploy osd create <span class="nt">--data</span> /dev/sdb server151
ceph-deploy osd create <span class="nt">--data</span> /dev/sdb server152
ceph-deploy osd create <span class="nt">--data</span> /dev/sdc server150
ceph-deploy osd create <span class="nt">--data</span> /dev/sdc server151
ceph-deploy osd create <span class="nt">--data</span> /dev/sdc server152
</code></pre></div></div>

<p>部署 MGR 服务</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph-deploy mgr create server150 server151 server152
</code></pre></div></div>

<p>使用以下命名，关闭使用不安全模式运行的提示</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph config <span class="nb">set </span>mon auth_allow_insecure_global_id_reclaim <span class="nb">false</span>
</code></pre></div></div>

<p>重启使配置生效</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl restart ceph-mgr.target
</code></pre></div></div>

<p>查看集群</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph <span class="nt">-s</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">cluster:</code>
    <code class="language-plaintext highlighter-rouge">id:     c2ff5c23-ed9c-4a7b-a70f-611dcd218c04</code>
    <code class="language-plaintext highlighter-rouge">health: HEALTH_OK</code></p>

<p><code class="language-plaintext highlighter-rouge">services:</code>
    <code class="language-plaintext highlighter-rouge">mon: 3 daemons, quorum server150,server151,server152 (age 5h)</code>
    <code class="language-plaintext highlighter-rouge">mgr: server150(active, since 2d), standbys: server151, server152</code>
    <code class="language-plaintext highlighter-rouge">osd: 6 osds: 4 up (since 5h), 4 in (since 21h)</code></p>

<p><code class="language-plaintext highlighter-rouge">data:</code>
    <code class="language-plaintext highlighter-rouge">pools:   0 pools, 0 pgs</code>
    <code class="language-plaintext highlighter-rouge">objects: 0 objects, 0 B</code>
    <code class="language-plaintext highlighter-rouge">usage:   4.0 GiB used, 36 GiB / 40 GiB avail</code>
    <code class="language-plaintext highlighter-rouge">pgs:</code></p>

<h5 id="部署dashboard">部署Dashboard</h5>

<p>每个结点都要安装</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> ceph-mgr-dashboard
</code></pre></div></div>

<p>开启dashboard模块</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph mgr module <span class="nb">enable </span>dashboard
</code></pre></div></div>

<p>修改默认配置</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 监听地址</span>
ceph config <span class="nb">set </span>mgr mgr/dashboard/server_addr 0.0.0.0
<span class="c"># 使用的端口</span>
ceph config <span class="nb">set </span>mgr mgr/dashboard/server_port 7000
<span class="c"># 不使用https</span>
ceph config <span class="nb">set </span>mgr mgr/dashboard/ssl <span class="nb">false</span>
</code></pre></div></div>

<p>重启使配置生效</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph mgr module disable dashboard
ceph mgr module <span class="nb">enable </span>dashboard
</code></pre></div></div>

<p>创建一个dashboard登录用户名密码</p>

<p>账号：admin</p>

<p>密码：123456</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"123456"</span> <span class="o">&gt;</span> password.txt
ceph dashboard ac-user-create admin administrator <span class="nt">-i</span> password.txt
</code></pre></div></div>

<p>顺便启用Prometheus监控</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph mgr module <span class="nb">enable </span>prometheus
</code></pre></div></div>

<p>查看服务方式</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ceph mgr services
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">{</code>
    <code class="language-plaintext highlighter-rouge">"dashboard": "http://server150:7000/",</code>
    <code class="language-plaintext highlighter-rouge">"prometheus": "http://server150:9283/"</code>
<code class="language-plaintext highlighter-rouge">}</code></p>

<p>测试promtheus指标接口</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl 192.168.25.150:9283/metrics
</code></pre></div></div>

<p>配置Prometheus采集</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim prometheus.yml

scrape_configs:
  - job_name: <span class="s1">'ceph'</span>
     static_configs:
     - targets: <span class="o">[</span><span class="s1">'192.168.25.150:9283'</span><span class="o">]</span>
</code></pre></div></div>

<p>浏览器访问Dashboard</p>

<p><img src="https://picst.sunbangyan.cn/2023/11/25/904c682e0835266461be945d48d0b36a.jpeg" alt="" /></p>

<p>浏览器访问Prometheus</p>

<p><img src="https://picdm.sunbangyan.cn/2023/11/25/bd06ff73bb9ec9103056d0581b04a7ef.jpeg" alt="" /></p>

<p><img src="https://picss.sunbangyan.cn/2023/11/25/03ac91a555e36a774995aec526e9ff93.jpeg" alt="" /></p>

<p>通过grafana模板查看</p>

<p>Dashboards -&gt; Manage -&gt; Import -&gt; 输入仪表盘ID -&gt; Load</p>

<p>Ceph-Cluster ID: 2842</p>

<p>Ceph-OSD ID:   5336</p>

<p>Ceph-Pool ID:  5342</p>

<p>Ceph-Cluster：</p>

<p><img src="https://picss.sunbangyan.cn/2023/11/25/0ce345fbfdbbc40bc720c86e7f23af4d.jpeg" alt="" /></p>

<p>Ceph-OSD：</p>

<p><img src="https://picst.sunbangyan.cn/2023/11/25/580164fde2eb7eac9f394fdd42831a42.jpeg" alt="" /></p>

<p>Ceph-Pool：</p>

<p><img src="https://picss.sunbangyan.cn/2023/11/25/27f6a542dc1a317bf601df5164dae079.jpeg" alt="" /></p>]]></content><author><name>FatGuy010</name></author><category term="Linux" /><category term="ceph" /><summary type="html"><![CDATA[ceph集群搭建]]></summary></entry><entry><title type="html">Docker搭建MySQL主从</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/2023/07/1/DockerBuildsMySQLMaster&Slave" rel="alternate" type="text/html" title="Docker搭建MySQL主从" /><published>2023-07-01T00:00:00+00:00</published><updated>2023-07-01T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/2023/07/1/Docker%E6%90%AD%E5%BB%BAMySQL%E4%B8%BB%E4%BB%8E</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/2023/07/1/DockerBuildsMySQLMaster&amp;Slave"><![CDATA[<h1 id="docker搭建mysql主从一主两从">Docker搭建MySQL主从(一主两从)</h1>

<h3 id="宿主机配置">宿主机配置</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> /mysql/master/data <span class="nt">-p</span>
<span class="nb">mkdir</span> /mysql/master/conf <span class="nt">-p</span>
<span class="nb">mkdir</span> /mysql/slave1/conf <span class="nt">-p</span>
<span class="nb">mkdir</span> /mysql/slave1/data <span class="nt">-p</span>
<span class="nb">mkdir</span> /mysql/slave2/data <span class="nt">-p</span>
<span class="nb">mkdir</span> /mysql/slave2/conf <span class="nt">-p</span>
</code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@server153 ~]# tree /mysql/
/mysql/
├── master
│   ├── conf
│   └── data
├── slave1
│   ├── conf
│   └── data
└── slave2
    ├── conf
    └── data

</code></pre></div></div>

<h4 id="master配置文件">master配置文件</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /mysql/master/conf/my.cnf

<span class="o">[</span>mysqld]
server_id <span class="o">=</span> 1
log-bin<span class="o">=</span> mysql-bin
read-only<span class="o">=</span>0
replicate-ignore-db<span class="o">=</span>mysql
replicate-ignore-db<span class="o">=</span>sys
replicate-ignore-db<span class="o">=</span>information_schema
replicate-ignore-db<span class="o">=</span>performance_schema
<span class="o">!</span>includedir /etc/mysql/conf.d/
<span class="o">!</span>includedir /etc/mysql/mysql.conf.d/
</code></pre></div></div>

<h4 id="salve1配置文件">salve1配置文件</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /mysql/slave1/conf/my.cnf

<span class="o">[</span>mysqld]
server_id <span class="o">=</span> 2
log-bin<span class="o">=</span> mysql-bin
read-only<span class="o">=</span>1
replicate-ignore-db<span class="o">=</span>mysql
replicate-ignore-db<span class="o">=</span>sys
replicate-ignore-db<span class="o">=</span>information_schema
replicate-ignore-db<span class="o">=</span>performance_schema
<span class="o">!</span>includedir /etc/mysql/conf.d/
<span class="o">!</span>includedir /etc/mysql/mysql.conf.d/
</code></pre></div></div>

<h4 id="slave2配置文件">slave2配置文件</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /mysql/slave2/conf/my.cnf

<span class="o">[</span>mysqld]
server_id <span class="o">=</span> 3
log-bin<span class="o">=</span> mysql-bin
read-only<span class="o">=</span>1
replicate-ignore-db<span class="o">=</span>mysql
replicate-ignore-db<span class="o">=</span>sys
replicate-ignore-db<span class="o">=</span>information_schema
replicate-ignore-db<span class="o">=</span>performance_schema
<span class="o">!</span>includedir /etc/mysql/conf.d/
<span class="o">!</span>includedir /etc/mysql/mysql.conf.d/
</code></pre></div></div>

<h3 id="启动docker容器">启动docker容器</h3>

<h4 id="创建docker桥接网络">创建Docker桥接网络</h4>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create <span class="nt">-d</span> bridge mysql
</code></pre></div></div>

<h4 id="启动mysql容器master">启动MySQL容器master</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> mysql-master <span class="nt">--network</span> mysql <span class="nt">-d</span> <span class="nt">-e</span> <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>123456 <span class="nt">-v</span> /mysql/master/data:/var/lib/mysql <span class="nt">-v</span> /mysql/master/conf/my.cnf:/etc/mysql/my.cnf mysql:5.7
</code></pre></div></div>

<h4 id="启动mysql容器slave1">启动MySQL容器slave1</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> mysql-slave1 <span class="nt">--network</span> mysql <span class="nt">-d</span> <span class="nt">-e</span> <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>123456 <span class="nt">-v</span> /mysql/slave1/data:/var/lib/mysql <span class="nt">-v</span> /mysql/slave1/conf/my.cnf:/etc/mysql/my.cnf mysql:5.7
</code></pre></div></div>

<h4 id="启动mysql容器slave2">启动MySQL容器slave2</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--name</span> mysql-slave2 <span class="nt">--network</span> mysql <span class="nt">-d</span> <span class="nt">-e</span> <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>123456 <span class="nt">-v</span> /mysql/slave2/data:/var/lib/mysql <span class="nt">-v</span> /mysql/slave2/conf/my.cnf:/etc/mysql/my.cnf mysql:5.7
</code></pre></div></div>

<h3 id="mysql-master">MySQL-master</h3>

<p>进入master容器</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> mysql-master /bin/bash
</code></pre></div></div>

<p>登录master数据库</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql <span class="nt">-uroot</span> <span class="nt">-p123456</span>
</code></pre></div></div>

<p>授权账号</p>

<pre><code class="language-mysql">GRANT REPLICATION SLAVE ON *.* to 'slave'@'%' identified by '123456';
</code></pre>

<p>刷新权限</p>

<pre><code class="language-mysql">flush privileges;
</code></pre>

<p>查看master信息</p>

<pre><code class="language-mysql">mysql&gt; show master status;
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog\_Do\_DB | Binlog\_Ignore\_DB | Executed\_Gtid\_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000003 |      590 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
</code></pre>

<h3 id="mysql-slave1">MySQL-slave1</h3>

<p>进入slave1容器</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> mysql-slave1 /bin/bash
</code></pre></div></div>

<p>登录slave1数据库</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql <span class="nt">-uroot</span> <span class="nt">-p123456</span>
</code></pre></div></div>

<p>主从设置</p>

<pre><code class="language-mysql">change master to master_host='mysql-master',master_user='slave',master_password='123456',master_log_file='mysql-bin.000003',master_log_pos=590,master_port=3306;
</code></pre>

<pre><code class="language-mysql">start slave;
</code></pre>

<p>查看MySQL主从配置是否成功</p>

<pre><code class="language-mysql">show slave status\G
</code></pre>

<h3 id="mysql-slave2">MySQL-slave2</h3>

<p>进入slave2容器</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> mysql-slave2 /bin/bash
</code></pre></div></div>

<p>登录slave1数据库</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysql <span class="nt">-uroot</span> <span class="nt">-p123456</span>
</code></pre></div></div>

<p>主从设置</p>

<pre><code class="language-mysql">change master to master_host='mysql-master',master_user='slave',master_password='123456',master_log_file='mysql-bin.000003',master_log_pos=590,master_port=3306;
</code></pre>

<pre><code class="language-mysql">start slave;
</code></pre>

<p>查看MySQL主从配置是否成功</p>

<pre><code class="language-mysql">show slave status\G
</code></pre>

<p>最后在主库上创库创表，用以验证主从是否搭建成功</p>

<h3 id="快速建库建表">快速建库建表</h3>

<pre><code class="language-MySQL">CREATE DATABASE TESTDB;
show databases;
use TESTDB;
CREATE TABLE TABLE1 (bTypeId int,bName char(16),price int,publishing char(16));
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('1','Linux','66','DZ');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('2','CLD','68','RM');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('3','SYS','90','JX');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('4','MySQL1','71','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('5','MySQL2','72','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('6','MySQL3','73','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('7','MySQL4','74','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('8','MySQL5','75','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('9','MySQL6','76','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('10','MySQL7','77','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('11','MySQL8','78','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('12','MySQL9','79','QH');

CREATE TABLE TABLE2 (name char(16),price int,pages int);
INSERT INTO TABLE2(name,price,pages) VALUES('Linux','30','666');
INSERT INTO TABLE2(name,price,pages) VALUES('CLD','60','666');
INSERT INTO TABLE2(name,price,pages) VALUES('SYS','80','666');
INSERT INTO TABLE2(name,price,pages) VALUES('MySQL1','166','666');

show tables;
select * from TABLE1;
select * from TABLE2;
</code></pre>

<p>查看表</p>

<pre><code class="language-mysql">show databases;
use TESTDB;
show tables;
select * from TABLE1;
select * from TABLE2;
</code></pre>]]></content><author><name>FatGuy010</name></author><category term="Linux" /><category term="Docker" /><summary type="html"><![CDATA[Docker搭建MySQL主从(一主两从)]]></summary></entry><entry><title type="html">CICD</title><link href="https://fattt.org.edu.kg//jekyll-theme-yat/2023/05/15/CICD" rel="alternate" type="text/html" title="CICD" /><published>2023-05-15T00:00:00+00:00</published><updated>2023-05-15T00:00:00+00:00</updated><id>https://fattt.org.edu.kg//jekyll-theme-yat/2023/05/15/Gitlab+Jenkins%E8%BF%9B%E8%A1%8CCICD</id><content type="html" xml:base="https://fattt.org.edu.kg//jekyll-theme-yat/2023/05/15/CICD"><![CDATA[<h3 id="gitlab安装部署">gitlab安装部署</h3>

<p>配置依赖环境</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nb">install</span> <span class="nt">-y</span> curl policycoreutils-python openssh-server openssh-clirnts postfixcronie lokkit rpm git
</code></pre></div></div>

<p>安装gitlab</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rpm <span class="nt">-ivh</span> /tmp/gitlab-ce-16.0.0-ce.0.el7.x86_64.rpm
</code></pre></div></div>

<p>修改配置文件</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/gitlab/gitlab.rb 

external_url <span class="s1">'http://192.168.25.130'</span>
user[<span class="s1">'username'</span><span class="o">]</span> <span class="o">=</span> <span class="s2">"git"</span>
user[<span class="s1">'group'</span><span class="o">]</span> <span class="o">=</span> <span class="s2">"git"</span>
</code></pre></div></div>

<p>修改配置文件后</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gitlab-ctl reconfigure
</code></pre></div></div>

<p>成功后</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Notes:
Default admin account has been configured with following details:
Username: root
Password: You didn<span class="s1">'t opt-in to print initial root password to STDOUT.
Password stored to /etc/gitlab/initial_root_password. This file will be cleaned up in first reconfigure run after 24 hours.

NOTE: Because these credentials might be present in your log files in plain text, it is highly recommended to reset the password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password.

gitlab Reconfigured!
</span></code></pre></div></div>

<p>查看初始密码</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /etc/gitlab/initial_root_password

<span class="c"># WARNING: This value is valid only in the following conditions</span>
<span class="c">#          1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environment variable or via `gitlab_rails['initial_root_password']` setting in `gitlab.rb`, it was provided before database was seeded for the first time (usually, the first reconfigure run).</span>
<span class="c">#          2. Password hasn't been changed manually, either via UI or via command line.</span>
<span class="c">#</span>
<span class="c">#          If the password shown here doesn't work, you must reset the admin password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password.</span>

Password: 3+ZV2iUGZGUhtVXNvt40wD3z6Fwur/RSgBKGxZ/w6vk<span class="o">=</span>

<span class="c"># NOTE: This file will be automatically deleted in the first reconfigure run after 24 hours.</span>

</code></pre></div></div>

<p>访问  http://192.168.25.130</p>

<p>第一次登录使用初始密码进行登录，账号为 root</p>

<p>进去后，修改密码，设置语言</p>

<p>创建用户—&gt;创建群组—&gt;创建项目</p>

<p><img src="https://picss.sunbangyan.cn/2023/11/27/9ef430ff9c39fd23452ea9b63c0c7c82.jpeg" alt="" /></p>

<p><img src="https://picst.sunbangyan.cn/2023/11/27/5b0e9d6372a7945507f143daaf16bffc.jpeg" alt="" /></p>

<p><img src="https://picdl.sunbangyan.cn/2023/11/27/099c9875446ffd1a0d653771c991b7cb.jpeg" alt="" /></p>

<p>修改ssh不进行指纹验证</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/ssh/ssh_config
<span class="c"># 约35行改成 </span>
StrictHostKeyChecking no
</code></pre></div></div>

<p>允许webhook</p>

<p><img src="https://picdl.sunbangyan.cn/2023/11/27/b2ca3a9fefd07286de0bc8195225e1c1.jpeg" alt="" /></p>

<h3 id="jenkins安装部署">jenkins安装部署</h3>

<h4 id="jdk17">jdk17</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /tmp
wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.rpm
rpm <span class="nt">-ivh</span> jdk-17_linux-x64_bin.rpm
<span class="c"># java路径</span>
<span class="c"># /usr/lib/jvm/jdk-17-oracle-x64/bin/java</span>
</code></pre></div></div>

<p>环境变量</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/profile.d/jdk.sh <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
#! /bin/bash
JAVA_HOME=/usr/java/jdk-17
JRE_HOME=</span><span class="nv">$JAVA_HOME</span><span class="sh">/jre
PATH=</span><span class="nv">$PATH</span><span class="sh">:</span><span class="nv">$JAVA_HOME</span><span class="sh">/bin:</span><span class="nv">$JRE_HOME</span><span class="sh">/bin
CLASSPATH=</span><span class="nv">$JAVA_HOME</span><span class="sh">/lib/dt.jar:</span><span class="nv">$JAVA_HOME</span><span class="sh">/lib/tools.jar:</span><span class="nv">$JRE_HOME</span><span class="sh">/lib
export JAVA_HOME JRE_HOME CLASSPATH
</span><span class="no">EOF
</span><span class="nb">source</span> /etc/profile
</code></pre></div></div>

<h4 id="安装maven">安装maven</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#上传并解压maven源码包</span>
<span class="nb">tar</span> <span class="nt">-xf</span> /tmp/apache-maven-3.9.4-bin.tar.gz <span class="nt">-C</span> /usr/local
<span class="c">#更名便于操作</span>
<span class="nb">mv</span> /usr/local/apache-maven-3.9.4 /usr/local/maven
</code></pre></div></div>

<p>配置环境变量</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> /etc/profile.d/maven.sh <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
#! /bin/bash
export MAVEN_HOME=/usr/local/maven
export PATH=</span><span class="nv">$MAVEN_HOME</span><span class="sh">/bin:</span><span class="nv">$PATH</span><span class="sh">
</span><span class="no">EOF
</span></code></pre></div></div>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> /etc/profile
</code></pre></div></div>

<p>查看maven版本</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvn <span class="nt">-v</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Apache Maven 3.9.4 (dfbb324ad4a7c8fb0bf182e6d91b0ae20e3d2dd9)</code>
<code class="language-plaintext highlighter-rouge">Maven home: /usr/local/maven</code>
<code class="language-plaintext highlighter-rouge">Java version: 17.0.9, vendor: Oracle Corporation, runtime: /usr/lib/jvm/jdk-17-oracle-x64</code>
<code class="language-plaintext highlighter-rouge">Default locale: en_US, platform encoding: UTF-8</code>
<code class="language-plaintext highlighter-rouge">OS name: "linux", version: "3.10.0-1160.71.1.el7.x86_64", arch: "amd64", family: "unix"</code></p>

<p>配置maven加速器</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#修改镜像</span>
vim /usr/local/maven/conf/settings.xml 
<span class="c">#源镜像在文件约160行</span>
<span class="c">#注释掉或删掉原来的镜像并改成下面阿里的镜像</span>
&lt;mirror&gt;
    &lt;<span class="nb">id</span><span class="o">&gt;</span>aliyunmaven&lt;/id&gt;
    &lt;mirrorOf&gt;<span class="k">*</span>&lt;/mirrorOf&gt;
    &lt;name&gt;阿里云公共仓库&lt;/name&gt;
    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
&lt;/mirror&gt;
</code></pre></div></div>

<p>官网：https://pkg.jenkins.io/redhat-stable/</p>

<h4 id="安装jenkins">安装jenkins</h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget <span class="nt">-O</span> /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
rpm <span class="nt">--import</span> https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
yum <span class="nb">install</span> <span class="nt">-y</span> fontconfig java-17-openjdk jenkins git
systemctl <span class="nb">enable</span> <span class="nt">--now</span> jenkins.service
</code></pre></div></div>

<p>查看初始密码</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> /var/lib/jenkins/secrets/initialAdminPassword
</code></pre></div></div>

<p>系统配置</p>

<p><img src="https://picst.sunbangyan.cn/2023/11/27/ad8d8057cf336dc32e2efae090b28bec.jpeg" alt="" /></p>

<p>全局配置</p>

<p><img src="https://picss.sunbangyan.cn/2023/11/27/d31f0fe44a3c4d7e7d7d72982ab7939e.jpeg" alt="" /></p>

<p>安装插件</p>

<p><img src="https://picss.sunbangyan.cn/2023/11/27/f721522006daa4bf5fe99195e126e180.jpeg" alt="" /></p>

<p>获取jenkins的ssh密钥</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>usermod <span class="nt">-s</span> /bin/bash jenkins
su - jenkins
<span class="nb">cat</span> .ssh/id_rsa.pub
usermod <span class="nt">-s</span> /bin/false jenkins
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC5G5XbbJ1QiU7qKBudyLgLKaCYJ2Y7/+o/WrjO++qUdbGbjz1cDizqXywVbt6Jm1QEES87K9isGhjSVffp36zfHOpa1RNdvgxc8QNjwVQ9M0IpTryn1UJMdOcFLpS62vpbC2jzZVc+KKdZ9Fya//HccIymB10YBQQX1yWYeYSz6+K/olDLa+qUqom1Ycs00xBShXTvzh84fdUbMh2Rr5sYhbu4sg1tqQOZsK4k+72FfkVy9qPF1HVaicxKeJ0dVR9juqOq1Tdgq0ae+CkpR//sUvPJd7RLZXo58BzYJQG8bbz0xvBjHa8IUjnmFY77ofrN82+iGkt8vDBu2jeMHIg9 jenkins@jenkins131</code></p>

<p>获取的ssh密钥可以丢到gitlab</p>

<p>进去后在最下面的 jenkins中文社区修改镜像</p>

<p>升级站点的url填进 清华镜像</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json
</code></pre></div></div>

<p>修改一下ssh配置</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/ssh/ssh_config
<span class="c"># 约35行改成</span>
StrictHostKeyChecking no
</code></pre></div></div>

<p>配置jenkins权限</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>visudo
<span class="c"># 约100行添加下面内容</span>

jenkins <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span>       NOPASSWD: ALL
</code></pre></div></div>

<h3 id="创建pipline流水线">创建pipline流水线</h3>

<p><img src="https://picst.sunbangyan.cn/2023/11/27/1a39394267c13164c78d627f5b08afca.jpeg" alt="" /></p>

<p>配置job</p>

<p><img src="https://picst.sunbangyan.cn/2023/11/27/7e9415f7d7b4fdd6eacd924801a97c19.jpeg" alt="" /></p>

<p>gitlab配置webhook</p>

<p><img src="https://picdl.sunbangyan.cn/2023/11/27/133936b1bf02f6225049532c6685b16b.jpeg" alt="" /></p>

<p>pipeline流水线脚本</p>

<pre><code class="language-pipeline">pipeline {
    agent any

    stages {
        stage('git') {
            steps {
                sleep 1
                git changelog: false, poll: false, url: 'git@192.168.25.130:myweb/myweb.git'
            }
        }
        stage('test') {
            steps {
                sh  'mvn clean package -DskipTests'
            }
        }
        stage('deploy') {
            steps {
                sh  'sudo sshpass  -p 123456 ssh  root@192.168.25.153 rm -rf /tmp/tomcatdata/*'
                sh  'sudo sshpass  -p 123456 scp  -r  /var/lib/jenkins/workspace/myweb/target/myweb-0.0.1-SNAPSHOT.war   192.168.25.153:/tmp/tomcatdata/ROOT.war'
            }
        }
    }
}
</code></pre>

<p>触发Gitlab推送事件，Jenkins流水线也会被触发</p>

<p><img src="https://picdm.sunbangyan.cn/2023/11/27/96741eef8f44b7c322c71f33aefd4a57.jpeg" alt="" /></p>]]></content><author><name>FatGuy010</name></author><category term="Linux" /><category term="Linux" /><summary type="html"><![CDATA[gitlab安装部署]]></summary></entry></feed>