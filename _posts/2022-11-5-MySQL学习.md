---
layout: post
title: MySQL基础
subtitle: 学习MySQL
author: FatGuy010
permalink: /MySQL
tags: [ MySQL]
---



## MySQL

### MySQL5.7破解密码

~~~
新安装MySQL5.7
yum install -y mysql mysql-server
systemctl start mysqld
cat /var/log/mysqld.log | grep password
复制最后面的复杂密码
mysql -uroot -p'复杂密码'
alter user 'root'@'localhost' identified by '自己的复杂密码';
flush privileges;
exit
mysql -uroot -p'自己的复杂密码'
~~~

~~~
忘记MySQL5.7密码
echo skip-grant-tables >> /etc/my.cnf
systemctl restart mysqld
msyql
flush privileges;
alter user 'root'@'localhost' identified by '自己的复杂密码';
flush privileges;
exit
mysql -uroot -p'自己的复杂密码'
exit
去除 /etc/my.cnf 里的 skip-grant-tables
systemctl restart mysqld
mysql -uroot -p'自己的复杂密码'
~~~

### MySQL配置文件

~~~
cat /etc/my.cnf
[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
symbolic-links=0
character-set-server=utf8
collation-server=utf8_general_ci

log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
skip-name-resolve
~~~

### MySQL基础

#### MySQL快速创建测试数据

~~~
CREATE DATABASE `testbookdb` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
show databases;
use testbookdb;
CREATE TABLE book1 (bTypeId int,bName char(16),price int,publishing char(16));
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('1','《Linux从入门到精通》','66','电子工业出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('2','《云计算趋势》','68','人民邮电出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('3','《操作系统设计与实现》','90','机械工业出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('4','《高性能MySQL》','71','清华大学出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('5','《高性能MySQL2》','72','清华大学出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('6','《高性能MySQL3》','73','清华大学出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('7','《高性能MySQL4》','74','清华大学出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('8','《高性能MySQL5》','75','清华大学出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('9','《高性能MySQL6》','76','清华大学出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('10','《高性能MySQL7》','77','清华大学出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('11','《高性能MySQL8》','78','清华大学出版社');
INSERT INTO book1(bTypeId,bName,price,publishing) VALUES('12','《高性能MySQL9》','79','清华大学出版社');
 
CREATE TABLE book2(bTypeId int,bName char(16),price int,pages int);
INSERT INTO book2(bTypeId,bName,price,pages) VALUES('1','《Linux从入门到精通》','30','666');
INSERT INTO book2(bTypeId,bName,price,pages) VALUES('2','《云计算趋势》','60','666');
INSERT INTO book2(bTypeId,bName,price,pages) VALUES('3','《操作系统设计与实现》','80','666');
INSERT INTO book2(bTypeId,bName,price,pages) VALUES('4','《高性能MySQL》','166','666');
 
show tables;
select * from book1;
select * from book2;
~~~

~~~
CREATE DATABASE TESTDB;
show databases;
use TESTDB;
CREATE TABLE TABLE1 (bTypeId int,bName char(16),price int,publishing char(16));
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('1','Linux','66','DZ');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('2','CLD','68','RM');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('3','SYS','90','JX');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('4','MySQL1','71','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('5','MySQL2','72','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('6','MySQL3','73','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('7','MySQL4','74','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('8','MySQL5','75','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('9','MySQL6','76','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('10','MySQL7','77','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('11','MySQL8','78','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('12','MySQL9','79','QH');

CREATE TABLE TABLE2 (name char(16),price int,pages int);
INSERT INTO TABLE2(name,price,pages) VALUES('Linux','30','666');
INSERT INTO TABLE2(name,price,pages) VALUES('CLD','60','666');
INSERT INTO TABLE2(name,price,pages) VALUES('SYS','80','666');
INSERT INTO TABLE2(name,price,pages) VALUES('MySQL1','166','666');

show tables;
select * from TABLE1;
select * from TABLE2;
~~~

#### MySQL基础语句

创建数据库

```
CREATE DATABASE IF NOT EXISTS RUNOOB DEFAULT CHARSET utf8 COLLATE utf8_general_ci;
```

删除数据库

```
drop database RUNOOB;
```

创建数据表

```
CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   `runoob_id` INT UNSIGNED AUTO_INCREMENT,
   `runoob_title` VARCHAR(100) NOT NULL,
   `runoob_author` VARCHAR(40) NOT NULL,
   `submission_date` DATE,
   PRIMARY KEY ( `runoob_id` )
)ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

删除数据表

```
DROP TABLE runoob_tbl;
```

插入数据

```
INSERT INTO runoob_tbl (runoob_title, runoob_author, submission_date) VALUES ("学习 PHP", "菜鸟教程", NOW());
或者插入多条
INSERT INTO table_name  (field1, field2,...fieldN)  VALUES  (valueA1,valueA2,...valueAN),(valueB1,valueB2,...valueBN),(valueC1,valueC2,...valueCN)......;
```

update更新

```
UPDATE runoob_tbl SET runoob_title='学习 C++' WHERE runoob_id=3;
UPDATE runoob_tbl SET title='学习 C++';  修改表里所有的title值
```

delete语句

```
DELETE FROM runoob_tbl WHERE runoob_id=3;
DELETE FROM runoob_tbl;   删除表里的所有数据
```

like语句

```
SELECT * from runoob_tbl  WHERE runoob_author LIKE '%COM';
```

union语句

```
UNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）
	SELECT 列名称 FROM 表名称 UNION SELECT 列名称 FROM 表名称 ORDER BY 列名称;
UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）
	SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称;
```

order by

```
SELECT * from runoob_tbl ORDER BY submission_date ASC;  升序
SELECT * from runoob_tbl ORDER BY submission_date DESC;  降序
```

添加字段：

```
alter table 表名 add 字段名 列类型 [not null|null][primary key][unique][auto_increment][default value]
alter table 表名 add 字段定义 after ar_id;
```

删除字段：

```
alter table 表名 drop 字段名
```

修改字段：

```
alter table 表名 modify 字段名 字段新类型
```

完整修改字段：

```
alter table 表名  change 旧字段名称 新字段定义
```

修改表名称

```
alter table 表名 rename 新名字
```

删除表

```
drop table [if (not) exists] 表名;
```

表中行的操作

insert

```
insert [into] 数据表名称 [(字段列表)] values|value (表达式|null|default,...),(表达式|null|default,...)
insert [into] 数据表名称 set 字段名称=值,...
insert与insert...set的区别是后者可以带有子查询。
```

update -- 单表

```
update 表名 set 字段名称=值,... [where 条件]
如果省略WHERE条件将更新全部记录。
```

删除记录 -- 单表

```
delete from 数据表名称 [where 条件]
如果省略where条件，将删除全部记录
```

select

```
select 字段列表 from 数据表 [[as] 别名] [where 条件]
```

别名的用法： 

```
select * from 数据表 [[as] 别名]
例如：select b.name from book as b where name='ganli';
```

字段名称 [[as]别名]

```
select product_offer_instance_object_id as ID, product_offer_instance_object_name name,coumn33 ‘金额’From table
```

授权

```
grant all privileges on *.* to Jaking@'%' identified by 'Jaking@vip.163.com';
flush privileges;
```

去除权限

```
revoke all privileges on *.* from 'Jaking'@'%';
flush privileges;
```

修改数据库字符集

```
alter database book default character set utf8;
```

修改表的字符集

~~~
alter table book1 default character set utf8;
~~~

修改字段字符集

```
alter table book5 change bName bName char(16) CHARACTER SET utf8 COLLATE utf8_general_ci;
```

null和not null的区别

```
为空表示不占空间，null表示占用空间
```

default 设定字段的默认值

~~~
create table test2(name varchar(8) not null,dept varchar(25) default 'SOS');
插入数据时不指定字段内容则显示设定好的默认值
~~~

自动增长 auto_increment

~~~
create table items ( id int not null auto_increment primary key , label varchar(20) not null);
只能修饰int字段
delete 不加where条件，清空所有表记录，但是delete不会清空auto_increment 值
truncate 
作用： 删除表的所有记录，并清空auto_increment 值，新插入的记录从1开始。
语法： truncate table name;
~~~

#### 索引  index

普通索引

~~~
最基本的索引，不具备唯一性，就是加快查询速度
create table demo( id int(4), name varchar(20), pwd varchar(20), index (pwd) );
注意：index和 key 是相同的
create table demo1( id int(4), name varchar(20), pwd varchar(20), key (pwd) );
也可以先建表再添加索引
alter table demo add key (pwd);
alter table demo drop key pwd;
~~~

唯一索引

~~~
与普通索引基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一，用来约束内容，字段值只能出现一次；应该加唯一索引；唯一索引允许有NULL值<允许为空>
create table demo3(id int(4) auto_increment primary key,uName varchar(20),uPwd varchar(20),unique index (uName));
也可以先建表再添加
alter table demo4 add unique weiyi666 (uName);
~~~

主键索引

~~~
查询数据库，按主键查询是最快的，每个表只能有一个主键列，可以有多个普通索引列；主键列要求列的所有内容必须唯一，而索引列不要求内容必须唯一，不允许为空
create table demo5( id int(4) not null auto_increment, name varchar(20) default null,primary key(id));
也可以创建表后添加 <不推荐> 如果生产的数据无法保证唯一，若主键存在自增则创建主键时会报错，要先取消自增再添加主键再将自增添加回来
alter table demo5 change id id int(4) not null; 先取消自增长
alter table demo5 drop primary key;  再删除主键
alter table demo5 change id id int(4) not null primary key auto_increment;   再将自增长添加回来
总结：主键索引，唯一性索引区别：主键索引不能有NULL，唯一性索引可以有空值
~~~

复合索引

~~~
索引可以包含一个、两个或更多个列，两个或更多个列上的索引被称作复合索引
create table firewall ( host varchar(15) not null ,port smallint(4) not null ,access enum('deny','allow') not null, primary key (host,port));  联合主键
总结：
建表的时候如果加各种索引，顺序如下：
create table 表名（字段定义，PRIMARYKEY  (`bId`),UNIQUE KEY `bi` (`bImg`),KEY `bn` (`bName`),KEY `ba` (`author`)）
~~~

全文索引

~~~
全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术；它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果
create table demo6( id int(4), name varchar(20),fulltext key quan(name));
也可以先建表在添加
alter table demo6 drop  key quan;
alter table demo6 add fulltext quan666(name);
强烈注意：MySQL自带的全文索引只能用于数据库引擎为MyISAM的数据表，如果是其他数据引擎，则全文索引不会生效，一般交给第三方软件进行全文索引。
~~~

索引设计原则：

```
1、索引并非越多越好
2、数据量不大不需要建立索引 
3、列中的值变化不多不需要建立索引 row id
4、经常排序（order by 字段）和分组（group by 字段）的列需要建立索引
select a.bTypeId,(select b.bTypeName from category b where a.bTypeId = b.bTypeId) bn,count(*) from books a group by bTypeId;
5、唯一性约束对应使用唯一性索引
Table (id pri,use,name index,pass)
```

#### 外键约束  foreign key

~~~
注：创建成功，必须满足以下4个条件：
1、确保参照的表和字段存在
2、组成外键的字段被索引
3、必须使用ENGINE指定存储引擎为：innodb
4、外键字段和关联字段，数据类型必须一致
~~~

~~~
mysql> create database market;   
mysql> use market;
mysql> create table `user`(id int(11) not null auto_increment, name varchar(50) not null default '', sex int(1) not null default '0', primary key(id))ENGINE=innodb;
#创建时，如果表名是sql关键字，使用时，需要使用反引号``
mysql> create table `order`(o_id int(11) auto_increment, u_id int(11) default '0', username varchar(50), money int(11), primary key(o_id), index(u_id), foreign key order_f_key(u_id) references user(id) on delete cascade on update cascade) ENGINE=innodb;

可以先创建表再添加外键约束
mysql> create table order1(o_id int(11) auto_increment, u_id int(11) default '0', username varchar(50), money int(11), primary key(o_id), index(u_id)) ENGINE=innodb;
mysql> alter table order1 add foreign key(u_id) references user(id) on delete cascade on update cascade, ENGINE =innodb;
mysql> alter table order1 add constraint `bk`foreign key(u_id) references user(id) on delete cascade on update cascade, ENGINE=innodb;
删除外键约束
alter table order1 drop foreign key order1_ibfk_1;
~~~

#### 视图  view

~~~
创建视图
create view bc as select b.bName,b.price,c.pages from book1 as b left join book2 as c on b.bTypeId=c.bTypeId;
更新或者修改视图
alter view bc as select b.bName,b.publishing,c.pages from book1 as b left join book2 as c on b.bTypeId=c.bTypeId;
删除视图
drop view bc;
~~~

~~~
注意：当视图中包含有如下内容时，视图的更新操作将不能被执行：
（1）视图中不包含基表中被定义为非空的列。
（2）在定义视图的SELECT语句后的字段列表中使用了数学表达式。
（3）在定义视图的SELECT语句后的字段列表中使用聚合函数。
（4）在定义视图的SELECT语句中使用了DISTINCT、UNION、TOP、GROUP BY或HAVING子句。
~~~

#### 存储过程

定义存储过程

```
mysql> delimiter %  这样结束符就为%
mysql> create procedure storage()
       begin
       select * from testbookdb.book1;
       end %
创建存储过程之前我们必须修改MySQL语句默认结束符 ; 否则不能创建成功。使用delimiter可以修改执行符号
delimiter 新执行符号  信执行符号可以是%或//
```

调用存储过程

```
call storage() %
```

存储过程参数类型
			in参数 传入参数

```
特点：读取外部变量值，且有效范围仅限存储过程内部
mysql> use testbookdb;
mysql> delimiter //
mysql> create procedure xx(in abc int)
     begin
     select abc;
     set abc=2;
     select abc;
     end;
     //
mysql> call xx(1)//
```

mysql定义变量方法

```
mysql> set @y=1;    局部变量
mysql> select @y;
mysql> call xx(@y);
```

out参数 传出参数

```
特点：不读取外部变量值，在存储过程执行完毕后保留新值
delimiter //
create procedure pout(out p_out int)
  begin
  select p_out;
  set p_out=2;
  select p_out;
  end;
   //
delimiter ;
set @p_out=1;
select @p_out;
此时的p_out=2,无论外界如何定义p_out，只要再次调用pout函数p_out就会等于2
in传入参数,是外部将值传给存储过程来使用的,而out传出参数是为了让存储过程的执行结果回传给调用他的程序来使用的
```

inout参数

```
特点：读取外部变量，在存储过程执行完后保留新值<类似银行存款>
mysql> delimiter //
     create procedure pinout(inout p_inout int)
     begin
     select p_inout;
     set p_inout=2;
     select p_inout;
     end;
     //
mysql> delimiter ;
mysql> set @p_inout=1;
mysql> select @p_inout;
mysql> call pinout(@p_inout);
```

MySQL注释有两种风格

```
“--“：单行注释
“/*......*/”:一般用于多行注释
```

存储过程流程控制语句
			变量作用域：

```
内部的变量在其作用域范围内享有更高的优先权，当执行到end; 时内部变量消失，此时已经在其作用域外，变量不再可见了，因为在存储过程外再也不能找到这个申明的变量，但是你可以通过out参数或者将其值指派给会话变量来保存其值。
mysql> DELIMITER //
     CREATE PROCEDURE proc1()
     begin
     declare x1 varchar(5) default 'outer';
     begin
     declare x1 varchar(5) default 'inner';
     select x1;
     end;
     select x1;
     end;
     //
call proc1()//
先出现 inner  再出现  outer
```

条件语句
1：if-then-else语句

```
mysql> DELIMITER //
     CREATE PROCEDURE matche1()
     BEGIN
     DECLARE a,b int DEFAULT 0;
     -- if
     IF a = 0 THEN
     SELECT 'ture',a;
     END IF;
     -- if-else
     IF b != 0 THEN
     SELECT 'ture',b;
     ELSE
     SELECT 'false',b;
     END IF;
     END;
     //
```

2：case语句

```
mysql> CREATE PROCEDURE matche2()
     BEGIN
     DECLARE a,b int DEFAULT 0;
     -- CASE
     CASE a
     WHEN 0 THEN
     SELECT '0',a;
     WHEN 1 THEN
     SELECT '1',a;
     ELSE
     SELECT '--',a;
     END CASE;
     END;
     //
```

循环语句：
1：while ···· end while

```
mysql> CREATE PROCEDURE matche3()
     BEGIN
     DECLARE a,b int DEFAULT 0; 
     -- while 
     while a<6 do
     SELECT a,b;
     set a=a+1;
     end while; 
     END;
     //
```

2：repeat···· end repeat

```
执行操作后检查结果，而while则是执行前进行检查
mysql> CREATE PROCEDURE matche4()
     BEGIN
     DECLARE a,b int DEFAULT 0; 
     -- repeat
     repeat
     SELECT a,b;
     set a=a+1;
     until a>=5
     end repeat;
     END;
     //
```

3：loop ·····end loop

```
loop循环不需要初始条件，这点和while 循环相似，同时和repeat循环一样不需要结束条件, leave语句的意义是离开循环
mysql> CREATE PROCEDURE matche5()
     BEGIN
     DECLARE a,b int DEFAULT 0; 
     -- loop
     LOOP_LABLE:loop
     SELECT a,b;
     set a=a+1;
     if a >=5 then
     -- 满足条件时结束循环
     leave LOOP_LABLE;
     end if;
     end loop;
     END;
     //
```

4: iterate迭代

```
通过iterate loop_lable; 跳出当前循环
mysql> CREATE PROCEDURE matche6()
     BEGIN
     DECLARE a,b int DEFAULT 0;
     -- iterate
     LOOP_LABLE:loop 
     if a=3 then
     set a=a+1;
     ITERATE LOOP_LABLE;
     end if; 
     SELECT a,b;
     set a=a+1;
     if a>=5 then
     leave LOOP_LABLE;
     end if;
     end loop;
     END;
     //
```

删除存储过程

~~~
方法一：DROP  PROCEDURE  过程名
mysql> drop procedure p_inout;
方法二：DROP PROCEDURE  IF  EXISTS 存储过程名
这个语句被用来移除一个存储程序，不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程
mysql> drop procedure IF  EXISTS proc1;
~~~

#### 触发器

~~~
触发器的作用
1.  安全性
可以基于数据库的值使用户具有操作数据库的某种权利。可以基于时间限制用户的操作。可以基于数据库中的数据限制用户的操作。
2.  审计
可以跟踪用户对数据库的操作。审计用户操作数据库的语句。把用户对数据库的操作写入审计表
3.  实现复杂的数据完整性规则
实现非标准的数据完整性检查和约束。触发器可产生比规则更为复杂的限制。与规则不同，触发器可以引用列或数据库对象。

4．实现复杂的非标准的数据库相关完整性规则。
触发器可以对数据库中相关的表进行连环更新。触发器能够拒绝或回退那些破坏相关完整性的变化，取消试图进行数据更新的事务

5．实时同步地复制表中的数据

6．自动计算数据值
如果数据的值达到了一定的要求，则进行特定的处理。
~~~

~~~
创建触发器：
create  trigger 触发器名称  触发的时机  触发的动作  on 表名 for each row 触发器状态。
参数说明：
触发器名称:  自己定义
触发的时机:  before /after  在执行动作之前还是之后
触发的动作:  指的激发触发程序的语句类型<insert ,update,delete>
each row:  操作第一行我都监控着

触发器创建语法四要素：
1.监视地点(table) 
2.监视事件(insert/update/delete) 
3.触发时间(after/before) 
4.触发事件(insert/update/delete)

CREATE TRIGGER delbook AFTER DELETE ON book1 FOR EACH ROW DELETE FROM book2 WHERE bTypeId = OLD.bTypeId;  当删除第一张表的某个书籍时，第二张表相同bTypeId的书籍同时被删除

删除触发器:
drop trigger  触发器名称;
drop trigger delbook;
~~~

#### 事务

~~~
数据库事务：（database transaction）: 事务是由一组SQL语句组成的逻辑处理单元，要么全成功要么全失败。
 ※ MYSQL中只有INNODB和BDB类型的数据表才能支持事务处理！其他的类型不支持！
事务处理：可以确保非事务性单元的多个操作都能成功完成，否则不会更新数据资源。
数据库默认事务是自动提交的， 也就是发一条 sql 它就执行一条。如果想多条 sql 放在一个事务中执行，则需要使用事务进行处理。当我们开启一个事务，并且没有提交，mysql 会自动回滚事务。或者我们使用 rollback 命令手动回滚事务。
优点：通过将一组操作组成一个，执行时，要么全部成功，要么全部失败的单元。使程序更可靠，简化错误恢复。

事务四大特性：
事务是必须满足4个条件（ACID）
1、  原子性（Autmic）：事务在执行性，要做到“要么不做，要么全做！”，就是说不允许事务部分得执行。即使因为故障而使事务不能完成，在rollback时也要消除对数据库得影响！
2、  一致性（Consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。在事务开始之前和结束之后，数据库的完整性约束没有被破坏。
3、  隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰，这些通过锁来实现。
4、  持久性（Durability）：指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障（比如说宕机等）不应该对其有任何影响。

MySQL事务处理的方法：
1、  用BEGIN,ROLLBACK,COMMIT来实现
START TRANSACTION | BEGIN [WORK]  开启事务
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE] 提交当前事务，执行永久操作。
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE] 回滚当前事务到开始点，取消上一次开始点后的所有操作。
SAVEPOINT 名称   折返点
2、  直接用set来改变mysql的自动提交模式
   MYSQL默认是自动提交的，也就是你提交一个QUERY，它就直接执行！
 SET AUTOCOMMIT = {0 | 1} 设置事务是否自动提交，默认是自动提交的。
0：禁止自动提交
1：开启自动提交
~~~

~~~
mysql> set autocommit=0;
mysql> delimiter //
mysql> start transaction;
     update book2 set bName="aaa" where bTypeId=1;
     update book2 set bName="bbb" where bTypeId=2;
 commit;//
mysql> rollback;  回滚
 执行commit后市永久修改，数据无法回滚
 
测试回滚操作，查看数据库存储引擎是否为innodb，如果为MyISAM无法成功启动事务，修改数据库存储引擎为innodb

mysql> delimiter //
mysql> start transaction; update book2 set bName="AH" where bTypeId=1; update book2 set bName="BL" where bTypeId=2;//  #不提交
mysql> delimiter //
mysql> rollback;
没有执行commit，数据可以回滚，恢复原来的数据
~~~

#### 用户权限管理

~~~
授权所有库所有表的select和insert权限给任意网段的test用户，密码也是test
grant select,insert on *.* to test@'%' identified by 'test';
删除任意网段的test用户
drop user test@'%';
授权所有库所有表的所有权限给任意网段的Jaking用户，密码是Jaking@vip.163.com
grant all privileges on *.* to Jaking@'%' identified by 'Jaking@vip.163.com';
删除任意网段的Jaking用户
revoke all privileges on *.* from 'Jaking'@'%';
刷新权限表
flush privileges;
~~~

检查与修复

```
mysqlcheck客户端工具可以检查和修复MyISAM表，还可以优化和分析表。

mysqlcheck --help 查看帮助
-c, --check (检查表)；
-r, --repair（修复表)；
-a, --analyze (分析表)；
-o, --tmpimize(优化表)； //其中，默认选项是-c(检查表)
-u, --使用mysql中哪个用户进行操作

1：检查表(check)
[root@jaking ~]# mysqlcheck -uroot -pJaking@vip.163.com -c testdb book1
2:  修复表（repair）
[root@jaking ~]# mysqlcheck -uroot -pJaking@vip.163.com -r testdb book1
3:修复指定的数据库
[root@jaking ~]# mysqlcheck -uroot -p -r --databases testdb
扩展： 修复文件系统，容易掉失数据
fsck -y -f /dev/sdbx
4:  检查修复所有数据库
[root@jaking ~]# mysqlcheck -uroot -pJaking@vip.163.com -A -r book.book1
5：每天定时对mysql数据库进行优化
使用计划任务
crontab -e
#0 1 * * * /usr/bin/mysqlcheck -A -o -r  -uroot -pJaking@vip.163.com > /dev/null 2>&1
0 3 * * *  /usr/bin/mysqlcheck -uroot -pJaking@vip.163.com -r -o -A > /dev/null 2>&1 #每天3点优化
```

### 备份与恢复

```
按照备份时对数据库的影响范围分为：Hot backup(热备)  Cold Backup（冷备）Warm Backup（温备）
Hot backup：指在数据库运行中直接备份，对正在运行的数据库没有任何影响，（Online Backup）官方手册为在线备份
Cold Backup：指在数据库停止的情况下进行备份，(OfflineBackup) 官方手册称为离线备份
Warm Backup：备份同样在数据库运行时进行，但是会对当前数据库的操作有所影响，例如加一个全局读锁以保证备份数据的一致性

按照备份后文件内容：
逻辑备份 -->指备份后的文件内容是可读的，通常为文本文件，内容一般是SQL语句，或者是表内的实际数据，如mysqldump和SELECT * INTO OUTFILE的方法，一般适用于数据库的升级和迁移，恢复时间较长
裸文件备份（物理备份）-->拷贝数据库的物理文件，数据库既可以处于运行状态（mysqlhotcopy 、ibbackup、xtrabackup这类工具），也可以处于停止状态，恢复时间较短。

按照备份数据库的内容的量来分，又可以分为：
完全备份：对数据库完整的备份
增量备份：在上一次完全备份基础上，对更新的数据进行备份（xtrabackup）
日志备份：二进制日志备份，主从复制
```

mysqldump

```
导出所有数据库
mysqldump -uroot -pJaking@vip.163.com -A >all.sql
导出某个数据库
mysqldump -uroot -pJaking@vip.163.com testdb > testdb.sql
导出单张表
mysqldump -uroot -pJaking@vip.163.com testdb book1 > testdb.book1.sql  #导出testdb库book1表
导出库的表结构
mysqldump -uroot -pJaking@vip.163.com -d testdb > testdbtable.sql  #只导出testdb库的表结构
只导出数据
mysqldump -uroot -pJaking@vip.163.com -t testdb > testdbdata.sql  #只导出testdb库中的数据
导出数据库，并自动生成库的创建语句
mysqldump -uroot -pJaking@vip.163.com -B testdb > testdb.sql  #生成建库语句

导入所有数据库
mysql -uroot -pJaking@vip.163.com < all.sql
导入数据库
mysql -uroot -pJaking@vip.163.com testdb < testdb.sql  #如果导入时，没有对应的数据库，需要你手动创建一下
使用source导入
mysql> drop database testdb;
mysql> create database testdb;
mysql> use testdb;
mysql> source /tmp/testdb.sql
导入表
mysql> drop table testdb.book1;
mysql> source /tmp/testdb.book1.sql;   #导入表时，不需要重新创建表，要先进到相应的数据库中
mysql> select * from testdb.book1;
导入表结构和数据
mysql> create database testdb;
mysql -uroot -pJaking@vip.163.com testdb < testdbtable.sql
```

mysqlhotcopy

```
mysqlhotcopy使用lock tables、flush tables和cp或scp来快速备份数据库，它是备份数据库或单个表最快的途径,完全属于物理备份,但只能用于备份MyISAM存储引擎和运行在数据库目录所在的机器上，与mysqldump备份不同,mysqldump属于逻辑备份,恢复时是执行的sql语句。
mysqlhotcopy本质是使用锁表语句后再使用cp或scp拷贝数据库

安装mysqlhotcopy
yum provides mysqlhotcopy
yum install -y mariadb mariadb-server
-u 和 -p 与账号密码要相隔一个空格
备份一个数据库到一个目录中
mysqlhotcopy -u root -p 123456 testbookdb /tmp
备份多个数据库到一个目录中
mysqlhotcopy -u root -p 123456 testbookdb mysql /tmp
备份数据库中的某个表
mysqlhotcopy -u root -p 123456 testbookdb./book1/ /tmp  #注意：表后要有/

破坏数据
rm -rf /var/lib/mysql/testbookdb/
恢复数据
cp -ra /tmp/testbookdb/ /var/lib/mysql/
chown -Rf mysql:mysql /var/lib/mysql/testbookdb/
```

```
总结：
mysqldump和mysqlhotcopy的比较：
1、mysqldump 是采用SQL级别的备份机制，它将数据表导成 SQL 脚本文件，数据库大时，占用系统资源较多，支持常用的MyISAM，Innodb
2、mysqlhotcopy只是简单的缓存写入和文件复制的过程，占用资源和备份速度比mysqldump快很多；特别适合大的数据库
3、mysqlhotcopy只能运行在数据库数据目录所在的机器上，mysqldump可以用在远程客户端
4、相同的地方都是在线执行LOCK TABLES 以及 UNLOCK TABLES
5、mysqlhotcopy恢复只需要COPY备份文件到源目录覆盖即可，mysqldump需要导入SQL文件到原来库中
```

xtrabackup备份工具使用

```
Xtrabackup包括两个主要工具：Xtrabackup和innobackupex
Xtrabackup只能备份InnoDB和XtraDB两种引擎表，而不能备份MyISAM数据表
安装
rpm -ivh libev-4.04-2.el6.x86_64.rpm 
rpm -ivh Percona-XtraDB-Cluster-shared-55-5.5.37-25.10.756.el6.x86_64.rpm
yum localinstall -y percona-xtrabackup-24-2.4.4-1.el7.x86_64.rpm
```

innobackupex创建全备

```
创建全备：
innobackupex --user=root --password=Jaking@vip.163.com /tmp/db_backup/ &>>/tmp/db_backup.log
&>>/tmp/db_backup.log   # 可以去掉，不显示输出信息，输出信息重定向到db_backup.log
设置备份的文件夹名称
innobackupex --default-file=/etc/my.cnf --user=root --password=Jaking@vip.163.com --no-timestamp /tmp/db_backup/full
```

innobackupex还原备份

```
systemctl stop mysqld   #停止MySQL服务
rm -rf /var/lib/mysql/*    #删除数据
innobackupex --copy-back /tmp/db_backup/full/    #还原数据
chown -Rf mysql:mysql /var/lib/mysql     #要不然MySQL服务不能启动
systemctl start mysqld
检查数据
```

innobackupex创建增量备份

```
增量备份作用：减少备份数据重复，节省磁盘空间，缩短备份时间
增量备份的实现，依赖于innodb页上面的LSN（log sequence number），每次对数据库的修改都会导致LSN自增，增量备份会复制指定LSN<日志序列号>之后的所有数据页
创建全备
innobackupex --user=root --password=Jaking@vip.163.com /tmp/db_backup/
插入一些数据到表里面
CREATE DATABASE TESTDB;
show databases;
use TESTDB;
CREATE TABLE TABLE1 (bTypeId int,bName char(16),price int,publishing char(16));
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('1','Linux','66','DZ');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('2','CLD','68','RM');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('3','SYS','90','JX');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('4','MySQL1','71','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('5','MySQL2','72','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('6','MySQL3','73','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('7','MySQL4','74','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('8','MySQL5','75','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('9','MySQL6','76','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('10','MySQL7','77','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('11','MySQL8','78','QH');
INSERT INTO TABLE1(bTypeId,bName,price,publishing) VALUES('12','MySQL9','79','QH');

CREATE TABLE TABLE2 (name char(16),price int,pages int);
INSERT INTO TABLE2(name,price,pages) VALUES('Linux','30','666');
INSERT INTO TABLE2(name,price,pages) VALUES('CLD','60','666');
INSERT INTO TABLE2(name,price,pages) VALUES('SYS','80','666');
INSERT INTO TABLE2(name,price,pages) VALUES('MySQL1','166','666');

show tables;
select * from TABLE1;
select * from TABLE2;
创建增量备份
语法 ： innobackupex --user=root --password=Jaking@vip.163.com --incremental /增量1路径 --incremental-basedir=全备路径，指定在哪个全备上进行增量备份
innobackupex --user=root --password=Jaking@vip.163.com --incremental /tmp/db_backup/ --incremental-basedir=/tmp/db_backup/2023-09-12_21-19-02
查看LSN<日志序列号>
cat /tmp/db_backup/2023-09-12_21-19-02/xtrabackup_checkpoints  #全备的
last_lsn = 2611761
cat /tmp/db_backup/2023-09-12_21-22-46/xtrabackup_checkpoints  #增量备份的
last_lsn = 2632627
---增量备份创建的替代方法
语法 ： innobackupex --user=root --password=Jaking@vip.163.com --incremental /tmp/db_backup/ --incremental-lsn=<日志序列号>  #从这个编号点开始备份
innobackupex --user=root --password=Jaking@vip.163.com --incremental /tmp/db_backup/ --incremental-lsn=2611761   #这里是也是第一次增量备份
```

innobackupex增量备份还原

```
还原过程
停止MySQL服务,删除数据 rm -rf /var/lib/mysql/* 

还原增量备份 
增量备份的恢复比全备要复杂一点，第一步是在所有备份目录下重做已提交的日志，如：
innobackupex --apply-log --redo-only BASE-DIR  

innobackupex --apply-log --redo-only BASE-DIR --incremental-dir=INCREMENTAL-DIR-1  
innobackupex --apply-log --redo-only BASE-DIR --incremental-dir=INCREMENTAL-DIR-2  
...
...
...
innobackupex --apply-log BASE-DIR --incremental-dir=INCREMENTAL-DIR-last-num

注意：如果仅有一份增量备份，第3条语句忽略
其中BASE-DIR是指全备目录，INCREMENTAL-DIR-1是指第一次的增量备份，INCREMENTAL-DIR-2是指第二次的增量备份，以此类推。

这里要注意的是：最后一步的增量备份并没有--redo-only选项！

以上语句执行成功之后，最终数据在BASE-DIR（即全备目录）下

第一步完成之后，我们开始第二步：回滚未完成的日志：
innobackupex --apply-log BASE-DIR

上面执行完之后，BASE-DIR里的备份文件已完全准备就绪，最后一步是拷贝：
innobackupex --copy-back BASE-DIR

恢复mysql权限 chown -Rf mysql:mysql /var/lib/mysql/

最后启动 systemctl start mysqld 

检验数据是否恢复正常
注意：innobackupex还原增量备份容易出错，不建议使用！
```

```
# systemctl stop mysqld.service
# rm -rf /var/lib/mysql/*
# innobackupex --apply-log --redo-only /tmp/db_backup/2023-09-12_21-19-02/  #全备的
# innobackupex --apply-log /tmp/db_backup/2023-09-12_21-19-02/ --incremental-dir=/tmp/db_backup/2023-09-12_21-22-46    #前面是全备的，后面是增量备份的
# innobackupex --apply-log /tmp/db_backup/2023-09-12_21-19-02/   #全备的
# innobackupex --copy-back /tmp/db_backup/2023-09-12_21-19-02/   #全备的
# chown -Rf mysql:mysql /var/lib/mysql/
# systemctl start mysqld
# 检查数据
```



### MySQL传统主从

master 192.168.25.133

~~~
一、
vim /etc/my.cnf   
#添加以下内容
log-bin=mysql-bin-master
server-id=1
binlog-do-db=testdb
binlog-ignore-db=mysql
lower_case_table_names=1

重启数据库
systemctl restart mysqld
二、创建好对应的数据库和表
CREATE DATABASE testdb;
show databases;
use testdb;
CREATE TABLE TABLE666 (bTypeId int,bName char(16),price int,publishing char(16));
三、授权
grant replication slave on *.* to slave@"192.168.25.%" identified by "Jaking@vip.163.com";
flush privileges;
四、导出主数据库内容给从服务器
mysqldump -uroot -pJaking@vip.163.com -B testdb > testdb.sql
scp testdb.sql 192.168.25.134:/root
~~~

slave 192.168.25.134

~~~
一、
vim/etc/my.cnf
#添加以下内容
server-id=2
lower_case_table_names=1

重启数据库
systemctl restart mysqld
二、检查一下是否可以连接上主服务器
mysql -uslave -pJaking@vip.163.com -h 192.168.25.133
三、导入主服务器的数据进从服务器
mysql -uroot -pJaking@vip.163.com < testdb.sql
四、配置从服务器
stop slave;
change master to master_host='192.168.25.133',master_user='slave',master_password='Jaking@vip.163.com';
start slave;

若执行数据库的备份与恢复则会出现一下错误：
在show slave status\G 时出现 yes no 解决方法如下
stop slave;
set global sql_slave_skip_counter=1;
start slave;
反复操作直到出现两个yes为止
~~~

测试主从

~~~
一、主服务器添加数据到testdb.table666表上
INSERT INTO table666(bTypeId,bName,price,publishing) VALUES('1','Linux','66','DZ');
INSERT INTO table666(bTypeId,bName,price,publishing) VALUES('2','CLD','68','RM');
INSERT INTO table666(bTypeId,bName,price,publishing) VALUES('3','SYS','90','JX');
INSERT INTO table666(bTypeId,bName,price,publishing) VALUES('4','MySQL1','71','QH');
INSERT INTO table666(bTypeId,bName,price,publishing) VALUES('5','MySQL2','72','QH');
INSERT INTO table666(bTypeId,bName,price,publishing) VALUES('6','MySQL3','73','QH');
二、从服务器能查看到则主从同步成功
~~~

### MySQL GTID主从同步

master 192.168.25.133

~~~
一、授权
grant replication slave on *.* to 'Jaking'@'192.168.25.%' identified by 'Jaking@vip.163.com';
flush privileges;
二、
配置文件添加剂下面内容
log-bin=mysql-bin              #开启二进制日志
server-id=133                   #服务器ID，必须唯一
gtid-mode=on                   #开启gtid模式
enforce-gtid-consistency=on    #强制gtid一致性，开启后对特定的create table不支持
binlog-format=row              #默认为mixed混合模式，更改成row复制，为了数据一致性
log-slave-updates=1            #从库binlog记录主库同步的操作日志
skip-slave-start=1             #跳过slave复制线程
binlog-ignore-db=mysql
#lower_case_table_names=1

重启MySQL
systemctl restart mysqld
~~~

slave 192.168.25.134

~~~
一、
配置文件添加下面内容
log-bin=mysql-bin
server-id=134
gtid-mode=on  
enforce-gtid-consistency=on          
binlog-format=row
log-slave-updates=1
skip-slave-start=1
#lower_case_table_names=1

重启MySQL
systemctl restart mysqld
二、配置从服务器
stop slave;
change master to master_host='192.168.25.133',master_user='Jaking',master_password='Jaking@vip.163.com',master_auto_position=1;
start slave;
~~~

测试主从

~~~
一、主服务执行SQL语句
CREATE DATABASE BOOK;
USE BOOK;
CREATE TABLE book (name char(66),price int,pages int);
INSERT INTO book(name,price,pages) VALUES('Linux','30','666');
INSERT INTO book(name,price,pages) VALUES('Cloud Computing','60','666');
INSERT INTO book(name,price,pages) VALUES('Operation System','80','666');
INSERT INTO book(name,price,pages) VALUES('Artificial Intelligence','166','666');
select * from book;
二、查看从服务器是否同步过来

停止从服务器，主服务器添加数据，启动从服务器，也可以看到停止从服务器时添加的数据
~~~

### MySQL高可用集群架构MHA

```
manager 192.168.25.133
master 192.168.25.134
slave1 192.168.25.135
slave2 192.168.25.136
```

1、添加epel源或者阿里源

```
wget -O /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repo
```

2、在所有的节点安装mha-node

```
所有节点都安装依赖
yum install perl-DBD-MySQL perl-Config-Tiny perl-Log-Dispatch perl-Parallel-ForkManager perl-Time-HiRes perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker perl-CPAN -y

rpm -ivh mha4mysql-node-0.54-0.el6.noarch.rpm
```

3、manager节点安装mha-manager

```
rpm -ivh mha4mysql-manager-0.55-0.el6.noarch.rpm
```

4、**所有**机器都进行ssh登录无密码验证

```
ssh-keygen ->回车->回车->回车
ssh-copy-id 192.168.25.133/4/5/6
```

5、配置master服务器 192.168.25.134

```
MySQ配置文件添加以下内容
log-bin=mysql-bin-master
server-id=1
binlog-ignore-db=mysql

重启MySQL 
systemctl restart mysqld

授权  
grant replication slave on *.* to repl@'192.168.25.%' identified by 'Jaking@vip.163.com';
flush privileges;
```

6、配置slave1从服务器 192.168.25.135

```
MySQ配置文件添加以下内容
log-bin=mysql-slave1
server-id=2
binlog-ignore-db=mysql
log_slave_updates=1

重启MySQL 
systemctl restart mysqld

授权  
grant replication slave on *.* to repl@'192.168.25.%' identified by 'Jaking@vip.163.com';
flush privileges;

建立主从
stop slave;
change master to master_host='192.168.25.134',master_user='repl',master_password='Jaking@vip.163.com';
start slave;
```

7、配置slave2从服务器 192.168.25.136

```
MySQL配置文件添加以下内容
log-bin=mysql-slave2
server-id=3
binlog-ignore-db=mysql
log_slave_updates=1

重启MySQL 
systemctl restart mysqld

授权  
grant replication slave on *.* to repl@'192.168.25.%' identified by 'Jaking@vip.163.com';
flush privileges;

建立主从
stop slave;
change master to master_host='192.168.25.134',master_user='repl',master_password='Jaking@vip.163.com';
start slave;
```

8、两台slave服务器设置read_only（从库对外提供读服务，之所以没有写进配置文件，是因为slave随时会提升为master）

```
mysql -uroot -pJaking@vip.163.com -e 'set global read_only=1'
```

9、创建监控用户（在主从上都执行）

```
grant all privileges on *.* to 'root'@'192.168.25.%' identified  by 'Jaking@vip.163.com';
flush privileges;
```

10、测试主从

```
create database HA charset=utf8
USE HA;
CREATE TABLE book (name char(66),price int,pages int);
INSERT INTO book(name,price,pages) VALUES('Linux','30','666');
INSERT INTO book(name,price,pages) VALUES('Cloud Computing','60','666');
INSERT INTO book(name,price,pages) VALUES('Operation System','80','666');
INSERT INTO book(name,price,pages) VALUES('Artificial Intelligence','166','666');
select * from book;

查看数据是否同步过来
```

11、配置MHA manager 192.168.25.133

```
mkdir -p /etc/masterha
mkdir -p /var/log/masterha/app1
vim /etc/masterha/app1.cnf

[server default]
manager_workdir=/var/log/masterha/app1
manager_log=/var/log/masterha/app1/manager.log
master_binlog_dir=/var/lib/mysql
master_ip_failover_script=/usr/local/bin/master_ip_failover
#master_ip_online_change_script=/usr/local/bin/master_ip_online_change  
password=Jaking@vip.163.com
user=root
ping_interval=1
remote_workdir=/tmp
repl_password=Jaking@vip.163.com
repl_user=repl
#report_script=/usr/local/send_report
#shutdown_script=""
ssh_user=root

[server1]
hostname=192.168.25.134
port=3306

[server2]
hostname=192.168.25.135
port=3306
candidate_master=1
check_repl_delay=0

[server3]
hostname=192.168.25.136
port=3306
```

12、设置relay log的清除方式（在每个slave节点上）

```
mysql -uroot -pJaking@vip.163.com -e 'set global relay_log_purge=0'
```

13、在manager结点上检查ssh配置   192.168.25.133

```
masterha_check_ssh --conf=/etc/masterha/app1.cnf

出现
Sun May 16 04:17:01 2021 - [info] All SSH connection tests passed successfully.
表示成功
```

14、检查整个复制环境状况，配置VIP  master 192.168.25.134

```
ip addr add 192.168.25.132/24 brd 192.168.25.255 dev ens33 label ens33:1
arping -c 1 192.168.25.134
```

15、创建自动切换脚本  manager 192.168.25.133

```
vim /usr/local/bin/master_ip_failover

#!/usr/bin/env perl
use strict;
use warnings FATAL => 'all';
 
use Getopt::Long;
 
my (
    $command,          $ssh_user,        $orig_master_host, $orig_master_ip,
    $orig_master_port, $new_master_host, $new_master_ip,    $new_master_port
);
 
my $vip = '192.168.25.132';
my $brdc = '192.168.25.255';
my $ifdev = 'ens33';
my $key = '1';
my $ssh_start_vip = "/usr/sbin/ip addr add $vip/24 brd $brdc dev $ifdev label $ifdev:$key;/usr/sbin/arping -q -A -c 1 -I $ifdev:$key $vip;iptables -F;";
my $ssh_stop_vip = "/usr/sbin/ip addr del $vip/24 dev $ifdev label $ifdev:$key";
 
GetOptions(
    'command=s'          => \$command,
    'ssh_user=s'         => \$ssh_user,
    'orig_master_host=s' => \$orig_master_host,
    'orig_master_ip=s'   => \$orig_master_ip,
    'orig_master_port=i' => \$orig_master_port,
    'new_master_host=s'  => \$new_master_host,
    'new_master_ip=s'    => \$new_master_ip,
    'new_master_port=i'  => \$new_master_port,
);
 
exit &main();
 
sub main {
 
    print "\n\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\n\n";
 
    if ( $command eq "stop" || $command eq "stopssh" ) {
 
        my $exit_code = 1;
        eval {
            print "Disabling the VIP on old master: $orig_master_host \n";
            &stop_vip();
            $exit_code = 0;
        };
        if ($@) {
            warn "Got Error: $@\n";
            exit $exit_code;
        }
        exit $exit_code;
    }
    elsif ( $command eq "start" ) {
 
        my $exit_code = 10;
        eval {
            print "Enabling the VIP - $vip on the new master - $new_master_host \n";
            &start_vip();
            $exit_code = 0;
        };
        if ($@) {
            warn $@;
            exit $exit_code;
        }
        exit $exit_code;
    }
    elsif ( $command eq "status" ) {
        print "Checking the Status of the script.. OK \n";
        exit 0;
    }
    else {
        &usage();
        exit 1;
    }
}
sub start_vip() {
    `ssh $ssh_user\@$new_master_host \" $ssh_start_vip \"`;
}
# A simple system call that disable the VIP on the old_master
sub stop_vip() {
    `ssh $ssh_user\@$orig_master_host \" $ssh_stop_vip \"`;
}
 
sub usage {
    print
    "Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\n";
}

chmod 755 /usr/local/bin/master_ip_failover

通过masterha_check_repl脚本查看整个集群的状态
masterha_check_repl --conf=/etc/masterha/app1.cnf
```

16、检查MHA Manager的状态   manager 192.168.25.133

```
通过master_check_status脚本查看Manager的状态：
masterha_check_status --conf=/etc/masterha/app1.cnf
app1 is stopped(2:NOT_RUNNING).  
注意：如果正常，会显示"PING_OK"，否则会显示"NOT_RUNNING"，这代表MHA监控没有开启
```

17、开启MHA Manager监控   manager 192.168.25.133

```
nohup masterha_manager --conf=/etc/masterha/app1.cnf --remove_dead_master_conf --ignore_last_failover < /dev/null > /var/log/masterha/app1/manager.log 2>&1 &
```

18、查看MHA Manager监控是否正常   manager 192.168.25.133

```
masterha_check_status --conf=/etc/masterha/app1.cnf
app1 (pid:5788) is running(0:PING_OK), master:192.168.25.134

可以看见已经在监控了，而且master的主机为192.168.25.134
```

19、关闭MHA Manage监控   manager 192.168.25.133

```
masterha_stop --conf=/etc/masterha/app1.cnf
```

20、故障模拟

```
master 192.168.25.135 停掉
systemctl stop mysqld

manager 192.168.25.133 查看日志
tail -f /var/log/masterha/app1/manager.log

发现日志里有这两句话
Master 192.168.25.134 is down!
Selected 192.168.25.135 as a new master.

表明原来的master 192.168.25.134挂掉了，由原来的slave1 192.168.25.135上任为新的master，并与slave2 192.168.25.136 成为主从。
```

总结：
目前高可用方案可以一定程度上实现数据库的高可用，还有其他方案heartbeat+drbd，Cluster、MGR等；这些高可用软件各有优劣，在进行高可用方案选择时，主要是看业务还有对数据一致性方面的要求

### MySQL+Atlas ---读写分离

```
Atlas代理  192.168.25.133
master    192.168.25.134
slave     192.168.25.135
都安装MySQL
```

数据库的配置

```
master 192.168.25.134
grant all on *.* to Jaking@'%' identified by "Jaking@vip.163.com";
flush privileges;
use mysql
update user set host = '%' where user = 'Jaking';
flush privileges;
```

主从配置

```
master 192.168.25.134
MySQL配置文件添加以下内容
binlog-do-db=test
binlog-ignore-db=mysql
log-bin=mysql-bin
server-id=1
重启MySQL  systemctl restart mysqld
授权
grant replication slave on *.* to 'Jaking'@'%' identified by 'Jaking@vip.163.com';
flush privileges;

slave 192.168.25.135
MySQL配置文件添加以下内容
server-id=2
重启MySQL  systemctl restart mysqld
授权
create database test;
stop slave;
change master to master_host='192.168.25.134',master_user='Jaking',master_password='Jaking@vip.163.com',master_port=3306, master_log_file='mysql-bin.000001',master_log_pos=591,master_connect_retry=10;
start slave;
测试主从是否同步成功
```

Atlas配置

```
安装
rpm -ivh Atlas-2.2.1.el6.x86_64.rpm
对密码进行加密
cd /usr/local/mysql-proxy/bin/
./encrypt Jaking@vip.163.com
得到一串字符串  sNU0V6SrdE173jSAUy5Kl+BK/UZJ6u8m
配置Atlas
vim /usr/local/mysql-proxy/conf/test.cnf
修改
12行 proxy-backend-addresses = 192.168.25.134:3306
15行 proxy-read-only-backend-addresses = 192.168.25.135:3306@1
18行 pwds = Jaking:sNU0V6SrdE173jSAUy5Kl+BK/UZJ6u8m
启动Atlas
cd /usr/local/mysql-proxy/bin
./mysql-proxyd test start
查看Atlas启动状态
./mysql-proxyd test status
ps aux | grep test
netstat -pantul | grep 1234
netstat -pantul | grep 2345
停止本机MySQL服务
systemctl stop mysqld
系统的MySQL进不去可以使用Atlas的管理模式进去
mysql -h127.0.0.1 -P2345 -uuser -ppwd
使用工作接口来访问
mysql -h127.0.0.1 -P1234 -uJaking -pJaking@vip.163.com
```

读写分离测试

```
MySQL主库和从库开启general_log日志
master 192.168.25.134
MySQL配置文件添加以下内容
general_log=ON
general_log_file=/var/lib/mysql/server134.log
重启MySQL   systemctl restart mysqld

slave 192.168.25.135
MySQL配置文件添加以下内容
general_log=ON
general_log_file=/var/lib/mysql/server135.log
重启MySQL   systemctl restart mysqld

master 192.168.25.134  查看日志
tail -f /var/lib/mysql/server134.log
slave 192.168.25.135   查看日志
tail -f /var/lib/mysql/server135.log
Atlas 192.168.25.133
通过工作接口访问
mysql -h127.0.0.1 -P1234 -uJaking -pJaking@vip.163.com
use test     -->master日志变动
CREATE TABLE book1(name char(16),price int,pages int);   -->master日志变动
INSERT INTO book1(name,price,pages) VALUES('Linux','66','666');      -->master日志变动
select * from book;   -->slave日志变动
select * from book1;    --slave日志变动

MySQL + Atlas --- 读写分离完成
```

### MySQL+MyCAT---读写分离

[![piWYgmR.png](https://z1.ax1x.com/2023/12/11/piWYgmR.png)](https://imgse.com/i/piWYgmR)

```
读写分离工作原理：
基本的原理是让主数据库处理事务性增、改、删操作(INSERT、UPDATE、DELETE)，而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。
读写分离优点：
A：应用程序内部实现读写分离，安装既可以使用
B：减少一定部署难度
C：访问压力在一定级别以下，性能很好
读写分离缺点：
A：架构一旦调整，代码要跟着变
B：难以实现高级应用，如自动分库，分表
C：无法适用大型应用场景

什么是MyCAT
·  一个彻底开源的，面向企业应用开发的大数据库集群
·  支持事务、ACID、可以替代MySQL的加强版数据库
·  一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群
·  一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server
·  结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品
·  一个新颖的数据库中间件产品
```

[![piWY201.png](https://z1.ax1x.com/2023/12/11/piWY201.png)](https://imgse.com/i/piWY201)

```
mycat 192.168.25.133
master 192.168.25.134
slave 192.168.25.135
```

MyCAT安装与配置

```
上传mycat和jdk
解压mycat
tar xvf Mycat-server-1.6.7.3-release-20190927161129-linux.tar.gz -C /usr/local
cd /usr/local/mycat/
创建mycat用户
useradd mycat
chown -R mycat.mycat /usr/local/mycat
echo 123456 | passwd --stdin mycat
解压jdk
mkdir /usr/java
tar xvf jdk-8u201-linux-x64.tar.gz -C /usr/java/

vim /etc/profile
末尾添加以下内容
#配置MyCAT所需环境变量
JAVA_HOME=/usr/java/jdk1.8.0_201
PATH=$JAVA_HOME/bin:$PATH 
CLASSPATH=$JAVA_HOME/jre/lib/ext:$JAVA_HOME/lib/tools.jar  
export PATH JAVA_HOME CLASSPATH 
MYCAT_HOME=/usr/local/mycat  
PATH=$MYCAT_HOME/bin:$PATH

source /etc/profile
jave -version

在MyCAT Server所在的服务器上配置IP和主机名的映射
vim /etc/hosts
192.168.25.133 server133
192.168.25.134 server134
192.168.25.135 server135

配置server.xml
vim /usr/local/mycat/conf/server.xml
#test是主从同步的数据库
101行   <user name="root" defaultAccount="true">
102行       <property name="password">Jaking@vip.163.com</property>
103行       <property name="schemas">test</property>

116行        <user name="user">
117行                <property name="password">user</property>
118行                <property name="schemas">test</property>
119行                <property name="readOnly">true</property>
120行        </user>

配置schema.xml
cp /usr/local/mycat/conf/schema.xml /usr/local/mycat/conf/schema.xml.bak
>/usr/local/mycat/conf/schema.xml
vim /usr/local/mycat/conf/schema.xml

<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">
<schema name="test" checkSQLschema="false" sqlMaxLimit="100" dataNode='dn1'>
        </schema>
        <dataNode name="dn1" dataHost="dthost" database="test"/>
        <dataHost name="dthost" maxCon="500" minCon="10" balance="3" writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100">
        <heartbeat>select user()</heartbeat>
        <writeHost host="server134" url="192.168.25.134:3306" user="root" password="Jaking@vip.163.com">
        <readHost host="server135" url="192.168.25.135:3306" user="root" password="Jaking@vip.163.com" />
        </writeHost>
        </dataHost>
</mycat:schema>

配置log4j2.xml
vim /usr/local/mycat/conf/log4j2.xml
25行         <asyncRoot level="debug" includeLocation="true">

重启mycat
mycat restart
查看日志  tail -f /usr/local/mycat/logs/wrapper.log
```

主从配置

```
master 192.168.25.134
MySQL配置文件添加以下内容
binlog-do-db=test
binlog-ignore-db=mysql
log-bin=mysql-bin
server-id=1
重启MySQL  systemctl restart mysqld
授权
grant replication slave on *.* to 'Jaking'@'%' identified by 'Jaking@vip.163.com';
flush privileges;

slave 192.168.25.135
MySQL配置文件添加以下内容
server-id=2
重启MySQL  systemctl restart mysqld
授权
stop slave;
create database test;
change master to master_host='192.168.25.134',master_user='Jaking',master_password='Jaking@vip.163.com';
start slave;
测试主从是否同步成功
```

测试MySQL读写分离

```
master 192.168.25.134
grant all privileges on *.* to root@"%" identified by "Jaking@vip.163.com";
flush privileges;

slave 192.168.25.135
grant all privileges on *.* to root@"%" identified by "Jaking@vip.163.com";
flush privileges;

先查看mycat 192.168.25.133 的日志
tail -f /usr/local/mycat/logs/mycat.log
目前MyCAT有两个端口，8066数据端口，9066管理端口，测试读写操作用8066数据端口
mysql -uroot -pJaking@vip.163.com -h 192.168.25.134 -P8066
show databases;  -->192.168.25.133操作
use test;  -->192.168.25.133操作
select * from book;  -->192.168.25.135操作
select * from book1;  -->192.168.25.135操作
insert into book1 values ('zuo',250,388);  -->192.168.25.134操作
select * from book1;  -->192.168.25.135操作

MySQL + MyCAT  读写分离完成  
```

### MySQL5.7 MGR集群

https://www.cnblogs.com/kevingrace/p/10260685.html  

获取 loose-group_replication_group_name 的方法，选中单主matser节点

```
server133 192.168.25.133

mysql> select uuid();
7fa485da-5221-11ee-b44e-000c29b79095
```

```
192.168.25.133 server133
192.168.25.134 server134
192.168.25.135 server135
```

1、设置hostname和IP映射

```
192.168.25.133 server133
192.168.25.134 server134
192.168.25.135 server135
```

2、server133  192.168.25.133

MySQL配置文件

```
# Group Replication
server_id = 133  #服务ID
gtid_mode = ON  #全局事务
enforce_gtid_consistency = ON  #强制GTID的一致性
master_info_repository = TABLE  #将master.info元数据保存在系统表中
relay_log_info_repository = TABLE  #将relay.info元数据保存在系统表中
binlog_checksum = NONE  #禁用二进制日志事件校验
log_slave_updates = ON  #级联复制
log_bin = binlog   #开启二进制日志记录
binlog_format = ROW  #以行的格式记录
 
transaction_write_set_extraction = XXHASH64 #使用哈希算法将其编码为散列
loose-group_replication_group_name = '7d09cf2e-5223-11ee-b44e-000c29b79095' #加入的组名，命名格式参考cat /var/lib/mysql/auto.cnf
loose-group_replication_start_on_boot = off #不自动启用组复制集群
loose-group_replication_local_address = 'server133:33061' #以本机端口33061接受来自组中成员的传入连接
loose-group_replication_group_seeds =' server133:33061, server134:33062, server135:33063' #组中成员访问表
loose-group_replication_bootstrap_group = off #不启用引导组
```

重启MySQL 

```
systemctl restart mysqld
```

server133上建立复制账号

```
set SQL_LOG_BIN=0;     #停掉日志记录
grant replication slave on *.* to repl@'192.168.25.%' identified by 'Jaking@vip.163.com';
flush privileges;
set SQL_LOG_BIN=1;  #开启日志记录
change master to master_user='repl',master_password='Jaking@vip.163.com'  for channel 'group_replication_recovery';    #构建group replication集群
```

在mysql服务器server133上安装group replication插件

```
install PLUGIN group_replication SONAME 'group_replication.so';
```

启动服务器server133上MySQL的group replication

```
设置group_replication_bootstrap_group为ON是为了标示以后加入集群的服务器以这台服务器为基准，以后加入的就不需要设置。
set global group_replication_bootstrap_group=ON;
作为首个节点启动MGR集群
start group_replication;
set global group_replication_bootstrap_group=OFF;
```

查看MGR的状态

```
select * from performance_schema.replication_group_members;
```

测试服务器server133上的MySQL

```
create database test;
use test;
create table table666 (id int primary key,name varchar(20));  #注意创建主键
insert into table666 values (1,'jaking');
select * from table666;
show binlog events;
```

3、server  192.168.25.134

MySQL配置文件

```
# Group Replication
server_id = 134  #服务ID
gtid_mode = ON  #全局事务
enforce_gtid_consistency = ON  #强制GTID的一致性
master_info_repository = TABLE  #将master.info元数据保存在系统表中
relay_log_info_repository = TABLE  #将relay.info元数据保存在系统表中
binlog_checksum = NONE  #禁用二进制日志事件校验
log_slave_updates = ON  #级联复制
log_bin = binlog   #开启二进制日志记录
binlog_format = ROW  #以行的格式记录
 
transaction_write_set_extraction = XXHASH64 #使用哈希算法将其编码为散列
loose-group_replication_group_name = '7d09cf2e-5223-11ee-b44e-000c29b79095' #加入的组名，命名格式参考cat /var/lib/mysql/auto.cnf
loose-group_replication_start_on_boot = off #不自动启用组复制集群
loose-group_replication_local_address = 'server134:33062' #以本机端口33061接受来自组中成员的传入连接
loose-group_replication_group_seeds =' server133:33061, server134:33062, server135:33063' #组中成员访问表
loose-group_replication_bootstrap_group = off #不启用引导组
```

重启MySQL

```
systemctl restart mysqld
```

用户授权

```
set SQL_LOG_BIN=0;     #停掉日志记录
grant replication slave on *.* to repl@'192.168.25.%' identified by 'Jaking@vip.163.com';
flush privileges;
set SQL_LOG_BIN=1;  #开启日志记录
change master to master_user='repl',master_password='Jaking@vip.163.com'  for channel 'group_replication_recovery';    #构建group replication集群
```

在mysql服务器server134上安装group replication插件

```
install PLUGIN group_replication SONAME 'group_replication.so';
```

在server134上操作，把实例添加到之前的复制组

```
set global group_replication_allow_local_disjoint_gtids_join=ON;
start group_replication;
select * from performance_schema.replication_group_members;
```

在server134上查看复制组状态

```
select * from performance_schema.replication_group_members;
```

在新添加的server134实例上查看数据库发现test库和table666表已经同步

```
show databases;
use test;
show tables;
select * from table666;
```

4、server135  192.168.25.135

MySQL配置文件

```
# Group Replication
server_id = 135  #服务ID
gtid_mode = ON  #全局事务
enforce_gtid_consistency = ON  #强制GTID的一致性
master_info_repository = TABLE  #将master.info元数据保存在系统表中
relay_log_info_repository = TABLE  #将relay.info元数据保存在系统表中
binlog_checksum = NONE  #禁用二进制日志事件校验
log_slave_updates = ON  #级联复制
log_bin = binlog   #开启二进制日志记录
binlog_format = ROW  #以行的格式记录
 
transaction_write_set_extraction = XXHASH64 #使用哈希算法将其编码为散列
loose-group_replication_group_name = '7d09cf2e-5223-11ee-b44e-000c29b79095' #加入的组名，命名格式参考cat /var/lib/mysql/auto.cnf
loose-group_replication_start_on_boot = off #不自动启用组复制集群
loose-group_replication_local_address = 'server135:33063' #以本机端口33061接受来自组中成员的传入连接
loose-group_replication_group_seeds =' server133:33061, server134:33062, server135:33063' #组中成员访问表
loose-group_replication_bootstrap_group = off #不启用引导组
```

重启MySQL

```
systemctl restart mysqld
```

用户授权

```
set SQL_LOG_BIN=0;     #停掉日志记录
grant replication slave on *.* to repl@'192.168.25.%' identified by 'Jaking@vip.163.com';
flush privileges;
set SQL_LOG_BIN=1;  #开启日志记录
change master to master_user='repl',master_password='Jaking@vip.163.com'  for channel 'group_replication_recovery';    #构建group replication集群
```

在mysql服务器server135上安装group replication插件

```
install PLUGIN group_replication SONAME 'group_replication.so';
```

在server135上操作，把实例添加到之前的复制组

```
set global group_replication_allow_local_disjoint_gtids_join=ON;
start group_replication;
select * from performance_schema.replication_group_members;
```

在MGR任意节点上查看复制组状态

```
select * from performance_schema.replication_group_members;
```

在新添加的server135实例上查看数据库发现test库和table666表已经同步

```
show databases;
use test;
show tables;
select * from table666;
```

如果在非主节点执行写操作，则会遇到以下报错：

```
mysql> insert into table666 values (2023,'jaking2023');

ERROR 1290 (HY000): The MySQL server is running with the --super-read-only option so it cannot execute this statement
```

至此，单master节点MySQL5.7 MGR集群就搭建完毕！

5、模拟故障

```
server133  192.168.25.133
停止MySQL服务
systemctl stop mysqld

查看日志
tail -n 66 /var/log/mysqld.log 

server134 192.168.25.134
select * from performance_schema.replication_group_members;
SHOW STATUS LIKE 'group_replication_primary_member';
show variables like 'server_uuid';
发现主节点变成了server134
可以进行插入数据
insert into table666 values (2023,'ganliniubi');
select * from table666;

server135 192.168.25.135
select * from table666;
发现数据同步过来了

查看集群参数设置列表
show variables like 'group_replication%';
```

6、multi-primary模式(多主master模式)

```
1、该模式启用需设置两个参数
group_replication_single_primary_mode=0  #这个参数很好理解，就是关闭单master模式
group_replication_enforce_update_everywhere_checks=1 #这个参数设置多主模式下各个节点严格一致性检查
2、默认启动的都是单master模式，其他节点都设置了read_only、super_read_only这两个参数，需要修改这两个配置
3、完成上面的配置后就可以执行多点写入了，多点写入会存在冲突检查，这耗损性能挺大的，官方建议采用网络分区功能，在程序端把相同的业务定位到同一节点，尽量减少冲突发生几率。
```

由单主模式修改为多主模式方法

```
在原来单主模式的主节点执行以下操作：即server134  192.168.25.134
stop GROUP_REPLICATION;
set global group_replication_single_primary_mode=off;
set global group_replication_enforce_update_everywhere_checks=ON;
SET GLOBAL group_replication_bootstrap_group=ON;
START GROUP_REPLICATION;
SET GLOBAL group_replication_bootstrap_group=OFF;

其他节点，执行以下操作：即server133 和 server135
stop GROUP_REPLICATION;
set global group_replication_allow_local_disjoint_gtids_join=ON;(即使含有组中不存在的事务，也允许当前server加入组)
set global group_replication_single_primary_mode=off;
set global group_replication_enforce_update_everywhere_checks=ON;

执行以上语句后发现三个节点都可以插入数据并同步数据
```

直接搭建多主master模式

my.cnf配置文件：

```
# Group Replication

server_id = 133 #服务ID

gtid_mode = ON #全局事务

enforce_gtid_consistency = ON #强制GTID的一致性

master_info_repository = TABLE #将master.info元数据保存在系统表中

relay_log_info_repository = TABLE #将relay.info元数据保存在系统表中

binlog_checksum = NONE #禁用二进制日志事件校验

log_slave_updates = ON #级联复制

log_bin = binlog  #开启二进制日志记录

binlog_format= ROW #以行的格式记录

 
transaction_write_set_extraction = XXHASH64 #使用哈希算法将其编码为散列

loose-group_replication_group_name = '7fa485da-5221-11ee-b44e-000c29b79095' #加入的组名

loose-group_replication_start_on_boot = off #不自动启用组复制集群

loose-group_replication_local_address = 'server133:33061' #以本机端口33061接受来自组中成员的传入连接

loose-group_replication_group_seeds = 'server133:33061,server134:33062,server135:33063' #组中成员访问表

loose-group_replication_bootstrap_group = off #不启用引导组

group_replication_single_primary_mode = off #关闭单master模式

group_replication_enforce_update_everywhere_checks = ON #多主一致性检查
```

（如果日志不一致(先停止集群，然后reset master清空日志)

### MySQL分库分表

#### 1、MyCAT安装

配置hosts

```
#追加到hosts文件里
cat >> /etc/hosts << EOF
192.168.25.133 server133
192.168.25.134 server134
192.168.25.135 server135
192.168.25.136 server136
EOF
```

安装配置jdk

```
上传jdk的包
tar xvf jdk-8u201-linux-x64.tar.gz -C /mysql/app

设置JAVA环境变量
vim .bashrc 
末尾添加一下内容
export JAVA_HOME=/mysql/app/jdk1.8.0_201
export PATH=$JAVA_HOME/bin:$PATH

vim /etc/profile
末尾添加以下内容
# jdk set
export JAVA_HOME=/mysql/app/jdk1.8.0_201
export JRE_HOME=$JAVA_HOME/jre 
export MYCAT_HOME=/mysql/app/mycat
export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH   
export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$MYCAT_HOME/bin:$PATH

使文件生效
source /etc/profile
source ~/.bashrc

查看Java版本
java -version
```

安装配置mycat

```
解压mycat的包
tar xvf Mycat-server-1.6.5-release-20180122220033-linux.tar.gz  -C /mysql/app/

添加mycat用户
groupadd mycat
useradd -g mycat mycat 
echo "Jaking@vip.163.com" | passwd --stdin mycat
chown -Rf mycat:mycat /mysql/app/mycat

配置mycat.service文件
vim /usr/lib/systemd/system/mycat.service
[Unit]
Description=mycat Database Proxy
Description=mycat
After=syslog.target
After=network.target

[Service]
Type=simple
Restart=on-abort
PIDFile=/mysql/app/mycat/logs/mycat.pid
ExecStart=/mysql/app/mycat/bin/mycat start
PrivateTmp=true

[Install]
WantedBy=multi-user.target

使用绝对路径更稳定
vim /mysql/app/mycat/conf/wrapper.conf
5行 wrapper.java.command=java
改成 wrapper.java.command=/mysql/app/jdk1.8.0_201/bin/java
```

mycat管理

```
systemctl daemon-reload
systemctl enable mycat
systemctl start mycat
systemctl status mycat

查看进程
ps aux | grep mycat
```

#### 2、mycat垂直分表操作

192.168.25.134

```
mysql -uroot -pJaking@vip.163.com

create user 'root'@'%' identified by 'Jaking@vip.163.com';
grant all privileges on *.* to 'root'@'%';
flush privileges;
create database jakingtestdb01 default character set utf8; 
create database jakingtestdb02 default character set utf8; 
create database jakingtestdb03 default character set utf8;
show databases;
```

192.168.25.135

```
mysql -uroot -pJaking@vip.163.com

create user 'root'@'%' identified by 'Jaking@vip.163.com';
grant all privileges on *.* to 'root'@'%';
flush privileges;
create database jakingtestdb04 default character set utf8; 
create database jakingtestdb05 default character set utf8; 
create database jakingtestdb06 default character set utf8;
show databases;
```

192.168.25.136

```
mysql -uroot -pJaking@vip.163.com

create user 'root'@'%' identified by 'Jaking@vip.163.com';
grant all privileges on *.* to 'root'@'%';
flush privileges;
create database jakingtestdb07 default character set utf8; 
create database jakingtestdb08 default character set utf8; 
create database jakingtestdb09 default character set utf8;
show databases;	
```

配置 schema.xml 文件    192.168.25.133

```
cd /mysql/app/mycat/conf
mv schema.xml schema.xml.bak
vim schema.xml

<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">

	<!-- 逻辑库配置 mycatdb1,mycatdb2,mycatdb3 是逻辑库并不是真的数据库-->
	
	<!-- 其中 checkSQLschema 表明是否检查并过滤 SQL 中包含 schema 的情况:
	如逻辑库为 mycatdb1，则可能写为 select * from mycatdb1.jakingtestdb11，
	此时会自动过滤 mycatdb1，SQL 变为 select * from jakingtestdb11，若不会出现上述写法，则可以关闭属性为 false	
	checkSQLschema="false"    select * from mycatdb1.jakingtestdb11;
	checkSQLschema="true"     select * from jakingtestdb11;   --> 

	<!-- sqlMaxLimit 默认返回的最大记录数限制，
	MyCat1.4 版本里面，用户的 Limit 参数会 覆盖掉 MyCat 的 sqlMaxLimit 默认设置-->
	

<!-- 每个逻辑库对应一个 schema ,每个schema 对应一个数据节点 -->
<schema name="mycatdb1" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb1"/>
<schema name="mycatdb2" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb2"/> 
<schema name="mycatdb3" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb3"/> 
<schema name="mycatdb4" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb4"/> 
<schema name="mycatdb5" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb5"/> 
<schema name="mycatdb6" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb6"/> 
<schema name="mycatdb7" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb7"/> 
<schema name="mycatdb8" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb8"/> 
<schema name="mycatdb9" checkSQLschema="false" sqlMaxLimit="100" dataNode="dnmycatdb9"/>


	<!-- 表分片配置在这里 --> 
	<!--</schema> --> 
	<!-- 定义 MyCat 的数据节点，节点配置 jakingtestdb01,jakingtestdb02,jakingtestdb03 才是真正的数据库， 
		dataNode 中的 name 数据表示节点名称， dataHost 表示数据主机名称， 
		database 表示该节点要路由的数据库的名称 -->

<!-- 设定数据结点 dnmycatdb1-3 对应的 192.168.25.134 服务以及对应的物理 schema --> 
<dataNode name="dnmycatdb1" dataHost="server134" database="jakingtestdb01" /> 
<dataNode name="dnmycatdb2" dataHost="server134" database="jakingtestdb02" /> 
<dataNode name="dnmycatdb3" dataHost="server134" database="jakingtestdb03" />

<!-- 设定数据结点 dnmycatdb4-6 对应的 192.168.135 服务以及对应的物理 schema --> 
<dataNode name="dnmycatdb4" dataHost="server135" database="jakingtestdb04" /> 
<dataNode name="dnmycatdb5" dataHost="server135" database="jakingtestdb05" /> 
<dataNode name="dnmycatdb6" dataHost="server135" database="jakingtestdb06" /> 

<!-- 设定数据结点 dnmycatdb7-9 对应的 192.168.136 服务以及对应的物理 schema --> 
<dataNode name="dnmycatdb7" dataHost="server136" database="jakingtestdb07" /> 
<dataNode name="dnmycatdb8" dataHost="server136" database="jakingtestdb08" /> 
<dataNode name="dnmycatdb9" dataHost="server136" database="jakingtestdb09" />


	<!-- 读写分离的配置 -->
	<!-- dataHost 配置的是实际的后端数据库集群（当然，也可以是非集群） -->
	<!-- 注意： schema 中的每一个 dataHost 中的 host 属性值必须唯一，否则会出现主从在所有 dataHost 中全部切换的现象 -->
	<!-- 定义数据主机 dtHost1，只连接到 MySQL 读写分离集群中的 Master 节点，不使用 MyCat 托管 MySQL 主从切换 -->
	<!-- 
		<dataHost name="dtHost1" maxCon="500" minCon="20" balance="0" 
		writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"> 
		<heartbeat>select user()</heartbeat> 
		<writeHost host="hostM1" url="192.168.10.63:3306" user="root" password="lyz" /> 
		</dataHost> 
	-->
	

<!-- 设定物理机，若要做读写分离可以参考上面的部分 --> 
<dataHost name="server134" maxCon="1000" minCon="10" balance="1" 
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.134" url="192.168.25.134:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost>

<dataHost name="server135" maxCon="1000" minCon="10" balance="1"
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.135" url="192.168.25.135:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost>

<dataHost name="server136" maxCon="1000" minCon="10" balance="1" 
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.136" url="192.168.25.136:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost> 

</mycat:schema>

设置权限
chmod 777 schema.xml
chown mycat:mycat schema.xml
```

配置 server.xml 文件 192.168.25.133

```
cd /mysql/app/mycat/conf
cp server.xml server.xml.bak
vim server.xml
只修改一下地方，给出大概行数，具体看情况
 93         <user name="root" defaultAccount="true">
 94                 <property name="password">Jaking@vip.163.com</property>
 95                 <property name="schemas">mycatdb1,mycatdb2,mycatdb3,mycat    db4,mycatdb5,mycatdb6,mycatdb7,mycatdb8,mycatdb9</property>

.....

108         <user name="mycat">
109                 <property name="password">Jaking@vip.163.com</property>
110                 <property name="schemas">mycatdb1,mycatdb2,mycatdb3,mycat    db4,mycatdb5,mycatdb6,mycatdb7,mycatdb8,mycatdb9</property>
111                 <property name="readOnly">true</property>
112         </user>
```

启动mycat 观察，启动日志

```
tail -20f /mysql/app/mycat/logs/wrapper.log

systemctl stop mycat
systemctl start mycat
systemctl status mycat
```

登陆mycat 查看数据源  192.168.25.134

```
mysql -uroot -pJaking@vip.163.com -P9066 -h192.168.25.133
# 查看所有帮助
show @@help;

# 查看逻辑数据库
show @@databases;

# 查看数据源
show @@datasource;

# 查看心跳
show @@heartbeat;
```

访问mycat 测试    192.168.25.134

```
mysql -uroot -pJaking@vip.163.com -P8066 -h192.168.25.134 -Dmycatdb1

show tables;
create table t1(id int);
show tables;
```

192.168.25.134 操作登陆，看看能否正常

```
mysql -uroot -pJaking@vip.163.com
show databases;
use jakingtestdb01;
show tables;

mysql -uroot -pJaking@vip.163.com -P9066 -h192.168.25.133
show databases;
```

#### 3、mycat全国省份分片枚举操作---垂直分表

192.168.25.134

```
mysql -uroot -pJaking@vip.163.com
drop database jakingtestdb01;
drop database jakingtestdb02;
drop database jakingtestdb03;
create database jakingtestdb01 default character set utf8; 
create database jakingtestdb02 default character set utf8; 
create database jakingtestdb03 default character set utf8; 
create database jakingtestdb04 default character set utf8; 
create database jakingtestdb05 default character set utf8; 
create database jakingtestdb06 default character set utf8; 
create database jakingtestdb07 default character set utf8; 
create database jakingtestdb08 default character set utf8; 
create database jakingtestdb09 default character set utf8; 
create database jakingtestdb10 default character set utf8; 
create database jakingtestdb11 default character set utf8; 
create database jakingtestdb12 default character set utf8;
show databases;
```

192.168.25.135

```
mysql -uroot -pJaking@vip.163.com
drop database jakingtestdb04;
drop database jakingtestdb05;
drop database jakingtestdb06;
create database jakingtestdb13 default character set utf8; 
create database jakingtestdb14 default character set utf8; 
create database jakingtestdb15 default character set utf8; 
create database jakingtestdb16 default character set utf8; 
create database jakingtestdb17 default character set utf8; 
create database jakingtestdb18 default character set utf8; 
create database jakingtestdb19 default character set utf8; 
create database jakingtestdb20 default character set utf8; 
create database jakingtestdb21 default character set utf8; 
create database jakingtestdb22 default character set utf8; 
create database jakingtestdb23 default character set utf8; 
create database jakingtestdb24 default character set utf8;
show databases;
```

192.168.25.136

```
mysql -uroot -pJaking@vip.163.com
drop database jakingtestdb07;
drop database jakingtestdb08;
drop database jakingtestdb09;
create database jakingtestdb25 default character set utf8; 
create database jakingtestdb26 default character set utf8; 
create database jakingtestdb27 default character set utf8; 
create database jakingtestdb28 default character set utf8; 
create database jakingtestdb29 default character set utf8; 
create database jakingtestdb30 default character set utf8; 
create database jakingtestdb31 default character set utf8; 
create database jakingtestdb32 default character set utf8; 
create database jakingtestdb33 default character set utf8; 
create database jakingtestdb34 default character set utf8; 
create database jakingtestdb35 default character set utf8; 
create database jakingtestdb36 default character set utf8;
show databases;
```

配置 schema.xml 文件 192.168.25.133

```
cd /mysql/app/mycat/conf
mv schema.xml schema.xml.bak
vim schema.xml 
```

```
<?xml version="1.0"?> 
<!DOCTYPE mycat:schema SYSTEM "schema.dtd"> 
<mycat:schema xmlns:mycat="http://io.mycat/">

<schema name="mycatdb" checkSQLschema="false" sqlMaxLimit="100"> 
	<table name="jakingtest_member" dataNode="dnmycatdb$1-36" rule="sharding-by-intfile-mycatdb-jakingtest_member"></table> 
</schema>

	
<!-- 设定数据节点 dnmycatdb1-dnmycatdb12 对应的 192.168.25.134 服务以及对应的物理 schema -->
<dataNode name="dnmycatdb1" dataHost="192.168.25.134" database="jakingtestdb01" />
<dataNode name="dnmycatdb2" dataHost="192.168.25.134" database="jakingtestdb02" />
<dataNode name="dnmycatdb3" dataHost="192.168.25.134" database="jakingtestdb03" />
<dataNode name="dnmycatdb4" dataHost="192.168.25.134" database="jakingtestdb04" />
<dataNode name="dnmycatdb5" dataHost="192.168.25.134" database="jakingtestdb05" />
<dataNode name="dnmycatdb6" dataHost="192.168.25.134" database="jakingtestdb06" />
<dataNode name="dnmycatdb7" dataHost="192.168.25.134" database="jakingtestdb07" />
<dataNode name="dnmycatdb8" dataHost="192.168.25.134" database="jakingtestdb08" />
<dataNode name="dnmycatdb9" dataHost="192.168.25.134" database="jakingtestdb09" />
<dataNode name="dnmycatdb10" dataHost="192.168.25.134" database="jakingtestdb10" />
<dataNode name="dnmycatdb11" dataHost="192.168.25.134" database="jakingtestdb11" />
<dataNode name="dnmycatdb12" dataHost="192.168.25.134" database="jakingtestdb12" />
	
	
<!-- 设定数据节点 dnmycatdb13-dnmycatdb24 对应的 192.168.25.135 服务以及对应的物理 schema --> 
<dataNode name="dnmycatdb13" dataHost="192.168.25.135" database="jakingtestdb13" />
<dataNode name="dnmycatdb14" dataHost="192.168.25.135" database="jakingtestdb14" /> 
<dataNode name="dnmycatdb15" dataHost="192.168.25.135" database="jakingtestdb15" /> 
<dataNode name="dnmycatdb16" dataHost="192.168.25.135" database="jakingtestdb16" /> 
<dataNode name="dnmycatdb17" dataHost="192.168.25.135" database="jakingtestdb17" /> 
<dataNode name="dnmycatdb18" dataHost="192.168.25.135" database="jakingtestdb18" /> 
<dataNode name="dnmycatdb19" dataHost="192.168.25.135" database="jakingtestdb19" /> 
<dataNode name="dnmycatdb20" dataHost="192.168.25.135" database="jakingtestdb20" /> 
<dataNode name="dnmycatdb21" dataHost="192.168.25.135" database="jakingtestdb21" /> 
<dataNode name="dnmycatdb22" dataHost="192.168.25.135" database="jakingtestdb22" /> 
<dataNode name="dnmycatdb23" dataHost="192.168.25.135" database="jakingtestdb23" /> 
<dataNode name="dnmycatdb24" dataHost="192.168.25.135" database="jakingtestdb24" />
	
	
<!-- 设定数据节点 dnmycatdb25-dnmycatdb36 对应的 192.168.25.136 服务以及对应的物理 schema --> 
<dataNode name="dnmycatdb25" dataHost="192.168.25.136" database="jakingtestdb25" /> 
<dataNode name="dnmycatdb26" dataHost="192.168.25.136" database="jakingtestdb26" /> 
<dataNode name="dnmycatdb27" dataHost="192.168.25.136" database="jakingtestdb27" /> 
<dataNode name="dnmycatdb28" dataHost="192.168.25.136" database="jakingtestdb28" /> 
<dataNode name="dnmycatdb29" dataHost="192.168.25.136" database="jakingtestdb29" /> 
<dataNode name="dnmycatdb30" dataHost="192.168.25.136" database="jakingtestdb30" /> 
<dataNode name="dnmycatdb31" dataHost="192.168.25.136" database="jakingtestdb31" /> 
<dataNode name="dnmycatdb32" dataHost="192.168.25.136" database="jakingtestdb32" /> 
<dataNode name="dnmycatdb33" dataHost="192.168.25.136" database="jakingtestdb33" /> 
<dataNode name="dnmycatdb34" dataHost="192.168.25.136" database="jakingtestdb34" /> 
<dataNode name="dnmycatdb35" dataHost="192.168.25.136" database="jakingtestdb35" />
<dataNode name="dnmycatdb36" dataHost="192.168.25.136" database="jakingtestdb36" />

<!-- 设定物理机，若要做读写分离可以参考上面的部分 --> 
<dataHost name="192.168.25.134" maxCon="1000" minCon="10" balance="1" 
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.134" url="192.168.25.134:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost>

<dataHost name="192.168.25.135" maxCon="1000" minCon="10" balance="1"
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.135" url="192.168.25.135:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost>

<dataHost name="192.168.25.136" maxCon="1000" minCon="10" balance="1" 
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.136" url="192.168.25.136:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost> 
</mycat:schema>
```

配置 rule.xml 文件  192.168.25.133

```
<!DOCTYPE mycat:rule SYSTEM "rule.dtd">
<mycat:rule xmlns:mycat="http://io.mycat/">

<tableRule name="sharding-by-intfile-mycatdb-jakingtest_member"> 
<rule> 
	<columns>region</columns> 
	<algorithm>hash-int</algorithm> 
</rule> 
</tableRule> 

<function name="hash-int" class="io.mycat.route.function.PartitionByFileMap"> 
	<property name="mapFile">partition-hash-int-mycatdb-jakingtest_member.txt</property> 
	<property name="type">1</property> 
	<property name="defaultNode">0</property>
<!-- type 默认值为0，0表示integer，非零表示string,所有节点配置都是从0开始，即0代表节点1 --> 
</function> 
</mycat:rule>
```

vim /mysql/app/mycat/conf/partition-hash-int-mycatdb-jakingtest_member.txt

```
北京市=0
上海市=1
云南省=2
内蒙古=3
贵州省=4
重庆市=5
台湾省=6
吉林省=7
四川省=8
天津市=9
宁夏省=10
安徽省=11
山东省=12
山西省=13
广东省=14
广西省=15
新疆省=16
江苏省=17
江西省=18
河北省=19
河南省=20
浙江省=21
海南省=22
湖北省=23
湖南省=24
澳门=25
甘肃省=26
福建省=27
西藏=28
辽宁省=29
陕西省=30
青海省=31
香港=32
黑龙江省=33
广州市=34
DEFAULT_NODE=35
```

配置 server.xml 文件  192.168.25.133

vim /mysql/app/mycat/conf/server.xml

```
 修改内容
 93         <user name="root" defaultAccount="true">
 94                 <property name="password">Jaking@vip.163.com</property>
 95                 <property name="schemas">mycatdb</property>


108         <user name="mycat">
109                 <property name="password">Jaking@vip.163.com</property>
110                 <property name="schemas">mycatdb</property>
111                 <property name="readOnly">true</property>
112         </user>

```

启动mycat 观察，启动日志

```
tail -20f /mysql/app/mycat/logs/wrapper.log

systemctl stop mycat
systemctl start mycat
systemctl status mycat
```

登陆mycat 查看数据源  192.168.25.134

```
mysql -uroot -pJaking@vip.163.com -P9066 -h192.168.25.133
show @@help;
show @@databases;
show @@datasource;
show @@heartbeat;
```

访问mycat 测试  192.168.25.134

```
mysql -uroot -pJaking@vip.163.com -P8066 -h192.168.25.133 -Dmycatdb
show databases;
show tables;
```

注意：一定要把3个节点的MySQL 自动提交的参数打开！

```
echo autocommit=1 >> /etc/my.cnf
systemctl restart mysqld

mysql -uroot -pJaking@vip.163.com
set global autocommit=1;
show global variables like 'autocommit';
```

导入数据

```
192.168.25.134
mysql -uroot -pJaking@vip.163.com -h192.168.25.133 -P8066 mycatdb < /root/jakingtest_member.sql
```

查看数据

```
mysql -uroot -pJaking@vip.163.com -P8066 -h192.168.25.133 -Dmycatdb
use mycatdb;
select count(*) from jakingtest_member;

select table_schema,table_name as "Tables",ROUND(((data_length + index_length) / 1024 / 1024), 2) \
"Size in MB" from information_schema.TABLES \
where TABLE_NAME = "jakingtest_member" order by (data_length + index_length) desc;

select * from jakingtest_member where id = 20000210;
```

192.168.25.134、135、136  查看分片数据

```
mysql -uroot -pJaking@vip.163.com -h192.168.25.134
select count(*) ,region from jakingtestdb10.jakingtest_member group by region; 
exit; 

mysql -uroot -pJaking@vip.163.com -h192.168.25.135 
select count(*) ,region from jakingtestdb20.jakingtest_member group by region; 
exit; 

mysql -uroot -pJaking@vip.163.com -h192.168.25.136
select count(*) ,region from jakingtestdb30.jakingtest_member group by region; 
exit;
```

访问mycat 测试,清理掉所有数据

```
mysql -uroot -pJaking@vip.163.com -h192.168.25.133 -P8066 mycatdb
use mycatdb;
truncate table jakingtest_member;
drop table jakingtest_member;
```

#### 4、mycat分库分表分片项目实战-水平分库-主键范围

192.168.25.134

```
mysql -uroot -pJaking@vip.163.com
drop database jakingtestdb01;
drop database jakingtestdb02;
drop database jakingtestdb03;
drop database jakingtestdb04;
drop database jakingtestdb05;
drop database jakingtestdb06;
drop database jakingtestdb07;
drop database jakingtestdb08;
drop database jakingtestdb09;
drop database jakingtestdb10;
drop database jakingtestdb11;
drop database jakingtestdb12;
create database jakingtestdb01 default character set utf8; 
create database jakingtestdb02 default character set utf8; 
create database jakingtestdb03 default character set utf8; 
show databases;
```

192.168.25.135

```
mysql -uroot -pJaking@vip.163.com
drop database jakingtestdb13;
drop database jakingtestdb14;
drop database jakingtestdb15;
drop database jakingtestdb16;
drop database jakingtestdb17;
drop database jakingtestdb18;
drop database jakingtestdb19;
drop database jakingtestdb20;
drop database jakingtestdb21;
drop database jakingtestdb22;
drop database jakingtestdb23;
drop database jakingtestdb24;
create database jakingtestdb13 default character set utf8; 
create database jakingtestdb14 default character set utf8; 
create database jakingtestdb15 default character set utf8; 
show databases;
```

192.168.25.136

```
mysql -uroot -pJaking@vip.163.com
drop database jakingtestdb25;
drop database jakingtestdb26;
drop database jakingtestdb27;
drop database jakingtestdb28;
drop database jakingtestdb29;
drop database jakingtestdb30;
drop database jakingtestdb31;
drop database jakingtestdb32;
drop database jakingtestdb33;
drop database jakingtestdb34;
drop database jakingtestdb35;
drop database jakingtestdb36;
create database jakingtestdb25 default character set utf8; 
create database jakingtestdb26 default character set utf8; 
create database jakingtestdb27 default character set utf8; 
show databases;
```

配置 schema.xml 文件   192.168.25.133

```
cd /mysql/app/mycat/conf
mv schema.xml schema.xml.bak
vim schema.xml 
```

```
<?xml version="1.0"?> 
<!DOCTYPE mycat:schema SYSTEM "schema.dtd"> 
<mycat:schema xmlns:mycat="http://io.mycat/">
<schema name="mycatdb" checkSQLschema="false" sqlMaxLimit="100"> 
	<table name="jakingtest_member" dataNode="dnmycatdb$1-3,dnmycatdb$13-15,dnmycatdb$25-27" rule="auto-sharding-long"></table> 
</schema>
	
<!-- 设定数据节点 dnmycatdb1-dnmycatdb3 对应的 192.168.25.134 服务以及对应的物理 schema -->
<dataNode name="dnmycatdb1" dataHost="192.168.25.134" database="jakingtestdb01" />
<dataNode name="dnmycatdb2" dataHost="192.168.25.134" database="jakingtestdb02" />
<dataNode name="dnmycatdb3" dataHost="192.168.25.134" database="jakingtestdb03" />
	
	
<!-- 设定数据节点 dnmycatdb13-dnmycatdb15 对应的 192.168.25.135 服务以及对应的物理 schema --> 
<dataNode name="dnmycatdb13" dataHost="192.168.25.135" database="jakingtestdb13" /> 
<dataNode name="dnmycatdb14" dataHost="192.168.25.135" database="jakingtestdb14" /> 
<dataNode name="dnmycatdb15" dataHost="192.168.25.135" database="jakingtestdb15" />
	
	
<!-- 设定数据节点 dnmycatdb25-dnmycatdb27 对应的 192.168.25.136 服务以及对应的物理 schema --> 
<dataNode name="dnmycatdb25" dataHost="192.168.25.136" database="jakingtestdb25" /> 
<dataNode name="dnmycatdb26" dataHost="192.168.25.136" database="jakingtestdb26" /> 
<dataNode name="dnmycatdb27" dataHost="192.168.25.136" database="jakingtestdb27" />
	
<!-- 设定物理机--> 
<dataHost name="192.168.25.134" maxCon="1000" minCon="10" balance="1" 
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.134" url="192.168.25.134:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost>

<dataHost name="192.168.25.135" maxCon="1000" minCon="10" balance="1"
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.135" url="192.168.25.135:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost>

<dataHost name="192.168.25.136" maxCon="1000" minCon="10" balance="1" 
writeType="0" dbType="mysql" dbDriver="native"> 
<heartbeat>select user()</heartbeat> 
<!-- can have multi write hosts --> 
<writeHost host="192.168.25.136" url="192.168.25.136:3306" user="root" password="Jaking@vip.163.com" /> 
</dataHost> 
</mycat:schema>
```

配置 rule.xml 文件  192.168.25.133

```
cd /mysql/app/mycat/conf
mv rule.xml rule.xml.bak
vim rule.xml
```

```
<!DOCTYPE mycat:rule SYSTEM "rule.dtd">
<mycat:rule xmlns:mycat="http://io.mycat/">

<tableRule name="auto-sharding-long"> 
<rule> 
	<columns>id</columns> 
	<algorithm>rang-long</algorithm> 
</rule> 
</tableRule> 

<function name="rang-long" class="io.mycat.route.function.AutoPartitionByLong"> 
	<property name="mapFile">autopartition-long-jakingtest_member.txt</property> 
	<property name="defaultNode">0</property>
<!-- type 默认值为0，0表示integer，非零表示string,所有节点配置都是从0开始，即0代表节点1 --> 
</function> 
</mycat:rule>
```

vim /mysql/app/mycat/conf/autopartition-long-jakingtest_member.txt

```
20000000-20005000=0
20005001-20010000=1
20010001-20015000=2
20015001-20020000=3
20020001-20025000=4
20025001-20030000=5
20030001-20035000=6
20035001-20040000=7
20040001-20050000=8
```

配置 server.xml 文件  192.168.25.133

vim server.xml

```
修改内容
 93         <user name="root" defaultAccount="true">
 94                 <property name="password">Jaking@vip.163.com</property>
 95                 <property name="schemas">mycatdb</property>
 96 
 97                 <!-- 表级 DML 权限设置 -->
 98                 <!--            
 99                 <privileges check="false">
100                         <schema name="TESTDB" dml="0110" >
101                                 <table name="tb01" dml="0000"></table>
102                                 <table name="tb02" dml="1111"></table>
103                         </schema>
104                 </privileges>           
105                  -->
106         </user>
107 
108         <user name="mycat">
109                 <property name="password">Jaking@vip.163.com</property>
110                 <property name="schemas">mycatdb</property>
111                 <property name="readOnly">true</property>
112         </user>
113 
114 </mycat:server>
```

启动mycat 观察，启动日志   192.168.25.133

```
tail -20f /mysql/app/mycat/logs/wrapper.log

systemctl stop mycat
systemctl start mycat
systemctl status mycat
```

192.168.25.133  操作

```
mysql -uroot -pJaking@vip.163.com -P9066 -h192.168.25.133
show @@help;
show @@databases;
show @@datasource;
show @@heartbeat;
```

访问mycat 测试,导入数据  192.168.25.134

```
mysql -uroot -pJaking@vip.163.com -P8066 -h192.168.25.133 -Dmycatdb
show databases;
show tables;
```

导入数据  192.168.25.134

```
注意：一定要把3个节点的MySQL 自动提交的参数打开。134、135、136
set global autocommit=1;
```

```
mysql -uroot -pJaking@vip.163.com -h192.168.25.133 -P8066 mycatdb < /root/jakingtest_member.sql 
```

查询数据量

```
mysql -uroot -pJaking@vip.163.com -P8066 -h192.168.25.133 -Dmycatdb
use mycatdb;
select count(*) from jakingtest_member;

select table_schema,table_name as "Tables",ROUND(((data_length + index_length) / 1024 / 1024), 2) \
"Size in MB" from information_schema.TABLES \
where TABLE_NAME = "jakingtest_member" order by (data_length + index_length) desc;
```

192.168.25.134、135、136 查看分片数据

```
mysql -uroot -pJaking@vip.163.com -h192.168.25.134
select count(*) from jakingtestdb01.jakingtest_member; 
select count(*) from jakingtestdb02.jakingtest_member; 
select count(*) from jakingtestdb03.jakingtest_member;
show databases;
exit; 

mysql -uroot -pJaking@vip.163.com -h192.168.25.135
select count(*) from jakingtestdb13.jakingtest_member; 
select count(*) from jakingtestdb14.jakingtest_member; 
select count(*) from jakingtestdb15.jakingtest_member;
show databases;
exit; 

mysql -uroot -pJaking@vip.163.com -h192.168.25.136
select count(*) from jakingtestdb25.jakingtest_member; 
select count(*) from jakingtestdb26.jakingtest_member; 
select count(*) from jakingtestdb27.jakingtest_member;
show databases;
exit;
```

访问mycat 测试,清理掉所有数据

```
mysql -uroot -pJaking@vip.163.com -h192.168.25.133 -P8066 mycatdb
use mycatdb;
truncate table jakingtest_member;
drop table jakingtest_member;
```

