---
layout: post
title: 面试题
subtitle: 面试可能会遇到的问题
author: FatGuy010
permalink: /InterviewQuestions
tags: [ 面试 ]
---



## 结构和非结构化数据

结构化数据和非结构化数据是两种主要的数据类型，它们在存储、处理和分析时有着本质的不同。

### 结构化数据

结构化数据是指那些高度组织和格式化的数据，因此可以轻松地被搜索引擎和数据挖掘工具所读取、搜索和分析。它们通常存储在关系数据库（如 MySQL、PostgreSQL、Oracle）中，并且有严格定义的数据模型和关系，如表格中的行和列。每一列都有一个预定义的数据类型，所有的数据项都符合这个数据类型。

**例子**：
- 客户信息表格，包括姓名、地址、电话号码等。
- 销售数据，包括日期、销售额、客户ID等。
- 库存管理系统中的物品清单。

结构化数据的优点是易于查询和更新，支持通过SQL（结构化查询语言）等查询语言进行高效的数据操作和分析。

### 非结构化数据

非结构化数据是指没有预定义数据模型的数据，也不容易放入传统的关系数据库中。这类数据包括文本、图像、音频、视频等，通常存储在文件系统中或者使用专门的存储系统和数据仓库。

**例子**：
- 邮件、PDF文件、Word文档等文本文件。
- 数码照片、视频剪辑等多媒体文件。
- 社交媒体帖子、博客文章等网络内容。

非结构化数据的挑战在于它的多样性和复杂性，需要使用特定的工具和技术来处理和分析，例如文本分析、图像识别和自然语言处理。

### 半结构化数据

除了结构化和非结构化数据之外，还有一种被称为半结构化数据的类型，它是介于结构化和非结构化数据之间的数据。它们可能不符合严格的数据模型，但仍然包含标签或其他标记来分隔语义元素，并支持数据的层次化组织。

**例子**：
- XML和JSON文件，它们包含标记或键值对，用于描述数据，但不符合固定的模式或结构。
- 电子数据交换（EDI）文件，它们用于商业交易，并遵循特定的格式标准，但并非存储在关系数据库中。

在现代数据管理和分析中，能够有效地处理结构化和非结构化数据是非常重要的，因为它们可以提供不同的视角和洞察力。随着大数据技术的发展，非结构化数据的重要性日益增加，因为它构成了世界数据量的一个很大比例。



## 容器与虚拟机的区别

容器和虚拟机都是提供隔离环境以运行应用程序的技术，但它们在架构和运行机制上有本质的不同。

### 虚拟机（VM）

虚拟机是一种基于硬件的虚拟化技术。每个虚拟机都包括完整的操作系统，以及运行在该操作系统之上的应用程序和必要的库。虚拟机由一个称为**虚拟机监控器**（Hypervisor）的软件组件管理，它负责在物理硬件和各个虚拟机之间进行调度。

**特点**：
- **完全隔离**：每个虚拟机都是完全独立的。
- **资源消耗**：因为每个虚拟机都运行一个完整的操作系统，所以相对占用更多的资源。
- **启动时间**：虚拟机的启动通常需要几分钟，因为需要加载整个操作系统。
- **可移植性**：虚拟机可以在不同的物理机器和虚拟化平台之间迁移，但通常体积较大，迁移速度较慢。

### 容器

容器是一种基于操作系统级别的虚拟化。与虚拟机不同，容器共享宿主机的操作系统内核，但在用户空间中为每个容器提供隔离的环境。容器内部包含应用程序和其依赖的库和设置，但不包括整个操作系统。

**特点**：
- **轻量级**：容器共享宿主机的操作系统内核，因此占用的资源比虚拟机少得多。
- **快速启动**：容器只需启动应用程序，而不是整个操作系统，因此启动通常在几秒钟内完成。
- **密度高**：在同等硬件上，可以运行更多的容器实例。
- **可移植性**：容器的体积小，易于快速迁移和扩展。

### 对比总结

- **隔离级别**：虚拟机提供硬件级别的完全隔离，而容器提供的是操作系统级别的隔离。
- **性能开销**：虚拟机包含完整的操作系统副本，导致更高的性能开销。容器由于共享宿主操作系统的内核，因此开销更小。
- **启动速度**：虚拟机启动慢，容器启动快。
- **系统兼容性**：虚拟机可以运行不同于宿主机的操作系统，而容器则受限于宿主机的操作系统内核。
- **管理工具**：虚拟机通常使用VMware、Hyper-V等虚拟化平台管理，容器则使用Docker、Kubernetes等容器管理工具。

在实际应用中，虚拟机更适用于需要完全隔离和安全保障的环境，而容器则因其轻量级和快速部署的特性，适用于微服务架构和持续集成/持续部署（CI/CD）的环境。



## 关系型数据和非关系型数据

关系型数据和非关系型数据是指存储在关系型数据库和非关系型数据库中的数据类型，它们具有不同的数据模型和用例。

### 关系型数据（Relational Data）

关系型数据基于关系模型，这种模型由数学家E.F. Codd在1970年提出。关系型数据库管理系统（RDBMS）如MySQL、PostgreSQL、Oracle和SQL Server等广泛采用这一模型。

**特点**：

- **结构化**：数据以表格的形式存储，每个表都有固定的列（属性）和多行（记录）。
- **严格的模式**：定义了数据的结构，包括数据类型、关系等，所有数据写入前都需要符合这个模式。
- **数据完整性**：通过主键、外键、索引、约束等机制来维护数据的准确性和一致性。
- **支持复杂的查询**：使用结构化查询语言（SQL）进行高度复杂的数据查询。
- **事务支持**：具有事务处理的能力，遵循ACID原则（原子性、一致性、隔离性、持久性）。

### 非关系型数据（Non-Relational Data）

非关系型数据，也称为NoSQL数据，存储在非关系型数据库中，如MongoDB、Cassandra、Redis和Elasticsearch等。这些数据库不遵循传统的关系模型，而是采用了其他种类的数据模型。

**特点**：

- **灵活的模式**：数据结构可以动态修改，不需要预先定义。
- **多样的数据模型**：包括键值对（Key-Value）、文档（Document）、列族（Column-Family）和图（Graph）等。
- **可扩展性**：通常设计为易于水平扩展，通过增加更多的服务器来提升性能和存储能力。
- **优化为特定类型的查询**：每种NoSQL数据库可能针对特定模式的查询或存储需求进行了优化。
- **事务支持差异**：NoSQL数据库通常不提供全面的ACID事务支持，尽管某些数据库开始提供类似功能。

### 使用场景

- **关系型数据库**通常用于需要严格数据完整性和复杂查询的应用，例如金融服务、会计系统和其他需要复杂事务处理的应用程序。
- **非关系型数据库**适用于数据模式不固定、需要水平扩展或对读写性能有特别要求的场景，如大数据分析、实时数据处理、内容管理系统等。



## 如何查看主从延时情况？

在使用MySQL关系型数据库的主从复制架构中，"主从延时"指的是从服务器复制主服务器上的数据变化所经历的时间差。这个延时可能是由网络延迟、从服务器的负载或复制过程中的SQL执行时间等因素造成的。

### 1. SHOW SLAVE STATUS命令

在MySQL中，可以在从服务器上执行`SHOW SLAVE STATUS\G`命令来查看复制状态，包括延时情况。这个命令会返回一个包含复制状态信息的结果集，其中的`Seconds_Behind_Master`字段显示了从服务器落后于主服务器的秒数。

```sql
SHOW SLAVE STATUS\G
```

查看输出结果中的`Seconds_Behind_Master`值：

- 如果这个值是`0`，表示主从复制良好。

- 如果这个值是一个非零的数字，它表示从服务器落后于主服务器的秒数，数字越大表示从库延迟越严重。

- 如果这个值是`NULL`，表示`io_thread`或是`sql_thread`有任何一个发生故障。

### 2. Performance Schema

从MySQL 5.6开始，可以使用Performance Schema来监控复制延迟。首先，需要确保Performance Schema被启用，并且相关的复制表也被激活。然后，可以查询`performance_schema.replication_applier_status_by_worker`表来获取复制延迟的信息。

### 3. pt-heartbeat

`pt-heartbeat`是Percona Toolkit工具套件中的一个工具，它可以更精确地测量复制延迟。它通过在主服务器上创建一个记录心跳时间的表，并定期更新这个表来工作。从服务器上的`pt-heartbeat`进程会监测这个表，并计算出主从同步的延迟时间。

### 4. 自定义脚本

可以编写自定义脚本来检测主从延迟。这些脚本通常在主服务器上插入时间戳记录，在从服务器上读取这些记录，并计算出时间差。

### 5. 第三方监控工具

还可以使用第三方监控工具，如Zabbix、Nagios、Prometheus等，配合相关插件来监控MySQL复制延迟。

### 6. MySQL Shell的复制报告

MySQL Shell是MySQL 8.0引入的一个高级客户端和代码编辑器。在MySQL Shell中，可以使用复制报告功能来检查复制状态，包括延迟。



## 解决数据丢失的问题

### 半同步复制

从MySQL5.5开始，MySQL已经支持半同步复制了，半同步复制介于异步复制和同步复制之间，主库在执行完事务后不立刻返回结果给客户端，需要等待至少一个从库接收到并写到relay log中才返回结果给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一个TCP/IP往返耗时的延迟。



## 解决从库复制延迟的问题

### 优化网络

### 升级Slave硬件配置

### Slave调整参数，关闭`binlog`，修改`innodb_flush_log_at_trx_commit`参数值

### 升级MySQL版本到5.7，使用并行复制



## Linux 开机启动过程

1. 开机BIOS自检
2. MBR引导
3. GRUB引导菜单
4. 加载内核Kernel
5. 初始化init/systemd
6. 运行程序
7. 提示登陆



## CI/CD的几种发布方式

### 蓝绿部署（Blue-Green Deployment）：

- 在蓝绿部署中，有两套完全相同的生产环境，分别称为蓝环境和绿环境。在任何时刻，只有一套环境在向用户提供服务，而另一套环境则处于闲置状态。当新版本准备好发布时，流量被切换到处于闲置状态的环境，从而实现零停机时间的部署。

  **特点**

  - 蓝绿部署的目的是减少发布时的中断时间、能够快速撤回发布
  - 发布策略简单
  - 用户无感知，平滑过渡
  - 升级/回滚速度快

  **缺点**

  - 需要准备正常业务使用资源的两倍以上服务器，防止升级期间单组无法承载业务突发
  - 短时间内浪费一定资源成本
  - 基础设施无改动，增大升级稳定性

### 金丝雀部署/灰度发布（Canary Deployment）：

- 金丝雀部署是一种逐步发布新版本的方式，它允许只向一小部分用户或流量引入新版本，以便在实际生产环境中进行测试。如果新版本没有引发问题，可以逐渐增加流量直至全部流量都使用新版本。

  **特点**

  - 保证整体系统稳定性，在初始灰度的时候就可以发现、调整问题，影响范围可控
  - 新功能逐步评估性能，稳定性和健康状况，如果出问题影响范围很小，相对用户体验也少
  - 用户无感知，平滑过渡

  **缺点**

  - 自动化要求高

### 滚动部署（Rolling Deployment）：

- 在滚动部署中，新版本逐步替换旧版本，通常是逐个节点或逐批节点地进行。这种方式可以确保系统的稳定性，因为在部署过程中，总是有一部分节点在提供服务。

  **特点**

  - 用户无感知，平滑过渡
  - 节约资源

  **缺点**

  - 部署时间慢，取决于每阶段更新时间
  - 发布策略较复杂
  - 无法确定OK的环境，不易回滚

### 增量部署（Incremental Deployment）：

- 增量部署是一种将新功能逐步添加到生产环境中的方式。这种方式通常用于大型系统或对稳定性要求较高的系统，以确保新功能的逐步引入不会对整个系统造成过大的影响。



## 一次域名请求经过的协议

一次域名请求通常会涉及到DNS 解析、HTTP/HTTPS 请求、TCP连接、安全传输协议（如果是 HTTPS 请求的话），以及可能的其他应用层协议(例如：FTP、STMP)。